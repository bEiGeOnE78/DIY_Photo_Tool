<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Gallery Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        background: #181818;
        color: #eee;
        font-family: system-ui, sans-serif;
      }
      #main {
        display: flex;
        height: 100vh;
      }
      #gallery-selector {
        width: 0;
        min-width: 0;
        background: #1e1e1e;
        color: #fff;
        border-right: 1px solid #333;
        padding: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 6px;
        z-index: 300;
      }
      #gallery-selector.visible {
        width: 228px;
        min-width: 180px;
        padding: 12px;
        overflow-y: auto;
      }
      .gallery-item {
        padding: 8px 10px;
        background: #2a2a2a;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
        font-size: 11px;
        font-weight: 500;
        border: 1px solid transparent;
        line-height: 1.3;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .gallery-item:hover {
        background: #3a3a3a;
      }
      .gallery-item.active {
        background: #0066cc;
        border-color: #41aaff;
      }
      .gallery-count-badge {
        background: #666;
        color: #ccc;
        font-size: 8px;
        font-weight: 600;
        padding: 2px 6px;
        border-radius: 8px;
        margin-left: auto;
        min-width: 16px;
        text-align: center;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }
      .gallery-item.active .gallery-count-badge {
        background: #4CAF50;
        color: white;
      }
      .gallery-item.keyboard-selected {
        background: #804dcc;
        border-color: #b366ff;
      }
      .gallery-item.keyboard-selected .gallery-count-badge {
        background: #9966cc;
        color: white;
      }
      .gallery-selector.focused {
        border: 2px solid #9966cc;
        background: rgba(153, 102, 204, 0.1);
      }
      .gallery-item.active.gallery-focused {
        background: #0066cc;
        border: 2px solid #9966cc;
      }
      .gallery-header {
        font-weight: 600;
        margin-bottom: 8px;
        padding: 6px 0;
        border-bottom: 1px solid #333;
        color: #999;
        font-size: 9px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      #sidebar {
        width: 0;
        min-width: 0;
        max-width: 0;
        background: #1e1e1e;
        color: #fff;
        border-left: 1px solid #333;
        box-sizing: border-box;
        padding: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 12px;
        z-index: 300;
      }
      #sidebar.visible {
        width: 240px;
        min-width: 200px;
        max-width: 280px;
        padding: 16px 12px;
        overflow-y: auto;
      }
      .meta-table {
        font-size: 10px;
        width: 100%;
        border-collapse: collapse;
        line-height: 1.3;
      }
      .meta-table td {
        padding: 2px 3px;
        vertical-align: top;
      }
      .meta-table td:first-child {
        color: #999;
        font-weight: 500;
        width: 55px;
        font-size: 9px;
        text-transform: uppercase;
        letter-spacing: 0.4px;
      }
      .meta-table td:last-child {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
        font-size: 10px;
        color: #e0e0e0;
      }
      .map-iframe {
        width: 100%;
        height: 120px;
        border: 0;
        border-radius: 6px;
        margin-top: 8px;
      }
      #gallery-area {
        flex: 1;
        position: relative;
        display: flex;
        flex-direction: column;
      }
      .thumb-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        gap: 14px;
        padding: 20px;
        overflow-y: auto;
        flex: 1;
        background: rgba(25, 26, 29, 0.98);
        justify-content: space-evenly;
        align-content: start;
        align-items: start;
        z-index: 200;
      }
      .thumb-cell {
        background: #262626;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid transparent;
        border-radius: 10px;
        cursor: pointer;
        transition: border-color 0.12s;
        position: relative;
        aspect-ratio: 1;
        width: 100%;
      }
      .thumb-cell.highlight-selected {
        border-color: #ffaa00;
        background: rgba(255, 170, 0, 0.1);
        z-index: 2;
      }
      .thumb-cell.picked {
        border: 2px solid #0f0;
        box-shadow: 0 0 8px #0f0;
        z-index: 2;
      }
      /* Ensure selected picked images are clearly visible */
      .thumb-cell.picked.highlight-selected {
        border: 2px solid #ffaa00 !important;
        background: rgba(255, 170, 0, 0.3) !important;
        box-shadow: 0 0 12px rgba(255, 170, 0, 0.6), 0 0 8px rgba(0, 255, 0, 0.4) !important;
        z-index: 10 !important;
      }
      .thumb-cell img {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        display: block;
        object-fit: contain;
        transition: box-shadow 0.1s;
      }
      
      /* Video thumbnail filmstrip styling */
      .thumb-cell.video-thumbnail::before,
      .thumb-cell.video-thumbnail::after {
        content: '';
        position: absolute;
        left: 6px;
        right: 6px;
        height: 5px;
        background: repeating-linear-gradient(
          to right,
          #222 0px,
          #222 6px,
          #444 6px,
          #444 8px,
          #666 8px,
          #666 10px,
          #444 10px,
          #444 12px
        );
        opacity: 0.5;
        z-index: 1;
        border-radius: 3px;
      }
      
      .thumb-cell.video-thumbnail::before {
        top: 8px;
      }
      
      .thumb-cell.video-thumbnail::after {
        bottom: 8px;
      }
      
      #singleview {
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #181818;
        align-items: center;
        justify-content: center;
        z-index: 1;
        flex-direction: column;
        overflow: hidden;
      }
      #singleview.visible {
        z-index: 200;
      }
      .bigimg-wrap {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
      }
      /* Adjust single view position and size when sidebars are visible */
      /* Default: full screen with no sidebars */
      #singleview {
        left: 0;
        right: 0;
        width: 100%;
      }
      
      /* When gallery selector is visible, shift right and reduce width */
      #gallery-selector.visible ~ #gallery-area #singleview {
        left: 253px;
        width: calc(100% - 253px);
      }
      
      /* When metadata sidebar is visible, shift left and reduce width */
      #main:has(#sidebar.visible) #singleview {
        right: 240px;
        width: calc(100% - 240px);
      }
      
      /* When both sidebars are visible, adjust both sides */
      #main:has(#gallery-selector.visible):has(#sidebar.visible) #singleview {
        left: 253px;
        right: 240px;
        width: calc(100% - 493px);
      }
      .bigimg, .bigvideo {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        transition: box-shadow 0.13s;
        box-shadow: 0 4px 48px #000a;
        background: #222;
        cursor: pointer;
        position: relative;
        left: 0;
        top: 0;
        box-sizing: border-box;
      }
      .bigvideo {
        display: none; /* Hidden by default, shown when video is loaded */
        width: 100% !important;
        height: 100% !important;
        min-width: 640px !important;
        min-height: 360px !important;
        max-width: 100vw !important;
        max-height: 100vh !important;
        pointer-events: auto !important; /* Ensure mouse interactions work */
        z-index: 999 !important; /* Higher z-index to ensure it's not blocked */
        position: relative !important; /* Ensure z-index takes effect */
      }
      .bigimg.picked, .bigvideo.picked {
        border: 4px solid #0f0;
        box-shadow: 0 0 20px #0f0, 0 4px 48px #000a;
      }
      .bigimg.rejected, .bigvideo.rejected {
        border: 4px solid #ff4444;
        box-shadow: 0 0 20px #ff4444, 0 4px 48px #000a;
        opacity: 0.7;
      }
      .bigimg.pixelzoom {
        max-width: none;
        max-height: none;
        width: auto;
        height: auto;
        position: absolute;
        left: 0;
        top: 0;
        background: #222;
        cursor: grab;
        box-sizing: border-box;
      }
      .bigimg.pixelzoom.rejected {
        border: 4px solid #ff4444;
        box-shadow: 0 0 20px #ff4444, 0 4px 48px #000a;
        opacity: 0.7;
      }
      .bigimg.pixelzoom.picked {
        border: 4px solid #0f0;
        box-shadow: 0 0 20px #0f0, 0 4px 48px #000a;
      }
      
      /* Status indicator dots for full screen mode */
      .status-indicator {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        z-index: 600;
        display: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      }
      
      .status-indicator.picked {
        background: #00ff00;
        display: block;
      }
      
      .status-indicator.rejected {
        background: #ff4444;
        display: block;
      }
      .bigvideo {
        cursor: default;
      }
      .filename-overlay {
        position: absolute;
        bottom: 8px;
        left: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
        font-family: monospace;
        word-break: break-all;
        z-index: 12;
        display: none;
      }
      .filename-overlay.visible {
        display: block;
      }
      .face-overlay {
        position: absolute;
        border: 2px solid #00ff00;
        border-radius: 4px;
        background: transparent;
        pointer-events: auto;
        z-index: 500;
        display: none;
      }
      .face-overlay.visible {
        display: block;
      }
      .face-label {
        position: absolute;
        top: -25px;
        left: 0;
        background: rgba(0, 255, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        font-family: system-ui, sans-serif;
        white-space: nowrap;
      }
      .thumb-cell.rejected {
        border: 2px solid #ff4444 !important;
        opacity: 0.4;
        background: rgba(255, 68, 68, 0.1);
      }
      /* Ensure selected rejected images are clearly visible */
      .thumb-cell.rejected.highlight-selected {
        opacity: 0.8 !important;
        border: 2px solid #ffaa00 !important;
        background: rgba(255, 170, 0, 0.3) !important;
        box-shadow: 0 0 12px rgba(255, 170, 0, 0.6), 0 0 4px rgba(255, 68, 68, 0.4) !important;
        z-index: 10 !important;
      }
      #cull-strip {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 120px;
        background: #1a1a1a;
        border-top: 2px solid #333;
        display: none;
        flex-direction: row;
        align-items: center;
        gap: 10px;
        padding: 10px;
        overflow-x: auto;
        z-index: 100;
      }
      #cull-strip.visible {
        display: flex;
      }
      .cull-thumb {
        height: 100px;
        width: 100px;
        object-fit: cover;
        border: 2px solid #555;
        border-radius: 4px;
        cursor: pointer;
        flex-shrink: 0;
      }
      .cull-thumb.active {
        border-color: #0066cc;
        box-shadow: 0 0 10px rgba(0, 102, 204, 0.5);
      }
      .cull-thumb.pick {
        border-color: #00ff00;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }
      #cull-comparison {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 142px;
        background: #181818;
        display: none;
        z-index: 98;
      }
      #cull-comparison.visible {
        display: flex;
        gap: 10px;
        width: 100%;
        height: 100%;
      }
      #cull-comparison.full {
        overflow: hidden;
      }
      .cull-img-container {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .cull-img-container img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      #cull-comparison.full img {
        position: absolute;
        top: 0;
        left: 0;
        width: auto;
        height: auto;
        object-fit: none;
      }
      #cull-single.full img {
        position: absolute;
        top: 0;
        left: 0;
        width: auto;
        height: auto;
        object-fit: none;
      }
      .cull-side-images {
        width: 300px;
        background: #242424;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        gap: 5px;
        padding: 10px;
      }
      .cull-side-thumb {
        width: 100%;
        height: 120px;
        object-fit: cover;
        cursor: pointer;
        border: 2px solid #555;
        border-radius: 4px;
      }
      .cull-side-thumb.pick {
        border-color: #00ff00;
        box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
      }
      #cull-exit-hint {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 101;
        display: none;
      }
      #cull-exit-hint.visible {
        display: block;
      }
      @media (max-width: 700px) {
        #sidebar {
          width: 180px;
          min-width: 100px;
          font-size: 11px;
        }
        .meta-table {
          font-size: 12px;
        }
        .map-iframe {
          height: 90px;
        }
        .filename-overlay {
          font-size: 12px;
          padding: 6px 8px;
        }
      }

      /* Touch Device Toolbar */
      #touch-toolbar {
        display: none;
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 4px;
        padding: 8px 16px;
        z-index: 1000;
        gap: 12px;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      #touch-toolbar.visible {
        display: flex;
      }
      
      .touch-btn {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 9px 16px;
        color: #fff;
        font-size: 12px;
        font-weight: 600;
        font-family: 'Helvetica Neue', Arial, sans-serif;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: all 0.2s;
        min-width: 40px;
        text-align: center;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
      }
      
      .touch-btn:hover, .touch-btn:active {
        background: rgba(0, 0, 0, 0.9);
        border-color: rgba(255, 255, 255, 0.4);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
      }
      
      .touch-btn.active {
        background: #0066cc;
        border-color: #41aaff;
      }
      
      .touch-btn.pick {
        background: rgba(0, 255, 0, 0.2);
        border-color: rgba(0, 255, 0, 0.4);
      }
      
      .touch-btn.reject {
        background: rgba(255, 0, 0, 0.2);
        border-color: rgba(255, 0, 0, 0.4);
      }

      /* Cull Mode Toolbar */
      #cull-toolbar {
        display: none;
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 4px;
        padding: 8px 16px;
        z-index: 1000;
        gap: 12px;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      #cull-toolbar.visible {
        display: flex;
      }

      /* Touch selection indicator */
      .thumb-cell.touch-selected {
        border-color: #ffaa00;
        background: rgba(255, 170, 0, 0.2);
        transform: scale(0.95);
      }

      /* Sort controls */
      #sort-controls {
        background: #1e1e1e;
        border-bottom: 1px solid #333;
        padding: 8px 12px;
        display: flex !important;
        align-items: center;
        gap: 12px;
        font-size: 11px;
        color: #ccc;
        min-height: 36px;
        z-index: 100;
        position: relative;
      }
      
      .sort-btn {
        background: #2a2a2a;
        border: 1px solid #444;
        color: #ccc;
        padding: 4px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 10px;
        transition: all 0.2s;
      }
      
      .sort-btn:hover {
        background: #333;
        border-color: #555;
      }
      
      .sort-btn.active {
        background: #0066cc;
        border-color: #41aaff;
        color: white;
      }
      
      /* Command Palette - Spotlight style */
      #command-palette {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        display: none;
        align-items: flex-start;
        justify-content: center;
        padding-top: 100px;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      
      #command-palette.visible {
        display: flex;
        opacity: 1;
      }
      
      .command-palette-container {
        background: #2c2c2c;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        width: 90%;
        max-width: 600px;
        overflow: hidden;
        border: 1px solid #444;
      }
      
      .command-input-container {
        padding: 20px;
        border-bottom: 1px solid #444;
      }
      
      #command-input {
        width: 100%;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 18px;
        font-family: system-ui, sans-serif;
        outline: none;
        padding: 0;
      }
      
      #command-input::placeholder {
        color: #888;
      }
      
      .command-results {
        max-height: 400px;
        overflow-y: auto;
      }
      
      .command-item {
        padding: 12px 20px;
        border-bottom: 1px solid #333;
        cursor: pointer;
        transition: background 0.1s ease;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      
      .command-item:hover,
      .command-item.selected {
        background: #3c3c3c;
      }
      
      .command-item:last-child {
        border-bottom: none;
      }
      
      .command-item.disabled {
        opacity: 0.6;
        cursor: default;
      }
      
      .command-item.disabled:hover {
        background: transparent;
      }
      
      .command-item-left {
        display: flex;
        align-items: center;
        flex: 1;
      }
      
      .command-icon {
        width: 20px;
        height: 20px;
        margin-right: 12px;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .command-details {
        display: flex;
        flex-direction: column;
        flex: 1;
      }
      
      .command-title {
        color: #fff;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 2px;
      }
      
      .command-subtitle {
        color: #888;
        font-size: 12px;
      }
      
      .command-shortcut {
        color: #666;
        font-size: 11px;
        background: #1a1a1a;
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #333;
      }
      
      .command-preview {
        padding: 15px 20px;
        background: #1a1a1a;
        border-top: 1px solid #333;
        color: #aaa;
        font-size: 12px;
        line-height: 1.4;
      }
      
      .command-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 40px;
        color: #888;
      }
      
      .command-loading .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #333;
        border-top: 2px solid #666;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .command-mode-badge {
        padding: 8px 20px;
        background: #1a1a1a;
        border-bottom: 1px solid #333;
        display: flex;
        align-items: center;
      }
      
      .command-badge-content {
        display: flex;
        align-items: center;
        background: #333;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
        color: #fff;
      }
      
      .command-badge-icon {
        margin-right: 6px;
        font-size: 14px;
      }
      
      .command-badge-text {
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .leica-badge {
        display: inline-block;
        flex: 1;
        text-align: center;
        padding: 9px 16px;
        white-space: nowrap;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        font-size: 10px;
        font-weight: 600;
        font-family: 'Helvetica Neue', Arial, sans-serif;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      }
      
      /* Status Feed Styles */
      #status-feed {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 6px;
        margin-top: 12px;
        max-height: 200px;
        display: flex;
        flex-direction: column;
      }
      
      #status-feed-header {
        background: #2a2a2a;
        padding: 8px 10px;
        border-bottom: 1px solid #333;
        border-radius: 6px 6px 0 0;
        font-size: 10px;
        font-weight: 600;
        color: #ccc;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      #status-feed-content {
        flex: 1;
        overflow-y: auto;
        padding: 6px;
        max-height: 150px;
        font-size: 9px;
        font-family: 'SF Mono', Consolas, 'Monaco', monospace;
        line-height: 1.3;
      }
      
      .status-entry {
        padding: 2px 0;
        color: #ddd;
        display: flex;
        align-items: flex-start;
        gap: 6px;
      }
      
      .status-entry.success {
        color: #4CAF50;
      }
      
      .status-entry.error {
        color: #f44336;
      }
      
      .status-entry.warning {
        color: #ff9800;
      }
      
      .status-entry.info {
        color: #2196F3;
      }
      
      .status-timestamp {
        color: #666;
        font-size: 8px;
        min-width: 45px;
        flex-shrink: 0;
      }
      
      .status-message {
        flex: 1;
        word-break: break-word;
      }
      
      #status-feed.hidden {
        display: none;
      }
      
      #status-clear-btn {
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-size: 10px;
        padding: 2px 4px;
        border-radius: 3px;
        transition: color 0.2s;
      }
      
      #status-clear-btn:hover {
        color: #ccc;
        background: rgba(255, 255, 255, 0.1);
      }
    </style>
  </head>
  <body>
    <div id="main">
      <div id="gallery-selector" class="visible">
        <div class="gallery-header">Galleries</div>
      </div>
      <div id="gallery-area">
        <div id="sort-controls">
          <span>Sort:</span>
          <button class="sort-btn active" id="sort-oldest">Oldest First</button>
          <button class="sort-btn" id="sort-newest">Newest First</button>
        </div>
        <div class="thumb-grid" id="thumbgrid"></div>
        <div id="singleview">
          <div class="bigimg-wrap" id="bigimgWrap">
            <img id="bigimg" class="bigimg" draggable="false" />
            <video id="bigvideo" class="bigvideo" controls></video>
          </div>
          <div class="status-indicator" id="statusIndicator"></div>
        </div>
      </div>
      <div id="sidebar"></div>
      
      <!-- Touch Device Toolbars -->
      <div id="touch-toolbar">
        <button class="touch-btn" id="touch-gallery-btn">üìÅ</button>
        <button class="touch-btn" id="touch-pick-btn">‚úì</button>
        <button class="touch-btn" id="touch-reject-btn">‚úó</button>
        <button class="touch-btn" id="touch-faces-btn">üë§</button>
        <button class="touch-btn" id="touch-sidebar-btn">‚ÑπÔ∏è</button>
        <button class="touch-btn" id="touch-picks-btn">üìã</button>
        <button class="touch-btn" id="touch-status-btn">üìä</button>
        <button class="touch-btn" id="touch-command-btn">/</button>
        <button class="touch-btn" id="touch-prev-btn" style="display: none;">‚óÄ</button>
        <button class="touch-btn" id="touch-next-btn" style="display: none;">‚ñ∂</button>
        <button class="touch-btn" id="touch-clear-btn" style="display: none;">Clear</button>
        <button class="touch-btn" id="touch-cull-btn" style="display: none;">Cull</button>
        <button class="touch-btn" id="touch-finish-btn" style="display: none;">Finish</button>
      </div>
      
      <div id="cull-toolbar">
        <button class="touch-btn" id="cull-finish-btn">Finish</button>
        <button class="touch-btn" id="cull-cancel-btn">Cancel</button>
      </div>
      
      <!-- Cull Mode UI -->
      <div id="cull-strip">
      </div>
      
      <div id="cull-comparison">
        <div class="cull-img-container">
          <img id="cull-candidate-img" />
          <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; font-size: 14px; z-index: 1;">
            Candidate
          </div>
        </div>
        <div class="cull-img-container">
          <img id="cull-current-img" />
          <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; font-size: 14px; z-index: 1;">
            Current
          </div>
        </div>
      </div>
      
      <!-- Single image view for cull mode (when no candidate selected) -->
      <div id="cull-single" style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 142px;
        background: #181818;
        display: none;
        z-index: 98;
      ">
        <div class="cull-img-container" style="width: 100%; height: 100%;">
          <img id="cull-main-img" />
        </div>
      </div>
      
      
      <!-- Command Palette -->
      <div id="command-palette">
        <div class="command-palette-container">
          <div class="command-input-container">
            <input id="command-input" type="text" placeholder="Type a command..." autocomplete="off" spellcheck="false">
          </div>
          <div class="command-results" id="command-results">
            <!-- Command results will be populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>
    <script>
      // Dynamic API configuration based on current host
      function getApiBaseUrl() {
        const host = window.location.hostname;
        const port = 8001; // Face API server port
        
        // If accessing via localhost, use localhost for API
        if (host === 'localhost' || host === '127.0.0.1') {
          return `http://localhost:${port}`;
        }
        // Otherwise, use the same host as the current page
        return `http://${host}:${port}`;
      }
      
      const API_BASE_URL = getApiBaseUrl();
      
      let images = [],
        current = 0,
        mode = "thumbs",
        sidebarOpen = true,
        picks = new Set(),
        rejects = new Set(),
        galleries = [],
        currentGallery = null,
        gallerySelectorOpen = true,
        facesVisible = false,
        selectedThumbnails = new Set(),
        cullMode = false,
        cullImages = [],
        cullCurrent = 0,
        cullPick = -1,
        preloadCache = new Set(),
        isTouchDevice = false,
        touchStartTime = 0,
        touchTimeout = null,
        touchHoldThreshold = 500,
        touchMode = 'normal',
        touchStartX = 0,
        touchStartY = 0,
        touchMoveThreshold = 10,
        commandPaletteOpen = false,
        commandPaletteSelectedIndex = -1,
        commandPaletteItems = [],
        commandPaletteMode = null, // null, 'gallery'
        commandPaletteSearchString = '',
        inputFieldFocused = false,
        // Background preloading system
        preloadingActive = false,
        preloadQueue = [],
        preloadAbortController = null,
        preloadedImages = new Set(),
        currentPreloadIndex = 0,
        maxPreloadImages = 100,
        // DOM-based adjacent image system
        adjacentImages = {
          prev2: null, prev1: null, current: null, next1: null, next2: null
        },
        adjacentVideos = {
          prev2: null, prev1: null, current: null, next1: null, next2: null
        };
      const thumbgrid = document.getElementById("thumbgrid");
      const bigimg = document.getElementById("bigimg");
      const bigvideo = document.getElementById("bigvideo");
      const singleview = document.getElementById("singleview");
      
      // Debug video element at page load
      console.log('üé¨ Video element at page load:', {
        bigvideo: bigvideo,
        exists: !!bigvideo,
        inDOM: bigvideo && bigvideo.parentElement !== null,
        allVideoElements: document.querySelectorAll('video'),
        bigimgWrapContent: document.getElementById('bigimgWrap') ? document.getElementById('bigimgWrap').innerHTML : 'NO WRAP'
      });
      const sidebar = document.getElementById("sidebar");
      const commandPalette = document.getElementById("command-palette");
      const commandInput = document.getElementById("command-input");
      const commandResults = document.getElementById("command-results");
      const bigimgWrap = document.getElementById("bigimgWrap");
      const main = document.getElementById("main");

      function detectTouchDevice() {
        return ('ontouchstart' in window) || 
               (navigator.maxTouchPoints > 0) || 
               (navigator.msMaxTouchPoints > 0);
      }
      
      function isVideoFile(filename) {
        const videoExts = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.m4v'];
        const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
        return videoExts.includes(ext);
      }

      function convertDMSToDD(dms) {
        // Handle numeric values (already decimal degrees)
        if (typeof dms === 'number') return dms;
        
        // Convert "51 deg 20' 26.21" N" format to decimal degrees
        if (typeof dms === 'string') {
          const match = dms.match(/(\d+) deg (\d+)' ([\d.]+)"/);
          if (!match) return parseFloat(dms); // fallback if already decimal
          const degrees = parseFloat(match[1]);
          const minutes = parseFloat(match[2]);
          const seconds = parseFloat(match[3]);
          let dd = degrees + minutes/60 + seconds/3600;
          if (dms.includes('S') || dms.includes('W')) dd = -dd;
          return dd;
        }
        
        return parseFloat(dms) || 0;
      }
      
      let galleryCache = null;
      let galleryCacheBuilt = false;
      let galleriesListLoaded = false;
      
      async function getGalleryInfo(imageId) {
        try {
          // Load all gallery JSONs if not cached
          if (!galleryCacheBuilt) {
            galleryCache = {};
            galleryCacheBuilt = true;
            
            // Use the existing galleries data instead of fetching galleries.json
            if (!galleries || galleries.length === 0) {
              return ""; // No galleries loaded yet
            }
            
            // Load each gallery's JSON
            for (const gallery of galleries) {
              try {
                const galleryResponse = await fetch(gallery.jsonPath + '?t=' + Date.now());
                const galleryData = await galleryResponse.json();
                
                // Index by image ID
                for (const image of galleryData) {
                  if (image._imageId) {
                    if (!galleryCache[image._imageId]) {
                      galleryCache[image._imageId] = [];
                    }
                    galleryCache[image._imageId].push(gallery.name);
                  }
                }
              } catch (e) {
                console.log(`Could not load gallery ${gallery.name}:`, e);
              }
            }
            
          }
          
          const foundGalleries = galleryCache[imageId] || [];
          
          if (foundGalleries.length > 1) { // More than current gallery
            const currentGalleryName = currentGallery ? getGalleryNameFromPath(currentGallery) : '';
            const otherGalleries = foundGalleries.filter(name => name !== currentGalleryName);
            
            if (otherGalleries.length > 0) {
              return `
                <div style="margin-top: 10px; padding: 6px 8px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
                  <div style="font-size: 9px; font-weight: 600; margin-bottom: 4px; color: #999; text-transform: uppercase; letter-spacing: 0.5px;">Also In</div>
                  <div style="font-size: 10px; line-height: 1.3;">
                    ${otherGalleries.map(name => `<div style="color: #e0e0e0; margin-bottom: 2px;">${name}</div>`).join('')}
                  </div>
                </div>`;
            }
          }
          
          console.log('No other galleries found for image', imageId);
          return "";
        } catch (e) {
          console.log('Error loading gallery info:', e);
          return "";
        }
      }

      async function loadSidebar(idx) {
        if (!images[idx]) {
          sidebar.innerHTML = "";
          return;
        }
        const meta = images[idx];
        
        // Create Leica-style camera setting badges at the top
        let cameraSettings = "";
        const settingBadges = [];
        
        if (meta.FNumber) {
          settingBadges.push(`<span class="leica-badge">∆í/${meta.FNumber}</span>`);
        }
        if (meta.ExposureTime) {
          settingBadges.push(`<span class="leica-badge">${meta.ExposureTime}s</span>`);
        }
        if (meta.ISO) {
          settingBadges.push(`<span class="leica-badge">ISO ${meta.ISO}</span>`);
        }
        if (meta.ExposureCompensation) {
          const comp = parseFloat(meta.ExposureCompensation);
          const sign = comp > 0 ? '+' : '';
          settingBadges.push(`<span class="leica-badge">${sign}${comp}EV</span>`);
        }
        if (meta.FocalLengthIn35mmFormat) {
          const focalLength = String(meta.FocalLengthIn35mmFormat).replace(/[^\d.]/g, '');
          if (focalLength && !isNaN(parseFloat(focalLength))) {
            settingBadges.push(`<span class="leica-badge">${Math.round(parseFloat(focalLength))}mm</span>`);
          }
        }
        
        // Add RAW badge (simplified - no async database call)
        if (meta.raw_proxy_type && meta.raw_proxy_type !== 'none') {
          settingBadges.push(`<span class="leica-badge">RAW</span>`);
        }
        
        // Ensure file type badge is always added
        if (meta.FileType && !settingBadges.some(badge => badge.includes(meta.FileType))) {
          settingBadges.push(`<span class="leica-badge">${meta.FileType}</span>`);
        }
        
        // Add megapixels badge
        const width = meta.ImageWidth || meta.width;
        const height = meta.ImageHeight || meta.height;
        if (width && height) {
          const megapixels = Math.round(width * height / 1000000);
          settingBadges.push(`<span class="leica-badge">${megapixels}MP</span>`);
        }
        
        // Add film mode badge last
        if (meta.FilmMode) {
          const filmName = meta.FilmMode.includes('(') && meta.FilmMode.includes(')') 
            ? meta.FilmMode.match(/\(([^)]+)\)/)?.[1] || meta.FilmMode
            : meta.FilmMode;
          settingBadges.push(`<span class="leica-badge">${filmName}</span>`);
        }
        
        if (settingBadges.length > 0) {
          cameraSettings = `<div style="margin-bottom: 12px; display: flex; flex-wrap: wrap; gap: 8px;">${settingBadges.join('')}</div>`;
        }
        
        let table = `<table class="meta-table">`;
        if (meta.DateTimeOriginal)
          table += `<tr><td>Date</td><td>${meta.DateTimeOriginal.replace(/:/g, "-").replace(" ", "&nbsp;")}</td></tr>`;
        if (meta.Make || meta.Model)
          table += `<tr><td>Camera</td><td>${[meta.Make, meta.Model].filter(Boolean).join(" ")}</td></tr>`;
        if (meta.LensModel)
          table += `<tr><td>Lens</td><td>${meta.LensModel}</td></tr>`;
        if (meta.FocalLength) {
          const focalLength = String(meta.FocalLength).replace(/[^\d.]/g, '');
          if (focalLength && !isNaN(parseFloat(focalLength))) {
            table += `<tr><td>Focal</td><td>${Math.round(parseFloat(focalLength))}mm</td></tr>`;
          } else {
            table += `<tr><td>Focal</td><td>${meta.FocalLength}</td></tr>`;
          }
        }
        // Add pixel dimensions (but not megapixels - will be in badges)
        // Check multiple possible field names for dimensions
        const tableWidth = meta.ImageWidth || meta.width;
        const tableHeight = meta.ImageHeight || meta.height;
        if (tableWidth && tableHeight) {
          table += `<tr><td>Dimensions</td><td>${tableWidth} √ó ${tableHeight}</td></tr>`;
        }
        
        if (meta.GPSLatitude && meta.GPSLongitude)
          table += `<tr><td>GPS</td><td>${meta.GPSLatitude.toFixed(4)}, ${meta.GPSLongitude.toFixed(4)}</td></tr>`;
        // Get correct file type and path from database for RAW files
        let fileType = meta.FileType;
        let masterPath = meta._originalPath || meta.FileName;
        
        // Add file type badge early (before async RAW logic)
        if (fileType) {
          settingBadges.push(`<span class="leica-badge">${fileType}</span>`);
        }
        
        if (meta.raw_proxy_type && meta.raw_proxy_type !== 'none') {
          fileType = 'RAW';
        }
        if (masterPath) {
          table += `<tr><td>Master Path</td><td>${masterPath}</td></tr>`;
        }
        
        // Add face recognition metadata if available
        if (meta._personId) {
          table += `<tr><td colspan="2" style="color: #4CAF50; font-weight: bold; padding-top: 8px; border-top: 1px solid #444;">Face Recognition</td></tr>`;
          table += `<tr><td>Person ID</td><td>${meta._personId}</td></tr>`;
          if (meta._personName) {
            table += `<tr><td>Name</td><td>${meta._personName}${meta._personConfirmed ? ' ‚úì' : ' ?'}</td></tr>`;
          }
          if (meta._faceConfidence) {
            table += `<tr><td>Confidence</td><td>${(meta._faceConfidence * 100).toFixed(1)}%</td></tr>`;
          }
          if (meta._totalFaces) {
            table += `<tr><td>Total Faces</td><td>${meta._totalFaces}</td></tr>`;
          }
          if (meta._sampleNumber) {
            table += `<tr><td>Sample</td><td>${meta._sampleNumber}</td></tr>`;
          }
        }
        
        table += `</table>`;
        
        // Add proxy switching controls if applicable
        let proxyControls = "";
        if (meta._imageId) {
          proxyControls = await getProxyControls(meta._imageId);
        }
        
        // Add gallery information
        let galleryInfo = "";
        if (meta._imageId) {
          galleryInfo = await getGalleryInfo(meta._imageId);
        }
        
        let locationInfo = "";
        if (meta.GPSLatitude && meta.GPSLongitude) {
          const lat = convertDMSToDD(meta.GPSLatitude);
          const lon = convertDMSToDD(meta.GPSLongitude);
          locationInfo = `
            <div style="margin-top: 10px; padding: 6px 8px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
              <div style="font-size: 9px; font-weight: 600; margin-bottom: 4px; color: #999; text-transform: uppercase; letter-spacing: 0.5px;">Location</div>
              <div style="font-size: 10px; color: #ddd; margin-bottom: 4px; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;">
                ${lat.toFixed(6)}, ${lon.toFixed(6)}
              </div>
              <div style="display: flex; gap: 6px; margin-top: 4px;">
                <a href="https://maps.google.com/maps?q=${lat},${lon}" target="_blank" 
                   style="color: #4285f4; text-decoration: none; font-size: 9px; padding: 2px 4px; border-radius: 2px; background: rgba(66, 133, 244, 0.1);">Google Maps</a>
                <a href="https://www.openstreetmap.org/?mlat=${lat}&mlon=${lon}&zoom=15" target="_blank" 
                   style="color: #7ebc6f; text-decoration: none; font-size: 9px; padding: 2px 4px; border-radius: 2px; background: rgba(126, 188, 111, 0.1);">OpenStreetMap</a>
              </div>
            </div>`;
        }
        
        // Status feed HTML - always include
        const statusFeed = `
          <div id="status-feed" class="hidden">
            <div id="status-feed-header">
              <span>Status Feed</span>
              <button id="status-clear-btn" onclick="clearStatusFeed()">Clear</button>
            </div>
            <div id="status-feed-content">
              <!-- Status messages will appear here -->
            </div>
          </div>
        `;
        
        // Render initial content immediately (without proxy controls for performance)
        sidebar.innerHTML = cameraSettings + table + galleryInfo + locationInfo + statusFeed;
        
        // Load proxy controls asynchronously after initial render
        if (meta._imageId) {
          getProxyControls(meta._imageId).then(proxyControls => {
            // Insert proxy controls after the table but before gallery info
            sidebar.innerHTML = cameraSettings + table + proxyControls + galleryInfo + locationInfo + statusFeed;
          }).catch(error => {
            console.log('Could not load proxy controls:', error);
          });
        }
      }

      function showThumbs() {
        mode = "thumbs";
        
        // Use z-index instead of display changes for instant switching
        thumbgrid.style.zIndex = "200";   // Bring thumbnails to front
        singleview.style.zIndex = "1";    // Send single view to back
        singleview.classList.remove('visible');
        
        // Reset video z-index when switching to thumbnail mode
        const videoEl = document.getElementById('bigvideo');
        if (videoEl) {
          videoEl.style.zIndex = "1";
        }
        
        // Hide all adjacent images but keep them in DOM for fast re-entry
        Object.values(adjacentImages).forEach(img => {
          if (img) img.style.opacity = "0";
        });
        Object.values(adjacentVideos).forEach(video => {
          if (video) video.style.opacity = "0";
        });
        
        updateTouchToolbar();
        
        // Sync orange selection with current image from full screen navigation
        selectedThumbnails.clear();
        selectedThumbnails.add(current);
        
        updateSelectionDisplay();
        updatePickClasses();
        updateStatusIndicator();
        loadSidebar(current).catch(console.error);
      }
      function showSingle(fitOrZoom) {
        mode = fitOrZoom;
        
        // Use z-index instead of display changes for instant switching
        singleview.style.zIndex = "200";  // Bring to front
        thumbgrid.style.zIndex = "1";     // Send to back
        singleview.classList.add('visible');
        
        // Check if current item is a video
        const currentMeta = images[current];
        const currentSrc = currentMeta?.SourceFile || currentMeta?.src || currentMeta?.FileName || '';
        const isCurrentVideo = isVideoFile(currentSrc);
        
        if (isCurrentVideo) {
          // For videos, use the main bigvideo element directly
          console.log('üìπ Loading video in main bigvideo element');
          loadImage(current);
        } else {
          // Adjacent images should already be created from thumbnail selection
          // Only create them if they don't exist (fallback for edge cases)
          const currentElement = adjacentImages.current || adjacentVideos.current;
          if (!currentElement) {
            console.log('üîÑ Creating adjacent images as fallback');
            createAdjacentImageElements(current);
          } else {
            console.log('‚ú® Using pre-created adjacent images for instant display');
            // Make sure current image is visible
            if (adjacentImages.current) {
              adjacentImages.current.style.opacity = "1";
              adjacentImages.current.style.zIndex = "100";
            }
            if (adjacentVideos.current) {
              adjacentVideos.current.style.opacity = "1";
              adjacentVideos.current.style.zIndex = "100";
            }
          }
        }
        
        loadSidebar(current).catch(console.error);
        updateTouchToolbar();
      }
      function highlightSelected() {
        // No longer needed - orange selection handles this
        updatePickClasses();
      }
      function scrollThumbIntoView(idx) {
        const el = document.querySelector(`.thumb-cell[data-idx='${idx}']`);
        if (el) el.scrollIntoView({ block: "center", inline: "center" });
      }
      function getDisplaySource(meta, forceTimestamp = false) {
        const originalSrc = meta.SourceFile || meta.src || meta.FileName;
        const cleanSrc = originalSrc.replace(/^\.\//, "");
        
        // Check if this is a RAW file with a custom proxy
        if (meta._imageId && meta.has_custom_proxy && meta.raw_proxy_type === 'custom_generated') {
          const proxyPath = `RAW Proxies/${meta._imageId}.jpg`;
          return forceTimestamp ? proxyPath + '?t=' + Date.now() : proxyPath;
        }
        
        // Check if this is a HEIC file and if we have a WebP proxy
        if (meta._imageId && (cleanSrc.toLowerCase().endsWith('.heic') || meta.FileType === 'HEIC')) {
          // Use WebP proxy for display
          const proxyPath = `HEIC Proxies/${meta._imageId}.webp`;
          return forceTimestamp ? proxyPath + '?t=' + Date.now() : proxyPath;
        }
        
        // Check if this is a video file - in galleries, they're already proxy files
        if (isVideoFile(cleanSrc)) {
          // Video files in galleries are already the correct proxy files
          return forceTimestamp ? cleanSrc + '?t=' + Date.now() : cleanSrc;
        }
        
        // Use original file for other files
        const finalSrc = cleanSrc;
        return forceTimestamp ? finalSrc + '?t=' + Date.now() : finalSrc;
      }
      
      function loadImage(idx, forceRefresh = false) {
        if (!images[idx] || !currentGallery) return;
        
        // Use cached version unless forceRefresh is true (for RAW proxy changes)
        const meta = images[idx];
        const displaySrc = getDisplaySource(meta, forceRefresh);
        const originalSrc = meta.SourceFile || meta.src || meta.FileName;
        const cleanOriginalSrc = originalSrc.replace(/^\.\//, ""); // for filename extraction
        const imageId = meta._imageId;
        const isPicked = picks.has(imageId);
        const isRejected = rejects.has(imageId);
        
        console.log('üéØ loadImage called for:', {
          cleanOriginalSrc: cleanOriginalSrc,
          displaySrc: displaySrc,
          isVideo: isVideoFile(cleanOriginalSrc),
          imageId: imageId
        });
        
        if (isVideoFile(cleanOriginalSrc)) {
          // Debug logging for video loading
          console.log('üé¨ Loading video:', {
            cleanOriginalSrc: cleanOriginalSrc,
            displaySrc: displaySrc,
            imageId: imageId,
            bigvideoElement: bigvideo,
            bigvideoExists: !!bigvideo,
            bigvideoInDOM: bigvideo && bigvideo.parentElement !== null,
            bigvideoId: bigvideo ? bigvideo.id : 'NO ELEMENT'
          });
          
          // Use fresh DOM lookup instead of potentially detached cached variable
          const videoElement = document.getElementById('bigvideo');
          console.log('üé¨ Fresh video element check:', {
            element: videoElement,
            exists: !!videoElement,
            inDOM: videoElement && videoElement.parentElement !== null,
            parentTag: videoElement && videoElement.parentElement ? videoElement.parentElement.tagName : 'NO PARENT'
          });
          
          if (!videoElement) {
            console.error('üé¨ ERROR: Video element not found in DOM!');
            return;
          }
          
          if (!videoElement.parentElement) {
            console.error('üé¨ ERROR: Video element exists but not attached to DOM!');
            return;
          }
          
          // Add event listeners for debugging video loading
          videoElement.addEventListener('loadstart', () => console.log('üé¨ Video loadstart event'), { once: true });
          videoElement.addEventListener('loadedmetadata', () => console.log('üé¨ Video loadedmetadata event'), { once: true });
          videoElement.addEventListener('canplay', () => console.log('üé¨ Video canplay event'), { once: true });
          videoElement.addEventListener('error', (e) => console.error('üé¨ Video error:', e, videoElement.error), { once: true });
          
          // Add simple interaction debugging
          videoElement.addEventListener('click', () => console.log('üé¨ Video controls clicked'));
          
          // Show video, hide image
          console.log('üé¨ Setting video src to:', displaySrc);
          console.log('üé¨ Current base URL:', window.location.origin);
          
          // For videos, ensure we use absolute URL to prevent URI issues
          const absoluteVideoSrc = displaySrc.startsWith('http') ? displaySrc : `http://localhost:8000/${displaySrc}`;
          console.log('üé¨ Absolute video URL:', absoluteVideoSrc);
          
          // Ensure proper display switching for videos
          videoElement.src = absoluteVideoSrc;
          videoElement.style.display = "block";
          videoElement.style.zIndex = "999"; // Restore high z-index for control interaction
          
          // Hide image element using fresh DOM lookup
          const currentImageElement = document.getElementById('bigimg');
          if (currentImageElement) {
            currentImageElement.style.display = "none";
          }
          
          console.log('üé¨ Display set: video=block, image=none');
          
          // Ensure video is unmuted for autoplay
          videoElement.muted = false;
          videoElement.volume = 1.0; // Set to full volume
          
          // Debug key video properties
          console.log('üé¨ Video loaded:', {
            fileName: cleanOriginalSrc.split('/').pop(),
            dimensions: `${videoElement.offsetWidth}x${videoElement.offsetHeight}`,
            muted: videoElement.muted,
            controls: videoElement.controls
          });
          
          console.log('üé¨ Video src after setting:', videoElement.src);
          videoElement.classList.toggle("picked", isPicked);
          videoElement.classList.toggle("rejected", isRejected);
          
          // Auto-play the video immediately after setting source
          console.log('üé¨ Starting immediate auto-play...');
          setTimeout(() => {
            // For Firefox/Zen browser compatibility, try unmuting again
            videoElement.muted = false;
            videoElement.volume = 1.0;
            
            videoElement.play().then(() => {
              console.log('üé¨ Immediate auto-play successful!');
              // Force unmute after successful play
              setTimeout(() => {
                videoElement.muted = false;
                videoElement.volume = 1.0;
                console.log('üé¨ Post-play unmute applied');
              }, 50);
            }).catch(err => {
              console.log('üé¨ Immediate auto-play failed, will retry on canplay:', err.message);
              // If autoplay fails, try playing muted first then unmuting (Firefox workaround)
              videoElement.muted = true;
              videoElement.play().then(() => {
                console.log('üé¨ Playing muted, will unmute after user interaction');
                videoElement.muted = false;
                videoElement.volume = 1.0;
              }).catch(err2 => {
                console.log('üé¨ Even muted autoplay failed:', err2.message);
              });
            });
          }, 100);
          
          console.log('üé¨ Video element after src set:', {
            src: bigvideo.src,
            display: bigvideo.style.display,
            readyState: bigvideo.readyState,
            networkState: bigvideo.networkState
          });
          
          // Update status indicator dot
          const statusIndicator = document.getElementById('statusIndicator');
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
          
          // Load faces for videos (if any)
          bigvideo.addEventListener('loadedmetadata', () => loadFacesForCurrentImage(), { once: true });
          
          // Additional debugging after video is ready
          bigvideo.addEventListener('canplay', () => {
            console.log('üé¨ Video ready to play - element state:', {
              src: bigvideo.src,
              display: bigvideo.style.display,
              visibility: getComputedStyle(bigvideo).visibility,
              width: bigvideo.offsetWidth,
              height: bigvideo.offsetHeight,
              clientWidth: bigvideo.clientWidth,
              clientHeight: bigvideo.clientHeight,
              controls: bigvideo.controls,
              paused: bigvideo.paused,
              readyState: bigvideo.readyState,
              videoWidth: bigvideo.videoWidth,
              videoHeight: bigvideo.videoHeight,
              duration: bigvideo.duration,
              parentElement: bigvideo.parentElement,
              zIndex: getComputedStyle(bigvideo).zIndex
            });
            
            // Debug parent container dimensions
            const parent = bigvideo.parentElement;
            if (parent) {
              console.log('üé¨ Parent container state:', {
                tagName: parent.tagName,
                className: parent.className,
                offsetWidth: parent.offsetWidth,
                offsetHeight: parent.offsetHeight,
                clientWidth: parent.clientWidth,
                clientHeight: parent.clientHeight,
                computedStyle: {
                  width: getComputedStyle(parent).width,
                  height: getComputedStyle(parent).height,
                  display: getComputedStyle(parent).display,
                  position: getComputedStyle(parent).position
                }
              });
            } else {
              console.error('üé¨ Video element has no parent! Element not attached to DOM.');
            }
            
            // Debug grandparent container
            if (parent) {
              const grandParent = parent.parentElement;
              if (grandParent) {
                console.log('üé¨ Grandparent container state:', {
                  tagName: grandParent.tagName,
                  className: grandParent.className,
                  offsetWidth: grandParent.offsetWidth,
                  offsetHeight: grandParent.offsetHeight,
                  computedStyle: {
                    width: getComputedStyle(grandParent).width,
                    height: getComputedStyle(grandParent).height,
                    display: getComputedStyle(grandParent).display
                  }
                });
              }
            }
            
            // Try to play the video automatically for testing
            console.log('üé¨ Attempting backup auto-play...');
            // Ensure unmuted before backup autoplay attempt
            videoElement.muted = false;
            videoElement.volume = 1.0;
            videoElement.play().then(() => {
              console.log('üé¨ Backup auto-play successful!');
            }).catch(err => {
              console.error('üé¨ Backup auto-play failed:', err);
            });
          }, { once: true });
        } else {
          // Show image, hide video (use JPG proxy for HEIC files)
          const currentVideoElement = document.getElementById('bigvideo');
          if (currentVideoElement) {
            currentVideoElement.pause(); // Stop any playing video first
            currentVideoElement.style.display = "none";
            // Remove src attribute instead of setting to empty string to avoid invalid URI error
            currentVideoElement.removeAttribute('src');
            currentVideoElement.load(); // Reset the video element
            console.log('üé¨ Video hidden, paused, and source cleared for image display');
          }
          
          // Ensure image element is properly configured
          const currentImageElement = document.getElementById('bigimg');
          if (currentImageElement) {
            currentImageElement.src = displaySrc;
            currentImageElement.style.display = "block";
            currentImageElement.classList.remove("pixelzoom");
            currentImageElement.style.left = currentImageElement.style.top = "0px";
            currentImageElement.classList.toggle("picked", isPicked);
            currentImageElement.classList.toggle("rejected", isRejected);
            console.log('üñºÔ∏è Image displayed:', displaySrc.split('/').pop());
          } else {
            console.error('üñºÔ∏è ERROR: Image element not found!');
          }
          
          // Update status indicator dot
          const statusIndicator = document.getElementById('statusIndicator');
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
          
          // Load faces after image is fully loaded for proper positioning
          bigimg.addEventListener('load', () => {
            loadFacesForCurrentImage();
            
            // Check cache status for main image load
            setTimeout(() => {
              const cacheStatus = checkImageCacheStatus(displaySrc);
              console.log(`üñºÔ∏è Main image ${idx + 1} loaded from ${cacheStatus.toUpperCase()}: ${displaySrc}`);
              console.log(`üîç Main image preloaded? ${preloadedImages.has(idx)}`);
            }, 10);
          }, { once: true });
          
          // Also call immediately in case image is already cached
          if (bigimg.complete) {
            loadFacesForCurrentImage();
          }
        }
      }
      
      function createAdjacentImageElements(centerIdx) {
        /**Create DOM elements for current image and 2 adjacent images on each side*/
        if (!images || images.length === 0) return;
        
        console.log(`üéØ Creating adjacent images for center index ${centerIdx} (mode: ${mode})`);
        
        // Clear existing adjacent elements
        clearAdjacentElements();
        
        // For small galleries, avoid duplicate indices
        const indices = {};
        if (images.length >= 5) {
          indices.prev2 = (centerIdx - 2 + images.length) % images.length;
          indices.prev1 = (centerIdx - 1 + images.length) % images.length;
          indices.current = centerIdx;
          indices.next1 = (centerIdx + 1) % images.length;
          indices.next2 = (centerIdx + 2) % images.length;
        } else {
          // For smaller galleries, only create what we need
          indices.current = centerIdx;
          if (images.length > 1) {
            indices.prev1 = (centerIdx - 1 + images.length) % images.length;
            indices.next1 = (centerIdx + 1) % images.length;
          }
          if (images.length > 3) {
            indices.prev2 = (centerIdx - 2 + images.length) % images.length;
            indices.next2 = (centerIdx + 2) % images.length;
          }
        }
        
        // Create elements for each position
        Object.keys(indices).forEach(position => {
          const idx = indices[position];
          const meta = images[idx];
          if (!meta) return;
          
          const originalSrc = meta.SourceFile || meta.src || meta.FileName;
          const cleanOriginalSrc = originalSrc.replace(/^\.\//, "");
          const displaySrc = getDisplaySource(meta, false);
          const isPicked = picks.has(meta._imageId);
          const isRejected = rejects.has(meta._imageId);
          
          if (isVideoFile(cleanOriginalSrc)) {
            // Skip creating adjacent video elements - videos load on demand only
            console.log(`üìπ Skipping adjacent video element for ${position} (index ${idx}) - videos load on demand`);
          } else {
            // Create image element  
            const img = document.createElement("img");
            img.src = displaySrc;
            img.style.position = "absolute";
            img.style.top = "0";
            img.style.left = "0";
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "contain";
            img.style.zIndex = position === 'current' ? "100" : "50";
            // In thumbnail mode, hide all elements initially; in full screen mode, show current
            img.style.opacity = (position === 'current' && mode !== 'thumbs') ? "1" : "0";
            img.classList.toggle("picked", isPicked);
            img.classList.toggle("rejected", isRejected);
            img.dataset.imageIndex = idx;
            img.dataset.position = position;
            
            adjacentImages[position] = img;
            bigimgWrap.appendChild(img);
            
            console.log(`üñºÔ∏è Created image element for ${position} (index ${idx})`);
          }
        });
        
        // Hide the main bigimg since we're using adjacent elements for images
        // Keep bigvideo available for video playback when needed
        bigimg.style.display = "none";
      }
      
      function clearAdjacentElements() {
        /**Clear all adjacent image/video elements*/
        Object.values(adjacentImages).forEach(img => {
          if (img && img.parentNode) {
            img.parentNode.removeChild(img);
          }
        });
        Object.values(adjacentVideos).forEach(video => {
          if (video && video.parentNode) {
            video.parentNode.removeChild(video);
          }
        });
        
        // Reset references
        adjacentImages = {
          prev2: null, prev1: null, current: null, next1: null, next2: null
        };
        adjacentVideos = {
          prev2: null, prev1: null, current: null, next1: null, next2: null
        };
      }
      
      function switchToAdjacentImage(direction) {
        /**Switch to adjacent image instantly using pre-created DOM elements - IMAGES ONLY*/
        if (!images || images.length === 0) return false;
        
        const newIndex = (current + direction + images.length) % images.length;
        const targetMeta = images[newIndex];
        const targetSrc = targetMeta?.SourceFile || targetMeta?.src || targetMeta?.FileName || '';
        
        // If target is a video, return false to use normal loadImage
        if (isVideoFile(targetSrc)) {
          console.log(`üìπ Target is video, using normal load instead of adjacent switch`);
          return false;
        }
        
        const targetPosition = direction > 0 ? 'next1' : 'prev1';
        const targetImg = adjacentImages[targetPosition];
        
        if (!targetImg) {
          console.log(`‚ö†Ô∏è No adjacent image element found for ${targetPosition}`);
          return false;
        }
        
        // Hide all elements by setting opacity and lowering z-index
        Object.values(adjacentImages).forEach(img => {
          if (img) {
            img.style.opacity = "0";
            img.style.zIndex = "50";
          }
        });
        
        // Show target image element instantly by bringing it to front
        targetImg.style.opacity = "1";
        targetImg.style.zIndex = "100";
        
        // Hide video element when switching to image
        bigvideo.style.display = "none";
        
        console.log(`‚ö° Instantly switched to image ${targetImg.dataset.imageIndex}`);
        
        // Update status indicator dot for the new current image
        const newCurrentIndex = (current + direction + images.length) % images.length;
        if (images[newCurrentIndex]) {
          const imageId = images[newCurrentIndex]._imageId;
          const isPicked = picks.has(imageId);
          const isRejected = rejects.has(imageId);
          
          const statusIndicator = document.getElementById('statusIndicator');
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
        }
        
        return true;
      }
      
      function handleArrow(dir, isShiftHeld = false) {
        if (mode === "thumbs") {
          // Get the most recent selected thumbnail (highest index)
          const currentSelection = selectedThumbnails.size > 0 ? 
            Math.max(...Array.from(selectedThumbnails)) : 0;
          
          const newIndex = (currentSelection + dir + images.length) % images.length;
          
          if (isShiftHeld) {
            // Add to selection (range from current to new)
            const start = Math.min(currentSelection, newIndex);
            const end = Math.max(currentSelection, newIndex);
            for (let i = start; i <= end; i++) {
              selectedThumbnails.add(i);
            }
          } else {
            // Move selection to new index
            selectedThumbnails.clear();
            selectedThumbnails.add(newIndex);
          }
          
          current = newIndex;
          updateSelectionDisplay();
          updateStatusIndicator();
          scrollThumbIntoView(newIndex);
          loadSidebar(newIndex).catch(console.error);
          
          // Pre-create adjacent images for instant full screen launch
          createAdjacentImageElements(newIndex);
          
          // Restart preloading from new selection
          restartPreloadingFromSelection();
        } else {
          // Full screen mode navigation with instant switching
          const newCurrent = (current + dir + images.length) % images.length;
          
          // Try instant switch using pre-created adjacent elements
          const instantSwitch = switchToAdjacentImage(dir);
          
          if (instantSwitch) {
            // Successfully switched instantly, now update state and recreate adjacent elements
            current = newCurrent;
            selectedThumbnails.clear();
            selectedThumbnails.add(current);
            
            // Recreate adjacent elements for new position (with small delay to let instant switch show)
            setTimeout(() => {
              createAdjacentImageElements(current);
              loadFacesForCurrentImage();
            }, 50);
          } else {
            // Fallback to regular loading if instant switch failed
            current = newCurrent;
            selectedThumbnails.clear();
            selectedThumbnails.add(current);
            loadImage(current);
          }
          
          loadSidebar(current).catch(console.error);
          
          // Restart preloading from new selection
          restartPreloadingFromSelection();
        }
      }
      
      function handleVerticalArrow(dir, isShiftHeld = false) {
        // Only work in thumbnail mode
        if (mode !== "thumbs") {
          return;
        }
        
        // Calculate the number of columns in the grid
        const thumbGrid = document.querySelector('.thumb-grid');
        if (!thumbGrid) return;
        
        const thumbCells = thumbGrid.querySelectorAll('.thumb-cell');
        if (thumbCells.length === 0) return;
        
        // Get grid computed style to determine columns
        const gridStyle = window.getComputedStyle(thumbGrid);
        const gridColumns = gridStyle.gridTemplateColumns.split(' ').length;
        
        // Get current selection
        const currentSelection = selectedThumbnails.size > 0 ? 
          Math.max(...Array.from(selectedThumbnails)) : 0;
        
        // Calculate new index (up = -columns, down = +columns)
        const newIndex = currentSelection + (dir * gridColumns);
        
        // Make sure we stay within bounds
        if (newIndex < 0 || newIndex >= images.length) {
          return;
        }
        
        if (isShiftHeld) {
          // Add to selection (range from current to new)
          const start = Math.min(currentSelection, newIndex);
          const end = Math.max(currentSelection, newIndex);
          for (let i = start; i <= end; i++) {
            selectedThumbnails.add(i);
          }
        } else {
          // Move selection to new index
          selectedThumbnails.clear();
          selectedThumbnails.add(newIndex);
        }
        
        current = newIndex;
        updateSelectionDisplay();
        updateStatusIndicator();
        scrollThumbIntoView(newIndex);
        loadSidebar(newIndex).catch(console.error);
      }
      
      let selectedGalleryIndex = -1; // Track which gallery is highlighted during navigation
      let gallerySelectorFocused = false; // Track if gallery selector has keyboard focus
      
      function handleGalleryNavigation(dir) {
        const galleryItems = document.querySelectorAll('.gallery-item');
        if (galleryItems.length === 0) return;
        
        // Hide thumbnail highlights while navigating galleries
        hideThumbnailHighlights();
        
        // Initialize selection if not set
        if (selectedGalleryIndex === -1) {
          selectedGalleryIndex = 0;
        } else {
          // Move selection
          selectedGalleryIndex += dir;
          
          // Wrap around
          if (selectedGalleryIndex < 0) {
            selectedGalleryIndex = galleryItems.length - 1;
          } else if (selectedGalleryIndex >= galleryItems.length) {
            selectedGalleryIndex = 0;
          }
        }
        
        // Update visual highlighting
        galleryItems.forEach((item, index) => {
          // Clear all selection classes first
          item.classList.remove('keyboard-selected', 'gallery-focused');
          
          if (index === selectedGalleryIndex) {
            if (item.classList.contains('active')) {
              // If this is the active gallery, use special focused styling
              item.classList.add('gallery-focused');
            } else {
              // Regular purple highlighting for non-active galleries
              item.classList.add('keyboard-selected');
            }
          }
        });
        
        // Scroll the selected gallery into view
        galleryItems[selectedGalleryIndex].scrollIntoView({
          behavior: 'smooth',
          block: 'nearest'
        });
      }
      
      // Store thumbnail selection state for restoration
      let savedThumbnailSelection = new Set();
      
      function hideThumbnailHighlights() {
        // Save current selection state before hiding
        savedThumbnailSelection.clear();
        const thumbCells = document.querySelectorAll('.thumb-cell.selected');
        thumbCells.forEach((cell, index) => {
          const thumbIndex = parseInt(cell.dataset.index);
          if (!isNaN(thumbIndex)) {
            savedThumbnailSelection.add(thumbIndex);
          }
        });
        
        // Clear thumbnail selection visual highlights
        const allThumbCells = document.querySelectorAll('.thumb-cell');
        allThumbCells.forEach(cell => {
          cell.classList.remove('selected');
        });
      }
      
      function restoreThumbnailHighlights() {
        // Restore previously saved thumbnail selections
        if (savedThumbnailSelection.size > 0) {
          const thumbCells = document.querySelectorAll('.thumb-cell');
          thumbCells.forEach(cell => {
            const thumbIndex = parseInt(cell.dataset.index);
            if (savedThumbnailSelection.has(thumbIndex)) {
              cell.classList.add('selected');
            }
          });
        }
      }
      
      function selectGalleryByIndex(index) {
        const galleryItems = document.querySelectorAll('.gallery-item');
        if (index >= 0 && index < galleryItems.length) {
          const galleryItem = galleryItems[index];
          const galleryPath = galleryItem.dataset.galleryPath;
          const galleryName = galleryItem.textContent.trim();
          
          // Clear keyboard selection styling and focus
          clearGalleryFocus();
          
          // Load the gallery
          loadGallery(galleryPath, galleryName);
        }
      }
      
      function focusGallerySelector() {
        // Validate gallery selector exists and is visible
        const gallerySelector = document.getElementById('gallery-selector');
        if (!gallerySelector || !gallerySelectorOpen) {
          console.warn('Cannot focus gallery selector: not found or not visible');
          return;
        }
        
        gallerySelectorFocused = true;
        
        // Add visual focus indicator
        gallerySelector.classList.add('focused');
        
        // Find current active gallery and highlight it, or start with first gallery
        const galleryItems = document.querySelectorAll('.gallery-item');
        if (galleryItems.length === 0) {
          console.warn('No gallery items found');
          return;
        }
        
        const activeGallery = document.querySelector('.gallery-item.active');
        
        if (activeGallery) {
          // If there's an active gallery, highlight it with special styling
          selectedGalleryIndex = Array.from(galleryItems).indexOf(activeGallery);
          activeGallery.classList.add('gallery-focused');
        } else {
          // Start with first gallery if no active gallery
          selectedGalleryIndex = 0;
          if (galleryItems.length > 0) {
            galleryItems[0].classList.add('keyboard-selected');
          }
        }
        
        // Hide thumbnail highlights (saves state for restoration)
        hideThumbnailHighlights();
        
        // Gallery selector is now focused
      }
      
      function clearGalleryFocus() {
        gallerySelectorFocused = false;
        selectedGalleryIndex = -1;
        
        // Remove visual focus indicator
        const gallerySelector = document.getElementById('gallery-selector');
        if (gallerySelector) {
          gallerySelector.classList.remove('focused');
        }
        
        // Clear keyboard selection styling
        document.querySelectorAll('.gallery-item.keyboard-selected').forEach(item => {
          item.classList.remove('keyboard-selected');
        });
        
        // Clear focused active gallery styling
        document.querySelectorAll('.gallery-item.gallery-focused').forEach(item => {
          item.classList.remove('gallery-focused');
        });
        
        // Restore thumbnail highlights if we're not switching galleries
        if (!gallerySelectorOpen) {
          restoreThumbnailHighlights();
        }
        
        // Gallery selector focus cleared
      }
      
      function enterZoom() {
        // Don't allow zoom for videos
        if (!images[current] || isVideoFile(images[current].SourceFile || images[current].src || images[current].FileName)) {
          return;
        }
        
        // Get the current visible adjacent image
        const currentImg = adjacentImages.current;
        if (!currentImg) {
          console.log('No current image found for zoom mode');
          return;
        }
        
        mode = "zoom";
        
        // Apply zoom styling to the current adjacent image
        currentImg.classList.add("pixelzoom");
        currentImg.style.maxWidth = "none";
        currentImg.style.maxHeight = "none";
        currentImg.style.width = "auto";
        currentImg.style.height = "auto";
        currentImg.style.cursor = "grab";
        currentImg.style.background = "#222";
        currentImg.style.boxSizing = "border-box";
        currentImg.style.zIndex = "150"; // Higher than normal images
        
        // Add mouse panning using the working logic from cull tool
        enableSingleImagePanning(currentImg);
        
        // Refresh faces (will hide them in zoom mode)
        loadFacesForCurrentImage();
      }
      function exitZoom() {
        mode = "fit";
        
        // Get the current visible adjacent image and reset zoom styling
        const currentImg = adjacentImages.current;
        if (currentImg) {
          currentImg.classList.remove("pixelzoom");
          currentImg.style.maxWidth = "100%";
          currentImg.style.maxHeight = "100%";
          currentImg.style.width = "100%";
          currentImg.style.height = "100%";
          currentImg.style.cursor = "";
          currentImg.style.background = "";
          currentImg.style.boxSizing = "";
          currentImg.style.left = "0px";
          currentImg.style.top = "0px";
          currentImg.style.zIndex = "100"; // Back to normal z-index
        }
        
        // Remove mouse panning
        disableSingleImagePanning();
        
        // Refresh faces (will show them again in fit mode)
        loadFacesForCurrentImage();
      }
      
      let singleImagePanHandler = null;
      
      function enableSingleImagePanning(targetImg = null) {
        const container = document.getElementById('singleview');
        const img = targetImg || bigimg;
        
        singleImagePanHandler = (e) => {
          if (!img || !img.naturalWidth) return;
          
          const rect = container.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          const maxX = Math.max(0, img.naturalWidth - rect.width);
          const maxY = Math.max(0, img.naturalHeight - rect.height);
          const ox = -maxX * x;
          const oy = -maxY * y;
          
          img.style.left = ox + "px";
          img.style.top = oy + "px";
        };
        
        container.addEventListener('mousemove', singleImagePanHandler);
      }
      
      function disableSingleImagePanning() {
        const container = document.getElementById('singleview');
        if (singleImagePanHandler) {
          container.removeEventListener('mousemove', singleImagePanHandler);
          singleImagePanHandler = null;
        }
      }
      function toggleSidebar() {
        sidebarOpen = !sidebarOpen;
        sidebar.classList.toggle("visible", sidebarOpen);
      }
      
      function togglePick() {
        // Toggle pick status for all selected thumbnails
        if (!currentGallery) return;
        
        const galleryName = getGalleryNameFromPath(currentGallery);
        const selectedIndices = selectedThumbnails.size > 0 ? Array.from(selectedThumbnails) : [current];
        
        // Determine if we're adding or removing (based on first selected item)
        const firstIndex = selectedIndices[0];
        const firstImageId = images[firstIndex]._imageId;
        const shouldAdd = !picks.has(firstImageId);
        
        selectedIndices.forEach(index => {
          if (images[index]) {
            const imageId = images[index]._imageId;
            
            if (shouldAdd) {
              picks.add(imageId);
            } else {
              picks.delete(imageId);
            }
          }
        });
        
        updatePickClasses();
        
        // Auto-save picks
        autoSavePicks();
      }
      
      async function autoSavePicks() {
        if (picks.size === 0) {
          // If no picks, save empty array to clear the file
          await savePicksToAPI([]);
          return;
        }
        
        const picksList = Array.from(picks);
        await savePicksToAPI(picksList);
      }
      
      async function savePicksToAPI(picksList) {
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/save-picks`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({picks: picksList})
          });
          
          if (response.ok) {
            console.log(`‚úÖ Auto-saved ${picksList.length} picks`);
          } else {
            console.error('‚ùå Failed to auto-save picks');
          }
        } catch (error) {
          console.error('‚ùå Error auto-saving picks:', error);
        }
      }
      
      function selectThumbnail(index, isShiftClick = false, isToggleClick = false) {
        if (!images[index]) return;
        
        if (isShiftClick && selectedThumbnails.size > 0) {
          // Range selection
          const existingSelection = Array.from(selectedThumbnails);
          const lastSelected = Math.max(...existingSelection);
          const start = Math.min(lastSelected, index);
          const end = Math.max(lastSelected, index);
          
          // Add range to selection
          for (let i = start; i <= end; i++) {
            selectedThumbnails.add(i);
          }
        } else if (isToggleClick) {
          // Toggle selection - add if not selected, remove if selected
          if (selectedThumbnails.has(index)) {
            selectedThumbnails.delete(index);
            // If we removed the current item and there are other selections, set current to the last remaining
            if (selectedThumbnails.size > 0 && current === index) {
              current = Math.max(...Array.from(selectedThumbnails));
            }
          } else {
            selectedThumbnails.add(index);
            current = index;
          }
        } else {
          // Single selection - clear previous
          selectedThumbnails.clear();
          selectedThumbnails.add(index);
          current = index;
        }
        
        updateSelectionDisplay();
        updateStatusIndicator();
        
        // Only load sidebar and preload if we have a valid current selection
        if (selectedThumbnails.size > 0) {
          loadSidebar(current).catch(console.error);
          
          // Pre-create adjacent images for instant full screen launch
          createAdjacentImageElements(current);
          
          // Restart preloading from new selection
          restartPreloadingFromSelection();
        }
      }
      
      function getGalleryNameFromPath(galleryPath) {
        // Extract gallery name from path like "Hard Link Galleries/Gower Holiday/image_data.json"
        const parts = galleryPath.split('/');
        return parts[parts.length - 2]; // Get the folder name before image_data.json
      }
      
      function getFileName(path) {
        return path.split('/').pop();
      }
      
      function updatePickClasses() {
        if (!currentGallery) return;
        
        const galleryName = getGalleryNameFromPath(currentGallery);
        
        Array.from(document.querySelectorAll(".thumb-cell")).forEach((el, i) => {
          const imageId = images[i]._imageId;
          el.classList.toggle("picked", picks.has(imageId));
          el.classList.toggle("rejected", rejects.has(imageId));
        });
        
        // Update full screen mode if active
        if (mode === "fit" || mode === "zoom") {
          const currentImageId = images[current]._imageId;
          const isPicked = picks.has(currentImageId);
          const isRejected = rejects.has(currentImageId);
          
          // Update adjacent images/videos
          if (adjacentImages.current) {
            adjacentImages.current.classList.toggle("picked", isPicked);
            adjacentImages.current.classList.toggle("rejected", isRejected);
          }
          if (adjacentVideos.current) {
            adjacentVideos.current.classList.toggle("picked", isPicked);
            adjacentVideos.current.classList.toggle("rejected", isRejected);
          }
          
          // Update status indicator dot
          const statusIndicator = document.getElementById('statusIndicator');
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
        }
        
      }
      
      function toggleReject() {
        // Toggle reject status for all selected thumbnails
        if (!currentGallery) return;
        
        const galleryName = getGalleryNameFromPath(currentGallery);
        const selectedIndices = selectedThumbnails.size > 0 ? Array.from(selectedThumbnails) : [current];
        
        // Determine if we're adding or removing (based on first selected item)
        const firstIndex = selectedIndices[0];
        const firstImageId = images[firstIndex]._imageId;
        const shouldAdd = !rejects.has(firstImageId);
        
        selectedIndices.forEach(index => {
          if (images[index]) {
            const imageId = images[index]._imageId;
            
            if (shouldAdd) {
              rejects.add(imageId);
              // Remove from picks if it was picked
              picks.delete(imageId);
            } else {
              rejects.delete(imageId);
            }
          }
        });
        
        updatePickClasses();
        
        // Auto-save both picks and rejects (since reject can remove picks)
        autoSavePicks();
        autoSaveRejects();
      }
      
      async function autoSaveRejects() {
        if (rejects.size === 0) {
          // If no rejects, save empty array to clear the file
          await saveRejectsToAPI([]);
          return;
        }
        
        const rejectsList = Array.from(rejects);
        await saveRejectsToAPI(rejectsList);
      }
      
      async function saveRejectsToAPI(rejectsList) {
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/save-rejects`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({rejects: rejectsList})
          });
          
          if (response.ok) {
            console.log(`‚úÖ Auto-saved ${rejectsList.length} rejects`);
          } else {
            console.error('‚ùå Failed to auto-save rejects');
          }
        } catch (error) {
          console.error('‚ùå Error auto-saving rejects:', error);
        }
      }
      
      async function loadPicksFromAPI() {
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/load-picks`);
          if (response.ok) {
            const data = await response.json();
            if (data.picks && Array.isArray(data.picks)) {
              picks.clear();
              data.picks.forEach(imageId => picks.add(imageId));
              console.log(`‚úÖ Loaded ${picks.size} picks from server`);
              return true;
            }
          } else if (response.status === 404) {
            // No picks file exists yet - this is normal
            console.log('‚ÑπÔ∏è No existing picks file found (this is normal for new installations)');
            return true;
          } else {
            console.warn('‚ö†Ô∏è Failed to load picks from server');
          }
        } catch (error) {
          console.error('‚ùå Error loading picks:', error);
        }
        return false;
      }
      
      async function loadRejectsFromAPI() {
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/load-rejects`);
          if (response.ok) {
            const data = await response.json();
            if (data.rejects && Array.isArray(data.rejects)) {
              rejects.clear();
              data.rejects.forEach(imageId => rejects.add(imageId));
              console.log(`‚úÖ Loaded ${rejects.size} rejects from server`);
              return true;
            }
          } else if (response.status === 404) {
            // No rejects file exists yet - this is normal
            console.log('‚ÑπÔ∏è No existing rejects file found (this is normal for new installations)');
            return true;
          } else {
            console.warn('‚ö†Ô∏è Failed to load rejects from server');
          }
        } catch (error) {
          console.error('‚ùå Error loading rejects:', error);
        }
        return false;
      }
      
      async function initializePicksAndRejects() {
        console.log('üîÑ Loading picks and rejects from server...');
        await Promise.all([
          loadPicksFromAPI(),
          loadRejectsFromAPI()
        ]);
        // Update visual indicators after loading
        updatePickClasses();
        console.log(`üìä Initialization complete: ${picks.size} picks, ${rejects.size} rejects`);
      }
      
      function enterCullMode() {
        if (selectedThumbnails.size < 2) {
          alert("Select at least 2 images to enter cull mode");
          return;
        }
        
        // Clear all cull images first to prevent flash of previous content
        document.getElementById('cull-main-img').src = '';
        document.getElementById('cull-candidate-img').src = '';
        document.getElementById('cull-current-img').src = '';
        
        cullMode = true;
        cullImages = Array.from(selectedThumbnails).map(i => ({
          index: i,
          src: images[i].SourceFile || images[i].src || images[i].FileName,
          displaySrc: getDisplaySource(images[i]),
          _imageId: images[i]._imageId
        }));
        cullCurrent = 0;
        cullPick = -1; // -1 = no candidate, >=0 = candidate index
        
        // Auto-hide both panels for cull mode
        const sidebar = document.getElementById('sidebar');
        const gallerySelector = document.getElementById('gallery-selector');
        sidebar.classList.remove('visible');
        gallerySelector.classList.remove('visible');
        sidebarOpen = false;
        gallerySelectorOpen = false;
        
        // Show cull UI
        document.getElementById('cull-strip').classList.add('visible');
        
        // Hide main thumbnail grid and show single view
        thumbgrid.style.display = 'none';
        
        renderCullStrip();
        showCullSingleImage();
        updateTouchToolbar();
      }
      
      function exitCullMode(markForDeletion = false) {
        if (!cullMode) return;
        
        if (markForDeletion && cullPick >= 0) {
          // Mark all non-candidates as rejected
          const galleryName = getGalleryNameFromPath(currentGallery);
          
          cullImages.forEach((img, i) => {
            if (i !== cullPick) {
              const imageId = img._imageId;
              rejects.add(imageId);
              picks.delete(imageId); // Remove from picks if it was picked
            }
          });
          
          console.log(`Marked ${cullImages.length - 1} images for deletion, kept candidate`);
          
          // Update pick/reject classes on thumbnails
          updatePickClasses();
          
          // Auto-save both picks and rejects after cull operation
          autoSavePicks();
          autoSaveRejects();
        }
        
        // Exit zoom mode if active
        if (cullZoomMode) {
          exitCullZoom();
        }
        
        // Reset cull mode
        cullMode = false;
        cullImages = [];
        cullCurrent = 0;
        cullPick = -1;
        
        // Hide cull UI
        document.getElementById('cull-strip').classList.remove('visible');
        document.getElementById('cull-comparison').classList.remove('visible');
        document.getElementById('cull-single').style.display = 'none';
        
        // Show main thumbnail grid
        thumbgrid.style.display = 'grid';
        
        // Update display
        updatePickClasses();
        updateSelectionDisplay();
        updateTouchToolbar();
      }
      
      function renderCullStrip() {
        const strip = document.getElementById('cull-strip');
        strip.innerHTML = '';
        
        cullImages.forEach((img, i) => {
          const thumb = document.createElement('img');
          // Use thumbnail if available, otherwise use display source (proxy for HEIC)
          const imageData = images[img.index];
          if (imageData._thumbnail) {
            thumb.src = imageData._thumbnail;
          } else {
            thumb.src = img.displaySrc;
          }
          thumb.className = 'cull-thumb';
          if (i === cullCurrent) thumb.classList.add('active');
          if (i === cullPick) thumb.classList.add('pick');
          
          thumb.addEventListener('click', () => {
            cullCurrent = i;
            renderCullStrip();
            renderCullComparison();
          });
          
          strip.appendChild(thumb);
        });
      }
      
      function showCullSingleImage() {
        // Show single image full screen with strip at bottom
        const mainImg = document.getElementById('cull-main-img');
        mainImg.src = cullImages[cullCurrent].displaySrc;
        
        // Ensure image is in fitted mode (not zoomed)
        resetCullImageToFitted(mainImg);
        
        // Show single view, hide comparison view
        document.getElementById('cull-single').style.display = 'flex';
        document.getElementById('cull-comparison').classList.remove('visible');
      }
      
      function resetCullImageToFitted(img) {
        // Reset image to fitted mode
        img.style.width = '';
        img.style.height = '';
        img.style.left = '';
        img.style.top = '';
        img.style.position = '';
      }
      
      function renderCullComparison() {
        if (cullPick < 0) {
          showCullSingleImage();
          return;
        }
        
        // Show two-up comparison: candidate on left, current on right
        document.getElementById('cull-single').style.display = 'none';
        document.getElementById('cull-comparison').classList.add('visible');
        
        const leftImg = document.getElementById('cull-candidate-img');
        const rightImg = document.getElementById('cull-current-img');
        
        leftImg.src = cullImages[cullPick].displaySrc;
        rightImg.src = cullImages[cullCurrent].displaySrc;
        
        // Ensure images are in fitted mode (not zoomed) unless we're in zoom mode
        if (!cullZoomMode) {
          resetCullImageToFitted(leftImg);
          resetCullImageToFitted(rightImg);
        }
      }
      
      function handleCullPick() {
        if (!cullMode) return;
        
        if (cullPick < 0) {
          // No candidate yet - set current as candidate and enter two-up mode
          cullPick = cullCurrent;
          // Move to next image for comparison
          cullCurrent = (cullCurrent + 1) % cullImages.length;
          if (cullCurrent === cullPick) {
            cullCurrent = (cullCurrent + 1) % cullImages.length; // Skip if wrapped to same
          }
        } else {
          // In two-up mode - promote right image to candidate
          cullPick = cullCurrent;
        }
        
        renderCullStrip();
        renderCullComparison();
      }
      
      function handleCullNavigation(direction) {
        if (!cullMode) return;
        
        if (cullPick < 0) {
          // Single image mode - navigate through all images
          cullCurrent = (cullCurrent + direction + cullImages.length) % cullImages.length;
        } else {
          // Two-up mode - navigate through non-candidate images on the right
          do {
            cullCurrent = (cullCurrent + direction + cullImages.length) % cullImages.length;
          } while (cullCurrent === cullPick && cullImages.length > 1);
        }
        
        renderCullStrip();
        renderCullComparison();
      }
      
      let cullZoomMode = false;
      let cullLastPan = { x: 0, y: 0 }; // Store pan offsets like working version
      
      function enterCullZoom() {
        if (!cullMode) return;
        
        cullZoomMode = true;
        
        if (cullPick < 0) {
          // Single image mode
          const singleContainer = document.getElementById('cull-single');
          singleContainer.classList.add('full');
          
          const container = document.querySelector('#cull-single .cull-img-container');
          const img = document.getElementById('cull-main-img');
          
          applyCullZoom(img);
          enableCullPan([container]);
        } else {
          // Two-up mode
          const comparison = document.getElementById('cull-comparison');
          comparison.classList.add('full');
          
          const candidateImg = document.getElementById('cull-candidate-img');
          const currentImg = document.getElementById('cull-current-img');
          const containers = document.querySelectorAll('#cull-comparison .cull-img-container');
          
          applyCullZoom(candidateImg);
          applyCullZoom(currentImg);
          enableCullPan(containers);
        }
        
        // Zoom mode is now active
      }
      
      function applyCullZoom(img) {
        if (img.complete && img.naturalWidth > 0) {
          img.style.width = img.naturalWidth + 'px';
          img.style.height = img.naturalHeight + 'px';
          img.style.left = cullLastPan.x + 'px';
          img.style.top = cullLastPan.y + 'px';
        } else {
          img.onload = () => {
            img.style.width = img.naturalWidth + 'px';
            img.style.height = img.naturalHeight + 'px';
            img.style.left = cullLastPan.x + 'px';
            img.style.top = cullLastPan.y + 'px';
          };
        }
      }
      
      function enableCullPan(containers) {
        containers.forEach((c) => {
          c.onmousemove = (e) => {
            const img = c.querySelector('img'); // Use querySelector instead of firstChild
            if (!img || !img.naturalWidth) return; // Safety check
            
            const rect = c.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            const maxX = Math.max(0, img.naturalWidth - rect.width);
            const maxY = Math.max(0, img.naturalHeight - rect.height);
            const ox = -maxX * x;
            const oy = -maxY * y;
            cullLastPan = { x: ox, y: oy }; // Store for next navigation
            
            // Apply to all images in all containers
            containers.forEach((container) => {
              const image = container.querySelector('img');
              if (image && image.style) {
                image.style.left = ox + "px";
                image.style.top = oy + "px";
              }
            });
          };
        });
      }
      
      function exitCullZoom() {
        if (!cullZoomMode) return;
        
        cullZoomMode = false;
        
        // Remove full class and reset containers
        const comparison = document.getElementById('cull-comparison');
        const singleContainer = document.getElementById('cull-single');
        comparison.classList.remove('full');
        singleContainer.classList.remove('full');
        
        // Reset all images to fitted mode
        const allImages = [
          document.getElementById('cull-main-img'),
          document.getElementById('cull-candidate-img'),
          document.getElementById('cull-current-img')
        ];
        
        allImages.forEach(img => {
          if (img) {
            img.style.width = '';
            img.style.height = '';
            img.style.left = '';
            img.style.top = '';
          }
        });
        
        // Remove mouse listeners
        const containers = document.querySelectorAll('.cull-img-container');
        containers.forEach(c => {
          c.onmousemove = null;
        });
        
      }
      
      
      function updateSelectionDisplay() {
        Array.from(document.querySelectorAll(".thumb-cell")).forEach((el, i) => {
          el.classList.toggle("highlight-selected", selectedThumbnails.has(i));
        });
      }
      
      function updateStatusIndicator() {
        const statusIndicator = document.getElementById('statusIndicator');
        if (statusIndicator && images[current]) {
          const imageId = images[current]._imageId;
          const isPicked = picks.has(imageId);
          const isRejected = rejects.has(imageId);
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
        }
      }
      
      function togglePicksList() {
        const existing = document.getElementById('picks-display');
        if (existing) {
          existing.remove();
          return;
        }
        
        if (picks.size === 0) {
          alert("No picks selected");
          return;
        }
        
        const picksList = Array.from(picks);
        const picksDisplay = document.createElement('div');
        picksDisplay.style.cssText = `
          position: fixed;
          top: 20px;
          left: 20px;
          right: 20px;
          background: #222;
          color: #0f0;
          z-index: 2000;
          max-width: 700px;
          margin: 0 auto;
          padding: 24px 16px;
          font-size: 15px;
          box-shadow: 0 2px 16px #0008;
          white-space: pre-wrap;
          font-family: monospace;
          border-radius: 8px;
        `;
        
        // Show raw JSON as before
        const jsonText = JSON.stringify(picksList, null, 2);
        picksDisplay.textContent = jsonText;
        picksDisplay.id = 'picks-display';
        
        // Add save button
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save to picks.json';
        saveButton.style.cssText = `
          position: absolute;
          top: 10px;
          right: 10px;
          background: #0066cc;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 14px;
          z-index: 3000;
        `;
        
        saveButton.addEventListener('click', async () => {
          try {
            const response = await fetch(`http://${window.location.hostname}:8001/api/save-picks`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({picks: picksList})
            });
            
            if (response.ok) {
              saveButton.textContent = '‚úÖ Saved!';
              saveButton.style.background = '#00aa00';
              setTimeout(() => {
                saveButton.textContent = 'Save to picks.json';
                saveButton.style.background = '#0066cc';
              }, 2000);
            } else {
              saveButton.textContent = '‚ùå Failed';
              saveButton.style.background = '#cc0000';
            }
          } catch (error) {
            console.error('Save error:', error);
            saveButton.textContent = '‚ùå Error';
            saveButton.style.background = '#cc0000';
          }
        });
        
        picksDisplay.appendChild(saveButton);
        document.body.appendChild(picksDisplay);
        
        // Auto-select the text
        setTimeout(() => {
          const range = document.createRange();
          range.selectNodeContents(picksDisplay);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }, 10);
        
        // Click to close
        picksDisplay.addEventListener('click', () => {
          picksDisplay.remove();
        });
        
        // Close on escape or clear picks with C
        const closeHandler = (e) => {
          const current = document.getElementById('picks-display');
          if (!current) return;
          
          if (e.key === 'q' || e.key === 'Q') {
            current.remove();
            document.removeEventListener('keydown', closeHandler);
          } else if (e.key === 'c' || e.key === 'C') {
            if (confirm(`Clear all ${picks.size} picks?`)) {
              picks.clear();
              updatePickClasses();
              current.remove();
              document.removeEventListener('keydown', closeHandler);
            }
          }
        };
        document.addEventListener('keydown', closeHandler);
      }
      
      function toggleGallerySelector() {
        gallerySelectorOpen = !gallerySelectorOpen;
        document.getElementById('gallery-selector').classList.toggle('visible', gallerySelectorOpen);
      }
      
      // Cache for people list
      let peopleCache = null;
      
      async function loadPeopleList() {
        /**Load list of all people for dropdown*/
        if (peopleCache) return peopleCache;
        
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/people`);
          if (response.ok) {
            peopleCache = await response.json();
            return peopleCache;
          }
        } catch (error) {
          console.error('Failed to load people list:', error);
        }
        return [];
      }
      
      async function assignFaceToPerson(faceId, personId) {
        /**Assign a face to a person via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/assign-face`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              face_id: faceId,
              person_id: personId
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('Face assigned successfully:', result);
            return true;
          } else {
            console.error('Failed to assign face:', response.statusText);
            return false;
          }
        } catch (error) {
          console.error('Error assigning face:', error);
          return false;
        }
      }
      
      async function ignoreFace(faceId) {
        /**Mark a face as ignored via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/ignore-face`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              face_id: faceId
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('Face ignored successfully:', result);
            return true;
          } else {
            console.error('Failed to ignore face:', response.statusText);
            return false;
          }
        } catch (error) {
          console.error('Error ignoring face:', error);
          return false;
        }
      }
      
      async function createUnidentifiedFaceControls(label, face) {
        /**Create dropdown and ignore button for unidentified faces*/
        const people = await loadPeopleList();
        
        // Create container for controls
        label.innerHTML = '';
        label.style.background = 'rgba(255, 80, 80, 0.9)';
        label.style.padding = '4px';
        label.style.minWidth = '120px';
        label.style.textAlign = 'left';
        
        // Face ID display
        const faceInfo = document.createElement('div');
        faceInfo.textContent = `ID:${face.id} (${(face.confidence * 100).toFixed(0)}%)`;
        faceInfo.style.fontSize = '10px';
        faceInfo.style.marginBottom = '2px';
        label.appendChild(faceInfo);
        
        // Dropdown for people
        const dropdown = document.createElement('select');
        dropdown.style.fontSize = '10px';
        dropdown.style.width = '100%';
        dropdown.style.marginBottom = '2px';
        
        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Choose action...';
        dropdown.appendChild(defaultOption);
        
        // Add ignore option
        const ignoreOption = document.createElement('option');
        ignoreOption.value = 'IGNORE';
        ignoreOption.textContent = 'üö´ Ignore this face';
        dropdown.appendChild(ignoreOption);
        
        // Add separator
        const separatorOption = document.createElement('option');
        separatorOption.disabled = true;
        separatorOption.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
        dropdown.appendChild(separatorOption);
        
        // Add people options
        people.forEach(person => {
          const option = document.createElement('option');
          option.value = person.id;
          option.textContent = `${person.name} (${person.face_count})`;
          dropdown.appendChild(option);
        });
        
        // Disable keyboard shortcuts when dropdown is focused
        dropdown.addEventListener('focus', () => {
          inputFieldFocused = true;
        });
        dropdown.addEventListener('blur', () => {
          inputFieldFocused = false;
        });
        
        // Handle assignment or ignore
        dropdown.addEventListener('change', async (e) => {
          if (e.target.value) {
            dropdown.disabled = true;
            dropdown.style.opacity = '0.5';
            
            if (e.target.value === 'IGNORE') {
              // Handle ignore
              faceInfo.textContent = 'Ignoring...';
              
              const success = await ignoreFace(face.id);
              if (success) {
                // Hide the face overlay completely
                label.parentElement.style.display = 'none';
              } else {
                // Reset on failure
                dropdown.disabled = false;
                dropdown.style.opacity = '1';
                dropdown.value = '';
                faceInfo.textContent = `ID:${face.id} (${(face.confidence * 100).toFixed(0)}%)`;
                alert('Failed to ignore face. Please try again.');
              }
            } else {
              // Handle person assignment
              const personId = parseInt(e.target.value);
              const personName = people.find(p => p.id === personId)?.name;
              
              faceInfo.textContent = 'Assigning...';
              
              const success = await assignFaceToPerson(face.id, personId);
              if (success) {
                // Update label to show assignment
                label.innerHTML = `${personName} (${(face.confidence * 100).toFixed(0)}%)`;
                label.style.background = 'rgba(0, 150, 255, 0.8)'; // Blue for assigned
              } else {
                // Reset on failure
                dropdown.disabled = false;
                dropdown.style.opacity = '1';
                dropdown.value = '';
                faceInfo.textContent = `ID:${face.id} (${(face.confidence * 100).toFixed(0)}%)`;
                alert('Failed to assign face. Please try again.');
              }
            }
          }
        });
        
        label.appendChild(dropdown);
      }
      
      async function createPersonRenameControls(label, face) {
        /**Create rename input field for Person # format names*/
        // Clear label and set up container
        label.innerHTML = '';
        label.style.background = 'rgba(255, 200, 0, 0.9)'; // Yellow for renameable
        label.style.padding = '4px';
        label.style.minWidth = '120px';
        label.style.textAlign = 'left';
        
        // Face info display
        const faceInfo = document.createElement('div');
        faceInfo.textContent = `${face.person_name} (${(face.confidence * 100).toFixed(0)}%)`;
        faceInfo.style.fontSize = '10px';
        faceInfo.style.marginBottom = '2px';
        label.appendChild(faceInfo);
        
        // Create input field
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter real name...';
        input.style.fontSize = '10px';
        input.style.width = '100%';
        input.style.padding = '2px';
        input.style.border = '1px solid #ccc';
        input.style.borderRadius = '3px';
        input.style.marginBottom = '2px';
        
        // Create buttons container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '2px';
        
        // Save button
        const saveButton = document.createElement('button');
        saveButton.textContent = '‚úì';
        saveButton.style.fontSize = '10px';
        saveButton.style.padding = '2px 6px';
        saveButton.style.background = '#00aa00';
        saveButton.style.color = 'white';
        saveButton.style.border = 'none';
        saveButton.style.borderRadius = '3px';
        saveButton.style.cursor = 'pointer';
        saveButton.style.flex = '1';
        
        // Cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = '‚úó';
        cancelButton.style.fontSize = '10px';
        cancelButton.style.padding = '2px 6px';
        cancelButton.style.background = '#cc0000';
        cancelButton.style.color = 'white';
        cancelButton.style.border = 'none';
        cancelButton.style.borderRadius = '3px';
        cancelButton.style.cursor = 'pointer';
        cancelButton.style.flex = '1';
        
        // Handle save
        const handleSave = async () => {
          const newName = input.value.trim();
          if (!newName) {
            alert('Please enter a name');
            return;
          }
          
          // Disable controls
          input.disabled = true;
          saveButton.disabled = true;
          cancelButton.disabled = true;
          faceInfo.textContent = 'Renaming...';
          
          const success = await renamePersonLabel(face.person_id, newName);
          if (success) {
            // Update label to show new name
            label.innerHTML = `${newName} (${(face.confidence * 100).toFixed(0)}%)`;
            label.style.background = 'rgba(0, 150, 255, 0.8)'; // Blue for confirmed
            
            // Clear people cache to force reload
            peopleCache = null;
          } else {
            // Reset on failure
            input.disabled = false;
            saveButton.disabled = false;
            cancelButton.disabled = false;
            faceInfo.textContent = `${face.person_name} (${(face.confidence * 100).toFixed(0)}%)`;
            alert('Failed to rename person. Please try again.');
          }
        };
        
        // Handle cancel
        const handleCancel = () => {
          // Restore original label
          label.innerHTML = `${face.person_name} (${(face.confidence * 100).toFixed(0)}%)`;
          label.style.background = face.confirmed ? 'rgba(0, 150, 255, 0.8)' : 'rgba(255, 150, 0, 0.8)';
        };
        
        // Event listeners
        saveButton.addEventListener('click', handleSave);
        cancelButton.addEventListener('click', handleCancel);
        
        // Disable keyboard shortcuts when input is focused
        input.addEventListener('focus', () => {
          inputFieldFocused = true;
        });
        input.addEventListener('blur', () => {
          inputFieldFocused = false;
        });
        
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            handleSave();
          } else if (e.key === 'Escape') {
            handleCancel();
          }
        });
        
        // Assemble the controls
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        label.appendChild(input);
        label.appendChild(buttonContainer);
        
        // Focus the input
        setTimeout(() => input.focus(), 100);
      }
      
      async function renamePersonLabel(personId, newName) {
        /**Rename a person via the API*/
        try {
          console.log(`Attempting to rename person ${personId} to "${newName}"`);
          
          const response = await fetch(`http://${window.location.hostname}:8001/api/rename-person`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              person_id: personId,
              new_name: newName
            })
          });
          
          console.log('Response status:', response.status, response.statusText);
          
          if (response.ok) {
            const result = await response.json();
            console.log('Person renamed successfully:', result);
            return true;
          } else {
            // Try to get error details from response
            let errorMessage = response.statusText;
            try {
              const errorText = await response.text();
              console.error('Rename error response:', errorText);
              errorMessage = errorText || errorMessage;
            } catch (e) {
              console.error('Could not read error response:', e);
            }
            
            console.error('Failed to rename person:', errorMessage);
            alert(`Failed to rename person: ${errorMessage}`);
            return false;
          }
        } catch (error) {
          console.error('Network error renaming person:', error);
          alert(`Network error: ${error.message}`);
          return false;
        }
      }
      
      async function loadFaces(imageId) {
        /**Load face data for an image from the database API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/faces/${imageId}`);
          if (response.ok) {
            return await response.json();
          }
        } catch (error) {
          console.log('Face data not available:', error);
        }
        return [];
      }
      
      async function getImageMetadata(imageId) {
        /**Get image metadata including proxy information from API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/image-metadata/${imageId}`);
          if (response.ok) {
            return await response.json();
          }
        } catch (error) {
          console.log('Image metadata not available:', error);
        }
        return null;
      }
      
      async function switchProxyMode(imageId, useCustomProxy) {
        /**Switch between original JPG and custom proxy via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/switch-proxy`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              image_id: imageId,
              use_custom_proxy: useCustomProxy
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            return { success: true, message: result.message };
          } else {
            const error = await response.text();
            console.error('Switch proxy API error:', response.status, error);
            return { success: false, message: `API Error ${response.status}: ${error}` };
          }
        } catch (error) {
          console.error('Error switching proxy mode:', error);
          return { success: false, message: `Network error: ${error.message}` };
        }
      }
      
      async function getAvailablePresets() {
        /**Get lists of available camera standards and style presets from API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/presets`);
          if (response.ok) {
            const presets = await response.json();
            // New API returns {camera_standards: [...], style_presets: [...]}
            if (presets.camera_standards && presets.style_presets) {
              return presets;
            }
            // Fallback for old API format
            return {
              camera_standards: presets.filter(p => p.file.startsWith('Standard_')),
              style_presets: presets.filter(p => !p.file.startsWith('Standard_'))
            };
          }
        } catch (error) {
          console.log('Presets not available:', error);
        }
        return {camera_standards: [], style_presets: []};
      }
      
      async function generateRawProxy(imageId, cameraStandard, stylePreset, exposure = 0.0, quality = 95) {
        /**Generate RAW proxy with three-stage preset processing via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/generate-raw-proxy`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              image_id: imageId,
              camera_standard: cameraStandard,
              style_preset: stylePreset,
              exposure: exposure,
              quality: quality
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            return { success: true, message: result.message };
          } else {
            const error = await response.text();
            return { success: false, message: error };
          }
        } catch (error) {
          console.error('Error generating RAW proxy:', error);
          return { success: false, message: 'Network error' };
        }
      }

      async function getProxyControls(imageId) {
        /**Generate enhanced proxy controls for the sidebar*/
        const metadata = await getImageMetadata(imageId);
        if (!metadata) return "";
        
        const isRAWFile = metadata.filename && /\.(cr2|cr3|nef|arw|dng|raf|orf|rw2|raw)$/i.test(metadata.filename);
        const isVideoFile = metadata.filename && /\.(mp4|mov|avi|mkv|webm|m4v)$/i.test(metadata.filename);
        
        if (!isRAWFile && !isVideoFile) return "";
        
        // Handle video files separately
        if (isVideoFile) {
          return await getVideoProxyControls(imageId, metadata);
        }
        
        // Get available presets
        const presets = await getAvailablePresets();
        
        // Determine current state and available actions
        const isUsingCustomProxy = metadata.raw_proxy_type === 'custom_generated';
        const hasCustomProxy = metadata.has_custom_proxy;
        const hasAdjacentJPG = metadata.has_adjacent_jpg;
        
        let buttons = "";
        
        if (isUsingCustomProxy) {
          // Currently using custom proxy
          if (hasAdjacentJPG) {
            buttons += `
              <button onclick="handleProxySwitch(${imageId}, false, event)" style="
                width: 100%;
                padding: 6px;
                background: #667722;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                font-weight: 500;
                margin-bottom: 4px;
              ">üì∑ Use Original JPG</button>`;
          }
          
          // Add regenerate with new preset option
          if (presets.camera_standards.length > 0 || presets.style_presets.length > 0) {
            buttons += `
              <div style="margin-bottom: 6px;">
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Camera Standard:</div>
                <select id="camera-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 6px;
                ">
                  <option value="">Auto-detect from EXIF</option>
                  ${presets.camera_standards.map(preset => `<option value="${preset.path}">${preset.name}</option>`).join('')}
                </select>
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Style Preset:</div>
                <select id="style-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 4px;
                ">
                  <option value="">Default Style</option>
                  ${presets.style_presets.sort((a, b) => a.name.localeCompare(b.name)).map(preset => `<option value="${preset.path}">${preset.name}</option>`).join('')}
                </select>
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Exposure:</div>
                <div style="display: flex; align-items: center; margin-bottom: 12px;">
                  <input type="range" id="exposure-select-${imageId}" min="-1" max="1" step="0.25" value="0" 
                    oninput="updateExposureDisplay(${imageId}, this.value)" style="
                    flex: 1;
                    height: 4px;
                    background: #555;
                    border-radius: 2px;
                    outline: none;
                    margin-right: 6px;
                  ">
                  <span id="exposure-value-${imageId}" style="
                    font-size: 9px;
                    color: #ccc;
                    min-width: 35px;
                    text-align: center;
                  ">0 EV</span>
                </div>
                <button onclick="handleRawRegenerate(${imageId})" style="
                  width: 100%;
                  padding: 6px;
                  background: #cc6600;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 10px;
                  font-weight: 500;
                ">üé® Regenerate with New Style</button>
              </div>`;
          }
        } else {
          // Currently using original JPG
          if (hasCustomProxy) {
            buttons += `
              <button onclick="handleProxySwitch(${imageId}, true, event)" style="
                width: 100%;
                padding: 6px;
                background: #cc6600;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                font-weight: 500;
                margin-bottom: 4px;
              ">üéûÔ∏è Use Existing RAW Proxy</button>`;
          }
          
          // Add generate new proxy option for ALL RAW files
          if (presets.camera_standards.length > 0 || presets.style_presets.length > 0) {
            buttons += `
              <div style="margin-bottom: 6px;">
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Camera Standard:</div>
                <select id="camera-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 6px;
                ">
                  <option value="">Auto-detect from EXIF</option>
                  ${presets.camera_standards.map(preset => `<option value="${preset.path}">${preset.name}</option>`).join('')}
                </select>
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Style Preset:</div>
                <select id="style-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 4px;
                ">
                  <option value="">Default Style</option>
                  ${presets.style_presets.map(preset => `<option value="${preset.path}">${preset.name}</option>`).join('')}
                </select>
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Exposure:</div>
                <div style="display: flex; align-items: center; margin-bottom: 12px;">
                  <input type="range" id="exposure-select-${imageId}" min="-1" max="1" step="0.25" value="0" 
                    oninput="updateExposureDisplay(${imageId}, this.value)" style="
                    flex: 1;
                    height: 4px;
                    background: #555;
                    border-radius: 2px;
                    outline: none;
                    margin-right: 6px;
                  ">
                  <span id="exposure-value-${imageId}" style="
                    font-size: 9px;
                    color: #ccc;
                    min-width: 35px;
                    text-align: center;
                  ">0 EV</span>
                </div>
                <button onclick="handleRawGenerate(${imageId})" style="
                  width: 100%;
                  padding: 6px;
                  background: #0066cc;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 10px;
                  font-weight: 500;
                ">${hasCustomProxy ? 'üé® Generate New' : 'üéûÔ∏è Process RAW'} Proxy</button>
              </div>`;
          }
        }
        
        if (buttons) {
          const currentStatus = isUsingCustomProxy ? 'Custom Proxy' : (hasAdjacentJPG ? 'Original JPG' : 'RAW File');
          return `
            <div style="margin-top: 10px; padding: 6px 8px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
              <div style="font-size: 9px; font-weight: 600; margin-bottom: 4px; color: #999; text-transform: uppercase; letter-spacing: 0.5px;">RAW Processing</div>
              <div style="font-size: 10px; color: #999; margin-bottom: 6px;">
                Currently: ${currentStatus}
              </div>
              ${buttons}
            </div>`;
        }
        
        return "";
      }
      
      async function getVideoProxyControls(imageId, metadata) {
        /**Generate video proxy controls for the sidebar*/
        try {
          // Get available LUTs
          const luts = await getAvailableLUTs();
          
          // Check if video proxy exists and get current proxy type
          const proxyExists = await checkVideoProxyExists(imageId);
          const currentProxyType = await getCurrentVideoProxyType(imageId);
          const isUsingProxy = currentProxyType === 'custom_generated';
          const currentStatus = isUsingProxy ? 'Video Proxy' : 'Original Video';
          
          console.log('Debug - Video Controls:', {
            imageId,
            proxyExists,
            currentProxyType,
            isUsingProxy,
            currentStatus
          });
          
          let controls = `
            <div style="margin-top: 10px; padding: 6px 8px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
              <div style="font-size: 9px; font-weight: 600; margin-bottom: 4px; color: #999; text-transform: uppercase; letter-spacing: 0.5px;">Video Processing</div>
              <div style="font-size: 10px; color: #999; margin-bottom: 6px;">
                Currently: ${currentStatus}
              </div>`;
          
          // Add proxy switching buttons if proxy exists
          if (proxyExists) {
            controls += `
              <div style="margin-bottom: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button onclick="handleVideoProxySwitch(${imageId}, false)" style="
                  padding: 4px 6px;
                  background: ${!isUsingProxy ? '#0066cc' : '#444'};
                  color: white;
                  border: none;
                  border-radius: 3px;
                  cursor: pointer;
                  font-size: 9px;
                  font-weight: 500;
                ">üìπ Original</button>
                <button onclick="handleVideoProxySwitch(${imageId}, true)" style="
                  padding: 4px 6px;
                  background: ${isUsingProxy ? '#0066cc' : '#444'};
                  color: white;
                  border: none;
                  border-radius: 3px;
                  cursor: pointer;
                  font-size: 9px;
                  font-weight: 500;
                ">üé¨ Proxy</button>
              </div>`;
          }
          
          controls += `
              <div style="margin-bottom: 6px;">
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Correction LUT (.cube):</div>
                <select id="correction-lut-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 6px;
                ">
                  <option value="">No Correction LUT</option>
                  ${luts.correctionLuts.map(lut => `<option value="${lut.path}">${lut.name}</option>`).join('')}
                </select>
                
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Style LUT (HALDCLUT .png):</div>
                <select id="style-lut-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 12px;
                ">
                  <option value="">No Style LUT</option>
                  ${luts.styleLuts.map(lut => `<option value="${lut.path}">${lut.name}</option>`).join('')}
                </select>
                
                <button onclick="handleVideoProxyGenerate(${imageId})" style="
                  width: 100%;
                  padding: 6px;
                  background: #0066cc;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 10px;
                  font-weight: 500;
                ">üé¨ ${proxyExists ? 'Regenerate' : 'Generate'} Video Proxy</button>
              </div>
            </div>`;
          
          return controls;
        } catch (error) {
          console.log('Error generating video proxy controls:', error);
          return "";
        }
      }
      
      async function getAvailableLUTs() {
        /**Get available LUT files from LUTS folder*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/luts`);
          if (response.ok) {
            return await response.json();
          }
        } catch (error) {
          console.log('LUTs not available:', error);
        }
        return {correctionLuts: [], styleLuts: []};
      }
      
      async function checkVideoProxyExists(imageId) {
        /**Check if video proxy exists for this image ID*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/video-proxy-status/${imageId}`);
          if (response.ok) {
            const result = await response.json();
            return result.exists;
          }
        } catch (error) {
          console.log('Could not check video proxy status:', error);
        }
        return false;
      }
      
      async function getCurrentVideoProxyType(imageId) {
        /**Get current video proxy type from database*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/image-metadata/${imageId}`);
          if (response.ok) {
            const metadata = await response.json();
            console.log('Debug - Full metadata:', metadata);
            console.log('Debug - video_proxy_type:', metadata.video_proxy_type);
            return metadata.video_proxy_type || 'original';
          }
        } catch (error) {
          console.log('Could not get video proxy type:', error);
        }
        return 'original';
      }
      
      async function handleVideoProxyGenerate(imageId) {
        /**Handle video proxy generation with LUTs*/
        const button = event.target;
        const originalText = button.textContent;
        
        // Get selected LUTs
        const correctionLutSelect = document.getElementById(`correction-lut-select-${imageId}`);
        const styleLutSelect = document.getElementById(`style-lut-select-${imageId}`);
        
        const correctionLut = correctionLutSelect ? correctionLutSelect.value : '';
        const styleLut = styleLutSelect ? styleLutSelect.value : '';
        
        // Disable button and show loading state
        button.disabled = true;
        button.style.opacity = '0.5';
        button.textContent = '‚è≥ Processing...';
        
        try {
          const result = await generateVideoProxy(imageId, correctionLut, styleLut);
          
          if (result.success) {
            // Show success feedback
            button.textContent = '‚úÖ Proxy Generated';
            button.style.background = '#00aa00';
            
            // Reload the current video to show the change with cache busting
            await reloadCurrentVideo();
            
            // Reset button after delay
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = '#0066cc';
              button.style.opacity = '1';
              button.disabled = false;
            }, 2000);
          } else {
            throw new Error(result.message || 'Video proxy generation failed');
          }
        } catch (error) {
          console.error('Error generating video proxy:', error);
          
          // Show error feedback
          button.textContent = '‚ùå Failed';
          button.style.background = '#cc0000';
          
          // Reset button after delay
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#0066cc';
            button.style.opacity = '1';
            button.disabled = false;
          }, 2000);
        }
      }
      
      async function generateVideoProxy(imageId, correctionLut, styleLut) {
        /**Generate video proxy with LUTs via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/generate-video-proxy`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              image_id: imageId,
              correction_lut: correctionLut,
              style_lut: styleLut
            })
          });
          
          if (response.ok) {
            return await response.json();
          } else {
            const errorText = await response.text();
            return { success: false, message: errorText };
          }
        } catch (error) {
          console.error('Error generating video proxy:', error);
          return { success: false, message: 'Network error' };
        }
      }
      
      async function handleVideoProxySwitch(imageId, useCustomProxy) {
        /**Handle switching between original video and custom proxy*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/switch-video-proxy`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              image_id: imageId,
              use_custom_proxy: useCustomProxy
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log(`‚úÖ ${result.message}`);
            
            // Reload the current video to show the change with cache busting
            await reloadCurrentVideo();
            
            // Force refresh the entire sidebar to update button states and status text
            await loadSidebar(current);
          } else {
            const error = await response.text();
            console.error('Failed to switch video proxy:', error);
            alert(`‚ùå Failed to switch video proxy: ${error}`);
          }
        } catch (error) {
          console.error('Error switching video proxy:', error);
          alert(`‚ùå Error: ${error.message}`);
        }
      }
      
      async function reloadCurrentVideo() {
        /**Reload the current video with cache busting*/
        const bigvideo = document.getElementById('bigvideo');
        if (bigvideo && bigvideo.style.display !== 'none') {
          const currentSrc = bigvideo.src;
          if (currentSrc) {
            // Add timestamp to bust cache
            const separator = currentSrc.includes('?') ? '&' : '?';
            bigvideo.src = currentSrc.split('?')[0] + '?t=' + Date.now();
          }
        }
      }
      
      async function handleProxySwitch(imageId, useCustomProxy, event) {
        /**Handle proxy switching with user feedback*/
        const button = event.target;
        const originalText = button.textContent;
        
        // Disable button and show loading state
        button.disabled = true;
        button.style.opacity = '0.5';
        button.textContent = '‚è≥ Switching...';
        
        try {
          const result = await switchProxyMode(imageId, useCustomProxy);
          console.log('Proxy switch result:', result);
          
          if (result.success) {
            // Update local metadata to reflect the proxy change
            const meta = images[current];
            if (meta && meta._imageId === imageId) {
              meta.raw_proxy_type = useCustomProxy ? 'custom_generated' : 'original_jpg';
            }
            
            // Show success feedback
            button.textContent = '‚úÖ ' + (useCustomProxy ? 'Using RAW Proxy' : 'Using Original JPG');
            button.style.background = '#00aa00';
            
            // Reload the current image to show the change
            await reloadCurrentImage();
            
            // Explicitly reload thumbnail for this image
            reloadThumbnail(imageId);
            
            // Reload sidebar to update controls
            setTimeout(async () => {
              await loadSidebar(current);
            }, 1000);
            
          } else {
            // Show error feedback
            button.textContent = '‚ùå Failed';
            button.style.background = '#cc0000';
            alert('Failed to switch proxy mode: ' + result.message);
            
            // Restore button after delay
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = useCustomProxy ? '#cc6600' : '#667722';
              button.style.opacity = '1';
              button.disabled = false;
            }, 2000);
          }
        } catch (error) {
          console.error('Proxy switch error:', error);
          button.textContent = '‚ùå Error';
          button.style.background = '#cc0000';
          
          // Restore button after delay
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = useCustomProxy ? '#cc6600' : '#667722';
            button.style.opacity = '1';
            button.disabled = false;
          }, 2000);
        }
      }
      
      async function handleRawGenerate(imageId) {
        /**Handle generating new RAW proxy with two-stage preset selection*/
        const button = event.target;
        const originalText = button.textContent;
        const cameraSelect = document.getElementById(`camera-select-${imageId}`);
        const styleSelect = document.getElementById(`style-select-${imageId}`);
        const exposureSelect = document.getElementById(`exposure-select-${imageId}`);
        const selectedCamera = cameraSelect ? cameraSelect.value : '';
        const selectedStyle = styleSelect ? styleSelect.value : '';
        const selectedExposure = exposureSelect ? parseFloat(exposureSelect.value) : 0.0;
        
        // Disable button and show loading state
        button.disabled = true;
        button.style.opacity = '0.5';
        button.textContent = '‚è≥ Processing...';
        
        try {
          const result = await generateRawProxy(imageId, selectedCamera, selectedStyle, selectedExposure);
          
          if (result.success) {
            // Show success feedback
            button.textContent = '‚úÖ Proxy Generated';
            button.style.background = '#00aa00';
            
            // Reload the current image to show the change
            await reloadCurrentImage();
            
            // Explicitly reload thumbnail for this image
            reloadThumbnail(imageId);
            
            // Reload sidebar to update controls
            setTimeout(async () => {
              await loadSidebar(current);
            }, 1000);
            
          } else {
            // Show error feedback
            button.textContent = '‚ùå Failed';
            button.style.background = '#cc0000';
            alert('Failed to generate RAW proxy: ' + result.message);
            
            // Restore button after delay
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = '#0066cc';
              button.style.opacity = '1';
              button.disabled = false;
            }, 2000);
          }
        } catch (error) {
          console.error('RAW generation error:', error);
          button.textContent = '‚ùå Error';
          button.style.background = '#cc0000';
          
          // Restore button after delay
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#0066cc';
            button.style.opacity = '1';
            button.disabled = false;
          }, 2000);
        }
      }
      
      async function handleRawRegenerate(imageId) {
        /**Handle regenerating existing RAW proxy with new two-stage presets*/
        const button = event.target;
        const originalText = button.textContent;
        const cameraSelect = document.getElementById(`camera-select-${imageId}`);
        const styleSelect = document.getElementById(`style-select-${imageId}`);
        const exposureSelect = document.getElementById(`exposure-select-${imageId}`);
        const selectedCamera = cameraSelect ? cameraSelect.value : '';
        const selectedStyle = styleSelect ? styleSelect.value : '';
        const selectedExposure = exposureSelect ? parseFloat(exposureSelect.value) : 0.0;
        
        // Disable button and show loading state
        button.disabled = true;
        button.style.opacity = '0.5';
        button.textContent = '‚è≥ Regenerating...';
        
        try {
          const result = await generateRawProxy(imageId, selectedCamera, selectedStyle, selectedExposure);
          
          if (result.success) {
            // Show success feedback
            button.textContent = '‚úÖ Regenerated';
            button.style.background = '#00aa00';
            
            // Reload the current image to show the change
            await reloadCurrentImage();
            
            // Explicitly reload thumbnail for this image
            reloadThumbnail(imageId);
            
            // Reload sidebar to update controls
            setTimeout(async () => {
              await loadSidebar(current);
            }, 1000);
            
          } else {
            // Show error feedback
            button.textContent = '‚ùå Failed';
            button.style.background = '#cc0000';
            alert('Failed to regenerate RAW proxy: ' + result.message);
            
            // Restore button after delay
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = '#cc6600';
              button.style.opacity = '1';
              button.disabled = false;
            }, 2000);
          }
        } catch (error) {
          console.error('RAW regeneration error:', error);
          button.textContent = '‚ùå Error';
          button.style.background = '#cc0000';
          
          // Restore button after delay
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#cc6600';
            button.style.opacity = '1';
            button.disabled = false;
          }, 2000);
        }
      }
      
      function getDisplayImageUrl(meta) {
        /**Get the display URL for an image from metadata*/
        return meta.SourceFile || meta.src || meta.FileName;
      }
      
      async function reloadCurrentImage() {
        /**Reload the currently displayed image to reflect proxy changes*/
        if (mode === 'thumbs' || !images[current]) return;
        
        const meta = images[current];
        const timestampUrl = getDisplaySource(meta, true); // Use proper proxy logic with timestamp
        
        if (mode === 'fit' || mode === 'zoom') {
          // Using adjacent image system - update the current visible element
          if (adjacentImages.current) {
            adjacentImages.current.src = timestampUrl;
            
            // Reload faces after adjacent image loads
            adjacentImages.current.onload = () => {
              if (facesVisible && meta._imageId) {
                loadAndDisplayFaces();
              }
            };
          } else if (adjacentVideos.current) {
            // Adjacent video system is active
            adjacentVideos.current.src = timestampUrl;
          }
        }
        
        // Thumbnail reload is handled separately when explicitly needed for proxy changes
      }
      
      function reloadThumbnail(imageId) {
        /**Force reload thumbnail with timestamp to show updated version*/
        if (!imageId) return;
        
        // Find thumbnail in grid view and force reload
        const thumbnailImg = document.querySelector(`img[data-image-id="${imageId}"]`);
        if (thumbnailImg) {
          const originalSrc = thumbnailImg.src.split('?')[0]; // Remove existing timestamp
          thumbnailImg.src = originalSrc + '?t=' + Date.now();
        }
        
        // Only reload thumbnail in current view to avoid performance issues during gallery switching
        // The expensive querySelectorAll is only used when specifically needed for proxy changes
      }
      
      async function showFaces(faces, containerElement) {
        /**Display face detection boxes on an image*/
        // Clear existing face overlays
        const existingFaces = containerElement.querySelectorAll('.face-overlay');
        existingFaces.forEach(el => el.remove());
        
        // Don't show faces in zoom mode (1:1 pixel view - too crowded)
        if (mode === "zoom") {
          console.log('Hiding faces in zoom mode');
          return;
        }
        
        if (!facesVisible || !faces || faces.length === 0) return;
        
        // Get the currently visible image element (either bigimg or adjacent image)
        let imgElement = null;
        
        // First try to find the current visible adjacent image
        const currentAdjacent = adjacentImages.current || adjacentVideos.current;
        if (currentAdjacent && currentAdjacent.style.opacity === "1") {
          imgElement = currentAdjacent;
        } else {
          // Fallback to bigimg for compatibility
          imgElement = containerElement.querySelector('#bigimg');
        }
        
        if (!imgElement) {
          console.log('No visible image element found, skipping face display');
          return;
        }
        
        // For video elements, skip face detection
        if (imgElement.tagName === 'VIDEO') {
          console.log('Video element detected, skipping face display');
          return;
        }
        
        if (!imgElement.complete && imgElement.tagName === 'IMG') {
          console.log('Image not loaded yet, skipping face display');
          return;
        }
        
        // Calculate scale factors between original image and displayed image
        const naturalWidth = imgElement.naturalWidth;
        const naturalHeight = imgElement.naturalHeight;
        
        if (!naturalWidth || !naturalHeight) {
          console.log('Could not get image dimensions');
          return;
        }
        
        // For images with object-fit: contain, we need to calculate the actual rendered size
        const containerWidth = imgElement.clientWidth;
        const containerHeight = imgElement.clientHeight;
        
        // Calculate the scale to fit the image within the container while maintaining aspect ratio
        const scaleToFitX = containerWidth / naturalWidth;
        const scaleToFitY = containerHeight / naturalHeight;
        const scaleToFit = Math.min(scaleToFitX, scaleToFitY);
        
        // Calculate actual displayed image dimensions
        const displayedWidth = naturalWidth * scaleToFit;
        const displayedHeight = naturalHeight * scaleToFit;
        
        // Calculate centering offset within the container
        const centerOffsetX = (containerWidth - displayedWidth) / 2;
        const centerOffsetY = (containerHeight - displayedHeight) / 2;
        
        // Get the image's position relative to the container
        const imgRect = imgElement.getBoundingClientRect();
        const containerRect = containerElement.getBoundingClientRect();
        const offsetX = imgRect.left - containerRect.left + centerOffsetX;
        const offsetY = imgRect.top - containerRect.top + centerOffsetY;
        
        console.log(`üîç Face positioning debug:`);
        console.log(`  Container: ${containerElement.id || containerElement.className}`);
        console.log(`  Image element: ${imgElement.id || imgElement.className} (${imgElement.tagName})`);
        console.log(`  Container size: ${containerWidth}x${containerHeight}`);
        console.log(`  Natural size: ${naturalWidth}x${naturalHeight}`);
        console.log(`  Actual displayed size: ${displayedWidth.toFixed(1)}x${displayedHeight.toFixed(1)}`);
        console.log(`  Scale to fit: ${scaleToFit.toFixed(3)}`);
        console.log(`  Center offset: ${centerOffsetX.toFixed(1)}px, ${centerOffsetY.toFixed(1)}px`);
        console.log(`  Final offset: ${offsetX.toFixed(1)}px, ${offsetY.toFixed(1)}px`);
        
        // Show all faces (identified and unidentified)
        for (let index = 0; index < faces.length; index++) {
          const face = faces[index];
          const overlay = document.createElement('div');
          overlay.className = 'face-overlay visible';
          
          // Scale face coordinates to match displayed image
          const scaledX = face.x * scaleToFit + offsetX;
          const scaledY = face.y * scaleToFit + offsetY;
          const scaledWidth = face.width * scaleToFit;
          const scaledHeight = face.height * scaleToFit;
          
          overlay.style.left = `${scaledX}px`;
          overlay.style.top = `${scaledY}px`;
          overlay.style.width = `${scaledWidth}px`;
          overlay.style.height = `${scaledHeight}px`;
          
          console.log(`Face ${index}: orig(${face.x},${face.y},${face.width}x${face.height}) -> scaled(${scaledX.toFixed(0)},${scaledY.toFixed(0)},${scaledWidth.toFixed(0)}x${scaledHeight.toFixed(0)})`);
          
          
          // Add name/confidence label
          const label = document.createElement('div');
          label.className = 'face-label';
          
          // Adjust label position if face box goes off top of screen
          const labelHeight = 25; // Height of label plus margin
          if (scaledY < labelHeight) {
            // Move label below the face box instead of above
            label.style.top = `${scaledHeight + 5}px`;
          } else {
            // Default position above the face box
            label.style.top = '-25px';
          }
          
          if (face.person_name && face.confirmed) {
            // Check if this is a Person # format that can be renamed
            if (/^Person \d+$/.test(face.person_name)) {
              await createPersonRenameControls(label, face);
            } else {
              label.textContent = `${face.person_name} (${(face.confidence * 100).toFixed(0)}%)`;
              label.style.background = 'rgba(0, 150, 255, 0.8)'; // Blue for confirmed
            }
          } else if (face.person_name) {
            // Check if this is a Person # format that can be renamed
            if (/^Person \d+$/.test(face.person_name)) {
              await createPersonRenameControls(label, face);
            } else {
              label.textContent = `${face.person_name}? (${(face.confidence * 100).toFixed(0)}%)`;
              label.style.background = 'rgba(255, 150, 0, 0.8)'; // Orange for unconfirmed
            }
          } else {
            // Unidentified face - create interactive controls
            await createUnidentifiedFaceControls(label, face);
          }
          
          overlay.appendChild(label);
          
          containerElement.appendChild(overlay);
        }
      }
      
      function toggleFaceDetection() {
        /**Toggle face detection overlay visibility*/
        facesVisible = !facesVisible;
        
        // Update all visible face overlays
        const allFaceOverlays = document.querySelectorAll('.face-overlay');
        allFaceOverlays.forEach(overlay => {
          overlay.classList.toggle('visible', facesVisible);
        });
        
        console.log(`Face detection: ${facesVisible ? 'ON' : 'OFF'}`);
        
        // If we're in single view and turning ON, load faces for current image
        if (mode !== 'thumbs' && facesVisible && images[current]) {
          console.log('Triggering face load after toggle');
          loadFacesForCurrentImage();
        }
        
        // If turning off, clear existing overlays
        if (!facesVisible) {
          const existingFaces = document.querySelectorAll('.face-overlay');
          existingFaces.forEach(el => el.remove());
        }
      }
      
      async function loadFacesForCurrentImage() {
        /**Load and display faces for the currently viewed image*/
        if (!images[current]) return;
        
        // Clear existing face overlays from both old bigimgWrap and singleview containers
        const existingFaces = document.querySelectorAll('.face-overlay');
        existingFaces.forEach(el => el.remove());
        
        const meta = images[current];
        const imageId = meta._imageId || meta.id; // Assuming we add image ID to JSON
        
        console.log('Loading faces for image:', current, 'imageId:', imageId, 'meta:', meta);
        
        if (imageId) {
          const faces = await loadFaces(imageId);
          console.log('Loaded faces:', faces);
          if (faces.length > 0) {
            // Use singleview as container since that's where adjacent images are positioned
            await showFaces(faces, singleview);
            // Show face detection controls if faces are found
            showFaceDetectionControls(true);
          } else {
            console.log('No faces found for image:', imageId);
            // Hide face detection controls if no faces
            showFaceDetectionControls(false);
            // Turn off face detection if it was on
            if (facesVisible) {
              facesVisible = false;
              console.log('Auto-disabled face detection - no faces in image');
            }
          }
        } else {
          console.log('No imageId found in meta data');
          showFaceDetectionControls(false);
        }
      }
      
      function showFaceDetectionControls(show) {
        /**Show or hide face detection controls based on whether image has faces*/
        const faceToggleButton = document.querySelector('[onclick*="toggleFaceDetection"]');
        if (faceToggleButton) {
          faceToggleButton.style.display = show ? 'block' : 'none';
        }
        
        // Also hide the keyboard shortcut hint if no faces
        const shortcutHints = document.querySelectorAll('[title*="face"]');
        shortcutHints.forEach(hint => {
          if (hint.textContent.toLowerCase().includes('face')) {
            hint.style.display = show ? 'block' : 'none';
          }
        });
      }
      
      async function loadGalleries(forceReload = false) {
        // Force reload if requested
        if (forceReload) {
          galleriesListLoaded = false;
          galleryCacheBuilt = false;
          galleryCache = null;
        }

        // Only load galleries once (unless forcing reload)
        if (!forceReload && galleriesListLoaded && galleries.length > 0) {
          return;
        }
        
        try {
          const response = await fetch(`JSON/galleries.json?t=${Date.now()}`);
          if (response.ok) {
            galleries = await response.json();
            console.log(`Loaded ${galleries.length} galleries from galleries.json`);
            renderGalleries();
            galleriesListLoaded = true;
          } else {
            console.log('galleries.json not found - run start_gallery_server.sh first');
            galleries = [];
            renderGalleries();
          }
        } catch (error) {
          console.log('Failed to load galleries.json:', error);
          galleries = [];
          renderGalleries();
        }
      }
      
      
      function renderGalleries() {
        const selector = document.getElementById('gallery-selector');
        const header = selector.querySelector('.gallery-header');
        
        // Clear existing items
        const existingItems = selector.querySelectorAll('.gallery-item');
        existingItems.forEach(item => item.remove());
        
        galleries.forEach(gallery => {
          const item = document.createElement('div');
          item.className = 'gallery-item';
          
          // Create gallery name span
          const nameSpan = document.createElement('span');
          nameSpan.textContent = gallery.name;
          
          // Create count badge
          const countBadge = document.createElement('span');
          countBadge.className = 'gallery-count-badge';
          const count = gallery.image_count || gallery.imageCount || 0;
          countBadge.textContent = count.toString();
          
          // Append both elements
          item.appendChild(nameSpan);
          item.appendChild(countBadge);
          
          item.dataset.galleryPath = gallery.jsonPath;
          
          if (currentGallery === gallery.jsonPath) {
            item.classList.add('active');
          }
          
          item.addEventListener('click', () => {
            loadGallery(gallery.jsonPath, gallery.name);
          });
          
          selector.appendChild(item);
        });
      }
      
      async function loadGallery(jsonPath, galleryName) {
        try {
          // Force return to thumbnail view and clear state
          if (mode !== "thumbs") {
            mode = "thumbs";
            singleview.classList.remove("visible");
            // Also clear z-index to ensure thumbnail grid is shown
            singleview.style.zIndex = "1";
            thumbgrid.style.zIndex = "200";
            thumbgrid.style.display = "grid";
            
            // Reset video z-index when forcing thumbnail mode
            const videoEl = document.getElementById('bigvideo');
            if (videoEl) {
              videoEl.style.zIndex = "1";
            }
          }
          
          // Clear current state immediately to prevent conflicts
          const oldImages = images;
          images = [];
          current = 0;
          selectedThumbnails.clear(); // Clear selection when switching galleries
          
          // Clear visual thumbnail highlights
          document.querySelectorAll('.thumb-cell.selected').forEach(cell => {
            cell.classList.remove('selected');
          });
          
          // Clear gallery keyboard navigation state
          clearGalleryFocus();
          
          preloadCache.clear(); // Clear preload cache when switching galleries
          stopPreloading(); // Stop background preloading for previous gallery
          clearAdjacentElements(); // Clear adjacent image elements
          // Keep picks across galleries for multi-gallery selection
          
          // Clear big image/video sources to prevent stale loads
          bigimg.src = '';
          // Properly clear video without invalid URI error
          const videoEl = document.getElementById('bigvideo');
          if (videoEl) {
            videoEl.pause();
            videoEl.removeAttribute('src');
            videoEl.load();
            videoEl.style.display = 'none';
          }
          bigimg.style.display = 'block';
          
          const response = await fetch(`${jsonPath}?t=${Date.now()}`);
          if (!response.ok) throw new Error('Gallery not found');
          
          const galleryData = await response.json();
          images = galleryData;
          currentGallery = jsonPath;
          
          // Apply default sort order to new gallery
          sortImages(currentSortOrder);
          
          // Initialize with first image selected
          if (images.length > 0) {
            selectedThumbnails.add(0);
          }
          
          // Update UI
          renderGalleries(); // Update active state
          renderThumbnails();
          updateSelectionDisplay();
          
          // Load picks and rejects, then update visual indicators
          initializePicksAndRejects();
          
          loadSidebar(0).catch(console.error);
          
          console.log(`Loaded gallery: ${galleryName} (${images.length} images)`);
        } catch (error) {
          console.error('Failed to load gallery:', galleryName, 'Error:', error.message);
          // Don't show alert for transient errors if the gallery might still work
        }
      }
      
      // Deferred loading system
      let loadTimeouts = new Map();
      // let intersectionObserver = null; // Disabled - using immediate loading
      let loadedImages = new Set(); // Track which images are loaded (still used for picks)
      // let viewportCenter = 0; // Track current viewport center
      // const MAX_LOADED_IMAGES = 200;
      
      function initDeferredLoading() {
        if (intersectionObserver) {
          intersectionObserver.disconnect();
        }
        
        intersectionObserver = new IntersectionObserver((entries) => {
          // Update viewport center based on intersecting entries
          updateViewportCenter(entries);
          
          entries.forEach(entry => {
            const cell = entry.target;
            const idx = parseInt(cell.dataset.idx);
            
            if (entry.isIntersecting) {
              // Schedule load after 1 second in viewport
              if (!loadTimeouts.has(idx)) {
                const timeoutId = setTimeout(() => {
                  loadThumbnail(cell, idx);
                  loadTimeouts.delete(idx);
                }, 1000);
                loadTimeouts.set(idx, timeoutId);
              }
            } else {
              // Clear any pending load if not yet loaded
              if (loadTimeouts.has(idx)) {
                clearTimeout(loadTimeouts.get(idx));
                loadTimeouts.delete(idx);
                
                // Only cancel loading for images that haven't started loading yet
                cancelPendingLoad(cell, idx);
              }
            }
          });
        }, {
          rootMargin: '50px',
          threshold: 0.1
        });
      }
      
      function updateViewportCenter(entries) {
        // Calculate approximate viewport center based on visible entries
        let visibleIndices = [];
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            visibleIndices.push(parseInt(entry.target.dataset.idx));
          }
        });
        
        if (visibleIndices.length > 0) {
          viewportCenter = visibleIndices.reduce((a, b) => a + b, 0) / visibleIndices.length;
        }
      }
      
      function getDistanceFromViewport(idx) {
        return Math.abs(idx - viewportCenter);
      }
      
      function enforceMemoryLimit() {
        if (loadedImages.size <= MAX_LOADED_IMAGES) return;
        
        // Get all loaded images with their distances from viewport
        const loadedWithDistances = Array.from(loadedImages).map(idx => ({
          idx: idx,
          distance: getDistanceFromViewport(idx)
        }));
        
        // Sort by distance (furthest first)
        loadedWithDistances.sort((a, b) => b.distance - a.distance);
        
        // Unload the furthest images until we're under the limit
        const toUnload = loadedWithDistances.slice(0, loadedImages.size - MAX_LOADED_IMAGES + 50); // Unload 50 extra for buffer
        
        toUnload.forEach(item => {
          const cell = document.querySelector(`.thumb-cell[data-idx='${item.idx}']`);
          if (cell && !cell.classList.contains('selected')) { // Don't unload selected image
            unloadThumbnail(cell, item.idx);
          }
        });
        
        console.log(`üìâ Memory management: Unloaded ${toUnload.length} images furthest from viewport`);
      }
      
      function loadThumbnail(cell, idx) {
        const meta = images[idx];
        if (!meta) return;
        
        // Use thumbnail if available, otherwise fall back to main image
        let src;
        if (meta._thumbnail) {
          src = meta._thumbnail;
        } else {
          src = meta.SourceFile || meta.src || meta.FileName;
        }
        const cleanSrc = src.replace(/^\.\//, "");
        
        // Check if already has content loaded
        const img = cell.querySelector('img');
        const alreadyLoaded = (img && img.src);
        
        if (alreadyLoaded && loadedImages.has(idx)) {
          // Already loaded and tracked
          return;
        }
        
        // Load the content - now both images and videos use img elements for thumbnails
        if (img) {
          if (isVideoFile(cleanSrc) && meta._thumbnail) {
            // For videos, use generated thumbnail
            img.src = meta._thumbnail;
          } else {
            // For images or videos without thumbnails, use original source
            img.src = cleanSrc;
          }
          img.alt = meta.FileName || "";
        }
        
        cell.dataset.loaded = 'true';
        loadedImages.add(idx);
        
        console.log(`üì∏ Loaded thumbnail ${idx} (${loadedImages.size}/${MAX_LOADED_IMAGES})`);
        
        // Check if we need to unload distant images
        enforceMemoryLimit();
      }
      
      function unloadThumbnail(cell, idx) {
        // Only unload if not currently selected
        if (cell.classList.contains('selected')) return;
        
        // Clear any pending load timeout for this image
        if (loadTimeouts.has(idx)) {
          clearTimeout(loadTimeouts.get(idx));
          loadTimeouts.delete(idx);
        }
        
        const img = cell.querySelector('img');
        
        if (img && img.src) {
          img.src = '';
        }
        
        cell.dataset.loaded = 'false';
        loadedImages.delete(idx);
        
        console.log(`üóëÔ∏è Unloaded thumbnail ${idx}`);
      }
      
      function cancelPendingLoad(cell, idx) {
        // This is called when an image leaves viewport before it finished loading
        // Only affects images that were scheduled to load but haven't started yet
        
        // The timeout was already cleared, so no action needed here
        // Images that were already loading will complete, images that hadn't started won't start
      }

      function renderThumbnails() {
        // Cancel any pending image loads from previous gallery
        const existingImages = thumbgrid.querySelectorAll('img');
        existingImages.forEach(img => {
          img.src = ''; // Cancel pending load
        });
        
        // Clear timeouts and reset tracking
        loadTimeouts.forEach(id => clearTimeout(id));
        loadTimeouts.clear();
        loadedImages.clear();
        viewportCenter = 0;
        
        // Clear DOM
        thumbgrid.innerHTML = "";
        
        images.forEach((meta, i) => {
          const src = meta.SourceFile || meta.src || meta.FileName;
          const cleanSrc = src.replace(/^\.\//, "");
          const cell = document.createElement("div");
          cell.className = "thumb-cell";
          cell.dataset.idx = i;
          
          // Load all thumbnails immediately - no lazy loading
          if (isVideoFile(cleanSrc)) {
            // For videos, use generated thumbnail image instead of video element
            const img = document.createElement("img");
            if (meta._thumbnail) {
              img.src = meta._thumbnail;
            } else {
              // Fallback to video file if no thumbnail available
              img.src = cleanSrc;
            }
            img.alt = meta.FileName || "";
            cell.classList.add("video-thumbnail");
            cell.appendChild(img);
          } else {
            const img = document.createElement("img");
            // Always use thumbnail if available, otherwise original
            if (meta._thumbnail) {
              img.src = meta._thumbnail;
            } else {
              img.src = cleanSrc;
            }
            img.alt = meta.FileName || "";
            cell.appendChild(img);
          }
          
          cell.dataset.loaded = 'true';
          loadedImages.add(i);
          
          thumbgrid.appendChild(cell);
        });
        
        console.log(`üì∏ Loaded all ${images.length} thumbnails immediately`);
        
        // Start background preloading after thumbnails are loaded
        startBackgroundPreloading();
      }
      
      function startBackgroundPreloading() {
        /**Start aggressive background preloading of full-size images*/
        if (preloadingActive || !images || images.length === 0) return;
        
        console.log('üöÄ Starting background preloading of full-size images');
        preloadingActive = true;
        preloadedImages.clear();
        
        // Create preload queue starting from current selection, then spiral outward
        createPreloadQueue();
        
        // Start preloading
        continuePreloading();
      }
      
      function createPreloadQueue() {
        /**Create preload queue starting from selected image, spiraling outward (limited to maxPreloadImages) - IMAGES ONLY*/
        preloadQueue = [];
        const startIndex = current || 0;
        const visited = new Set();
        
        // Add selected image first (only if it's not a video)
        if (!isVideoFile(images[startIndex]?.SourceFile || images[startIndex]?.src || images[startIndex]?.FileName || '')) {
          preloadQueue.push(startIndex);
          visited.add(startIndex);
        }
        
        // Spiral outward from selected image, but limit total count and exclude videos
        let distance = 1;
        while (visited.size < Math.min(images.length, maxPreloadImages)) {
          // Add images at distance before and after current
          const before = (startIndex - distance + images.length) % images.length;
          const after = (startIndex + distance) % images.length;
          
          // Check if before index is not a video
          if (!visited.has(before) && visited.size < maxPreloadImages) {
            const beforeFile = images[before]?.SourceFile || images[before]?.src || images[before]?.FileName || '';
            if (!isVideoFile(beforeFile)) {
              preloadQueue.push(before);
              visited.add(before);
            }
          }
          
          // Check if after index is not a video
          if (!visited.has(after) && after !== before && visited.size < maxPreloadImages) {
            const afterFile = images[after]?.SourceFile || images[after]?.src || images[after]?.FileName || '';
            if (!isVideoFile(afterFile)) {
              preloadQueue.push(after);
              visited.add(after);
            }
          }
          
          distance++;
          
          // Safety check to prevent infinite loop in small galleries
          if (distance > Math.ceil(images.length / 2)) {
            break;
          }
        }
        
        console.log(`üìã Created preload queue of ${preloadQueue.length} IMAGES ONLY (max ${maxPreloadImages}) starting from index ${startIndex}`);
      }
      
      function continuePreloading() {
        /**Continue preloading the next image in queue - IMAGES ONLY*/
        if (!preloadingActive || currentPreloadIndex >= preloadQueue.length) {
          console.log(`‚úÖ Background preloading completed (${preloadedImages.size} images cached)`);
          preloadingActive = false;
          return;
        }
        
        const imageIndex = preloadQueue[currentPreloadIndex];
        const meta = images[imageIndex];
        
        if (!meta || preloadedImages.has(imageIndex)) {
          // Skip already preloaded or invalid images
          currentPreloadIndex++;
          setTimeout(continuePreloading, 1);
          return;
        }
        
        // Double-check that this isn't a video (safety check)
        const fileName = meta.SourceFile || meta.src || meta.FileName || '';
        if (isVideoFile(fileName)) {
          console.warn(`‚ö†Ô∏è Skipping video in preload queue: ${fileName}`);
          currentPreloadIndex++;
          setTimeout(continuePreloading, 1);
          return;
        }
        
        // Create an image element to preload
        const img = new Image();
        const displaySrc = getDisplaySource(meta, false); // No timestamp for caching
        
        console.log(`üîÑ Preloading image index ${imageIndex} with URL: ${displaySrc}`);
        
        img.onload = () => {
          preloadedImages.add(imageIndex);
          
          // Check if image was loaded from cache or server
          setTimeout(() => {
            const cacheStatus = checkImageCacheStatus(displaySrc);
            console.log(`üì∏ Preloaded image ${currentPreloadIndex + 1}/${preloadQueue.length} (index ${imageIndex + 1}) - ${cacheStatus.toUpperCase()}`);
          }, 10);
          
          currentPreloadIndex++;
          
          // Continue with next image after small delay to avoid blocking UI
          setTimeout(continuePreloading, 50);
        };
        
        img.onerror = () => {
          console.warn(`‚ö†Ô∏è Failed to preload image ${currentPreloadIndex + 1}/${preloadQueue.length} (index ${imageIndex})`);
          currentPreloadIndex++;
          setTimeout(continuePreloading, 1);
        };
        
        img.src = displaySrc;
      }
      
      function restartPreloadingFromSelection() {
        /**Restart preloading from newly selected image*/
        if (!images || images.length === 0) return;
        
        console.log(`üîÑ Selection changed to image ${current + 1}`);
        
        if (preloadingActive) {
          console.log(`‚èπÔ∏è Cancelling current preloading batch (was at ${currentPreloadIndex}/${preloadQueue.length})`);
          // Stop current preloading
          preloadingActive = false;
        }
        
        // Start fresh preloading from new selection
        console.log(`üöÄ Starting new preload batch from image ${current + 1}`);
        preloadingActive = true;
        currentPreloadIndex = 0;
        createPreloadQueue();
        
        // Start preloading from new queue
        continuePreloading();
      }
      
      function stopPreloading() {
        /**Stop background preloading (for gallery changes)*/
        if (preloadingActive) {
          console.log('‚èπÔ∏è Stopping background preloading');
          preloadingActive = false;
          preloadQueue = [];
          currentPreloadIndex = 0;
        }
      }
      
      function checkImageCacheStatus(imageUrl) {
        /**Check if an image was loaded from cache or server using Performance API*/
        try {
          // Try different URL variations that might be in performance entries
          const urlsToCheck = [
            imageUrl,
            new URL(imageUrl, window.location.href).href, // Convert to absolute URL
            encodeURI(imageUrl), // Handle special characters
            imageUrl.replace(/^\.\//, '') // Remove leading ./
          ];
          
          for (const url of urlsToCheck) {
            const entries = performance.getEntriesByName(url);
            if (entries.length > 0) {
              const entry = entries[entries.length - 1]; // Get most recent entry
              
              console.log(`üîç Performance entry for ${url}:`, {
                transferSize: entry.transferSize,
                decodedBodySize: entry.decodedBodySize,
                encodedBodySize: entry.encodedBodySize,
                duration: entry.duration
              });
              
              // More robust cache detection
              if (entry.transferSize === 0 && entry.decodedBodySize > 0) {
                return 'cached';
              } else if (entry.transferSize > 0) {
                return 'server';
              } else if (entry.duration === 0 || entry.duration < 1) {
                return 'cached (fast)'; // Very fast load likely means cached
              }
            }
          }
          
          // Check all performance entries to see what URLs are actually recorded
          const allEntries = performance.getEntriesByType('resource');
          const imageEntries = allEntries.filter(e => 
            e.initiatorType === 'img' && 
            (e.name.includes(imageUrl) || imageUrl.includes(e.name.split('/').pop()))
          );
          
          if (imageEntries.length > 0) {
            console.log(`üîç Found related image entries:`, imageEntries.map(e => e.name));
            const entry = imageEntries[imageEntries.length - 1];
            if (entry.transferSize === 0 && entry.decodedBodySize > 0) {
              return 'cached (matched)';
            } else if (entry.transferSize > 0) {
              return 'server (matched)';
            }
          }
          
          return 'unknown (no perf entry)';
        } catch (e) {
          console.warn('Cache status check error:', e);
          return 'error';
        }
      }
      
      document.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        
        // DEBUG: console.log('Keydown event:', e.key, 'inputFieldFocused:', inputFieldFocused, 'commandPaletteOpen:', commandPaletteOpen);
        
        // Skip keyboard shortcuts when an input field is focused (except for command palette)
        if (inputFieldFocused && !commandPaletteOpen) return;
        
        // Handle command palette
        if (commandPaletteOpen) {
          if (e.key === "Escape") {
            if (commandPaletteMode === 'gallery') {
              // Exit gallery mode, go back to main commands
              commandPaletteMode = null;
              commandPaletteSearchString = '';
              commandInput.value = '';
              commandInput.placeholder = 'Type a command...';
              updateCommandPalette('');
            } else {
              closeCommandPalette();
            }
            e.preventDefault();
            return;
          }
          if (e.key === "ArrowUp") {
            navigateCommandPalette(-1);
            e.preventDefault();
            return;
          }
          if (e.key === "ArrowDown") {
            navigateCommandPalette(1);
            e.preventDefault();
            return;
          }
          if (e.key === "Enter") {
            executeSelectedCommand();
            e.preventDefault();
            return;
          }
          // Let other keys pass through to the input
          return;
        }
        
        // Open command palette with "/"
        if (e.key === "/" && !e.ctrlKey && !e.metaKey) {
          openCommandPalette();
          e.preventDefault();
          return;
        }
        
        // Handle cull mode keys
        if (cullMode) {
          if (e.key === "ArrowLeft") {
            handleCullNavigation(-1);
            e.preventDefault();
            return;
          }
          if (e.key === "ArrowRight") {
            handleCullNavigation(1);
            e.preventDefault();
            return;
          }
          if (e.key === "p") {
            handleCullPick();
            e.preventDefault();
            return;
          }
          if (e.key === " ") {
            if (cullZoomMode) {
              exitCullZoom();
            } else {
              enterCullZoom();
            }
            e.preventDefault();
            return;
          }
          if (e.key === "f") {
            exitCullMode(true); // Mark for deletion
            e.preventDefault();
            return;
          }
          if (e.key === "q" || e.key === "Q") {
            exitCullMode(false); // Cancel without marking
            e.preventDefault();
            return;
          }
          // Block other keys in cull mode
          e.preventDefault();
          return;
        }
        
        // Handle gallery 'g' key behavior - close gallery if open, open if closed
        if (e.key === "g") {
          if (gallerySelectorOpen) {
            // Gallery bar is open - close it
            clearGalleryFocus();
            toggleGallerySelector();
          } else {
            // Gallery bar is closed - open it (but don't focus)
            toggleGallerySelector();
          }
          e.preventDefault();
          return;
        }
        
        // Handle gallery navigation - Shift+Up/Down when gallery is open
        if (gallerySelectorOpen && e.shiftKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          if (!gallerySelectorFocused) focusGallerySelector(); // Auto-focus on Shift+arrow keys
          handleGalleryNavigation(e.key === "ArrowDown" ? 1 : -1);
          e.preventDefault();
          return;
        }
        
        // Handle gallery selection and escape
        if (gallerySelectorOpen && gallerySelectorFocused) {
          if (e.key === "Enter" && selectedGalleryIndex >= 0) {
            selectGalleryByIndex(selectedGalleryIndex);
            e.preventDefault();
            return;
          }
          if (e.key === "Escape") {
            clearGalleryFocus();
            e.preventDefault();
            return;
          }
        }
        
        // Normal mode keys
        if (e.key === "ArrowLeft") handleArrow(-1, e.shiftKey);
        if (e.key === "ArrowRight") handleArrow(1, e.shiftKey);
        if (e.key === "ArrowUp") handleVerticalArrow(-1, e.shiftKey);
        if (e.key === "ArrowDown") handleVerticalArrow(1, e.shiftKey);
        if (e.key === " ") {
          if (mode === "thumbs") {
            // Check if we should enter cull mode
            if (selectedThumbnails.size > 1) {
              enterCullMode();
            } else if (selectedThumbnails.size === 1) {
              // Set current index to the selected thumbnail before showing single view
              const selectedIndex = Array.from(selectedThumbnails)[0];
              current = selectedIndex;
              showSingle("fit");
            }
          } else if (mode === "fit") {
            enterZoom();
          } else if (mode === "zoom") {
            exitZoom();
          }
          e.preventDefault();
        }
        if (e.key === "q" || e.key === "Q") {
          // Stop any playing video
          const currentVideo = document.getElementById('bigvideo');
          if (currentVideo && !currentVideo.paused) {
            console.log('üé¨ Stopping video on "q" key press');
            currentVideo.pause();
            currentVideo.currentTime = 0; // Reset to beginning
          }
          
          if (mode === "zoom") exitZoom();
          else if (mode === "fit") showThumbs();
          else if (mode === "thumbs") {
            // Clear all selections in thumbnail mode
            selectedThumbnails.clear();
            updateSelectionDisplay();
          }
        }
        if (e.key === "m") toggleSidebar();
        if (e.key === "p") {
          togglePick();
        }
        if (e.key === "x") {
          toggleReject();
        }
        if (e.key === "l") togglePicksList();
        // 'g' key handler removed - sophisticated 'g' behavior is handled earlier in the keydown handler
        if (e.key === "o") toggleFaceDetection(); // Changed from 'f' to 'o' to avoid conflict
        if (e.key === "s") toggleStatusFeed(); // Toggle status feed log
      });

      // Click-to-zoom removed for better face control interaction
      // Use spacebar to zoom instead
      
      bigvideo.addEventListener("click", (e) => {
        // For videos, don't interfere with native controls
        e.stopPropagation();
      });

      thumbgrid.addEventListener("click", (e) => {
        // Skip click handling on touch devices to prevent conflicts
        if (isTouchDevice) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        
        let cell = e.target.closest(".thumb-cell");
        if (!cell) return;
        
        const clickedIndex = +cell.dataset.idx;
        
        // New selection model: single click selects, shift+click does range selection, cmd/ctrl+click toggles
        if (e.shiftKey) {
          e.preventDefault();
          selectThumbnail(clickedIndex, true, false);
          return;
        }
        
        // Cmd/Ctrl+click - toggle selection
        if (e.metaKey || e.ctrlKey) {
          e.preventDefault();
          selectThumbnail(clickedIndex, false, true);
          return;
        }
        
        // Normal click - just select the thumbnail
        selectThumbnail(clickedIndex, false, false);
      });
      

      // Initialize the gallery system
      // initDeferredLoading(); // Disabled - using immediate loading
      
      loadGalleries().then(() => {
        // Show gallery selection message instead of auto-loading first gallery
        showGallerySelectionMessage();
        sidebar.classList.add("visible");
      });

      // Touch device initialization and handlers
      function initializeTouchSupport() {
        isTouchDevice = detectTouchDevice();
        
        if (isTouchDevice) {
          document.getElementById('touch-toolbar').classList.add('visible');
          
          // Add touch toolbar event handlers
          document.getElementById('touch-gallery-btn').addEventListener('click', toggleGallerySelector);
          document.getElementById('touch-pick-btn').addEventListener('click', () => {
            if (cullMode) {
              // In cull mode, do what 'p' key does
              handleCullPick();
            } else if (selectedThumbnails.size > 0) {
              // In normal mode, do what 'p' key does
              togglePick();
              updatePickClasses();
            }
          });
          document.getElementById('touch-reject-btn').addEventListener('click', () => {
            if (selectedThumbnails.size > 0) {
              toggleReject();
              updatePickClasses();
            }
          });
          document.getElementById('touch-faces-btn').addEventListener('click', () => {
            facesVisible = !facesVisible;
            document.getElementById('touch-faces-btn').classList.toggle('active', facesVisible);
            loadFacesForCurrentImage();
          });
          document.getElementById('touch-sidebar-btn').addEventListener('click', () => {
            sidebarOpen = !sidebarOpen;
            sidebar.classList.toggle('visible', sidebarOpen);
            document.getElementById('touch-sidebar-btn').classList.toggle('active', sidebarOpen);
          });
          document.getElementById('touch-picks-btn').addEventListener('click', () => {
            // Do what 'l' key does - toggle picks list
            togglePicksList();
          });
          document.getElementById('touch-status-btn').addEventListener('click', () => {
            // Do what 's' key does - toggle status feed
            toggleStatusFeed();
          });
          document.getElementById('touch-command-btn').addEventListener('click', () => {
            // Do what '/' key does - open command palette
            openCommandPalette();
          });
          document.getElementById('touch-finish-btn').addEventListener('click', () => {
            // Do what 'f' key does in cull mode - finish cull
            if (cullMode) {
              exitCullMode(true);
            }
          });
          document.getElementById('touch-prev-btn').addEventListener('click', () => {
            // Do what left arrow key does
            handleArrow(-1, false);
          });
          document.getElementById('touch-next-btn').addEventListener('click', () => {
            // Do what right arrow key does
            handleArrow(1, false);
          });
          document.getElementById('touch-clear-btn').addEventListener('click', () => {
            // Do what 'q' key does - clear selection and exit modes
            if (cullMode) {
              // In cull mode, exit cull mode (same as 'q' in cull mode)
              exitCullMode(false);
            } else {
              selectedThumbnails.clear();
              touchMode = 'normal';
              updateSelectionDisplay();
              
              // Hide single view if visible (like 'q' does)
              if (singleview.classList.contains('visible')) {
                showThumbs();
              } else {
                updateTouchToolbar();
              }
            }
          });
          document.getElementById('touch-cull-btn').addEventListener('click', () => {
            if (cullMode) {
              // In cull mode, do what 'f' key does - finish cull
              exitCullMode(true);
            } else if (selectedThumbnails.size > 1) {
              // In selection mode, enter cull mode
              enterCullMode();
            }
          });
          
          // Cull mode toolbar handlers
          document.getElementById('cull-finish-btn').addEventListener('click', () => {
            // Trigger the same action as 'f' key
            finalizeCull();
          });
          document.getElementById('cull-cancel-btn').addEventListener('click', () => {
            // Trigger the same action as 'q' key in cull mode
            exitCullMode();
          });
          
          // Add touch event handlers to thumbnails
          addTouchThumbnailHandlers();
          
          // Add swipe handlers to single view
          addSwipeHandlers();
        }
      }

      function addTouchThumbnailHandlers() {
        thumbgrid.addEventListener('touchstart', handleTouchStart, { passive: true });
        thumbgrid.addEventListener('touchend', handleTouchEnd, { passive: true });
        thumbgrid.addEventListener('touchmove', handleTouchMove, { passive: true });
      }

      function handleTouchStart(e) {
        const cell = e.target.closest('.thumb-cell');
        if (!cell) return;
        
        // Prevent any other event handlers
        e.stopPropagation();
        
        const idx = +cell.dataset.idx;
        touchStartTime = Date.now();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        cell.classList.add('touch-selected');
        
        // Set up long press detection
        touchTimeout = setTimeout(() => {
          handleLongPress(idx, cell);
        }, touchHoldThreshold);
      }

      function handleTouchMove(e) {
        // Cancel long press if user moves finger significantly
        if (touchTimeout && e.touches.length > 0) {
          const deltaX = Math.abs(e.touches[0].clientX - touchStartX);
          const deltaY = Math.abs(e.touches[0].clientY - touchStartY);
          
          if (deltaX > touchMoveThreshold || deltaY > touchMoveThreshold) {
            clearTimeout(touchTimeout);
            touchTimeout = null;
            
            // Remove visual feedback since this is now a scroll
            const cell = e.target.closest('.thumb-cell');
            if (cell) {
              cell.classList.remove('touch-selected');
            }
          }
        }
      }

      function handleTouchEnd(e) {
        const cell = e.target.closest('.thumb-cell');
        if (!cell) return;
        
        // Prevent any other event handlers
        e.stopPropagation();
        
        const idx = +cell.dataset.idx;
        const touchDuration = Date.now() - touchStartTime;
        
        // Calculate movement to detect if this was a scroll
        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        const deltaX = Math.abs(endX - touchStartX);
        const deltaY = Math.abs(endY - touchStartY);
        const hasMoved = deltaX > touchMoveThreshold || deltaY > touchMoveThreshold;
        
        cell.classList.remove('touch-selected');
        
        if (touchTimeout) {
          clearTimeout(touchTimeout);
          touchTimeout = null;
        }
        
        // Only handle tap if user didn't move finger significantly (not a scroll)
        if (!hasMoved && touchDuration < touchHoldThreshold) {
          // Short tap without movement
          if (touchMode === 'selection') {
            // In selection mode, toggle selection
            if (selectedThumbnails.has(idx)) {
              selectedThumbnails.delete(idx);
              // Exit selection mode if no items selected
              if (selectedThumbnails.size === 0) {
                touchMode = 'normal';
              }
            } else {
              selectedThumbnails.add(idx);
            }
            updateSelectionDisplay();
            updateTouchToolbar();
          } else {
            // Normal tap - show full size
            selectedThumbnails.clear();
            selectedThumbnails.add(idx);
            current = idx;
            showSingle('fit');
            updateSelectionDisplay();
          }
        }
        // If hasMoved is true, we ignore the tap and let scrolling work normally
      }

      function handleLongPress(idx, cell) {
        // Long press - enter selection mode
        touchMode = 'selection';
        selectedThumbnails.clear();
        selectedThumbnails.add(idx);
        updateSelectionDisplay();
        updateTouchToolbar();
        
        // Visual feedback
        cell.style.transform = 'scale(0.95)';
        setTimeout(() => {
          cell.style.transform = '';
        }, 200);
      }

      function updateTouchToolbar() {
        if (isTouchDevice) {
          const cullBtn = document.getElementById('touch-cull-btn');
          const clearBtn = document.getElementById('touch-clear-btn');
          const prevBtn = document.getElementById('touch-prev-btn');
          const nextBtn = document.getElementById('touch-next-btn');
          const finishBtn = document.getElementById('touch-finish-btn');
          const isInSingleView = singleview.classList.contains('visible');
          
          if (cullMode) {
            // In cull mode - show finish and clear buttons
            clearBtn.textContent = 'Clear';
            clearBtn.style.display = 'flex';
            cullBtn.style.display = 'none';
            finishBtn.style.display = 'flex';
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          } else if (isInSingleView) {
            // In single view mode - show back and navigation buttons
            clearBtn.textContent = 'Back';
            clearBtn.style.display = 'flex';
            cullBtn.style.display = 'none';
            finishBtn.style.display = 'none';
            // prevBtn.style.display = 'flex';  // Hidden - swiping is sufficient
            // nextBtn.style.display = 'flex';  // Hidden - swiping is sufficient
          } else if (selectedThumbnails.size > 1) {
            // Multiple items selected in thumbnail view
            clearBtn.textContent = 'Clear';
            cullBtn.textContent = 'Cull';
            cullBtn.style.display = 'flex';
            clearBtn.style.display = 'flex';
            finishBtn.style.display = 'none';
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          } else if (selectedThumbnails.size === 1 && touchMode === 'selection') {
            // Single item selected in selection mode
            clearBtn.textContent = 'Clear';
            cullBtn.style.display = 'none';
            clearBtn.style.display = 'flex';
            finishBtn.style.display = 'none';
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          } else {
            // Normal thumbnail view, no selection
            cullBtn.textContent = 'Cull';
            cullBtn.style.display = 'none';
            clearBtn.style.display = 'none';
            finishBtn.style.display = 'none';
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          }
        }
      }




      function addSwipeHandlers() {
        let startX = 0;
        let startY = 0;
        let endX = 0;
        let endY = 0;
        
        singleview.addEventListener('touchstart', (e) => {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        }, { passive: true });
        
        singleview.addEventListener('touchend', (e) => {
          endX = e.changedTouches[0].clientX;
          endY = e.changedTouches[0].clientY;
          
          const deltaX = endX - startX;
          const deltaY = endY - startY;
          const absDeltaX = Math.abs(deltaX);
          const absDeltaY = Math.abs(deltaY);
          
          // Require minimum swipe distance and ensure horizontal swipe
          if (absDeltaX > 50 && absDeltaX > absDeltaY * 2) {
            if (deltaX > 0) {
              // Swipe right - previous image
              handleArrow(-1, false);
            } else {
              // Swipe left - next image
              handleArrow(1, false);
            }
          }
        }, { passive: true });
      }

      // Command Palette Functions
      function openCommandPalette() {
        commandPaletteOpen = true;
        commandPaletteSelectedIndex = -1;
        commandPaletteItems = [];
        commandPaletteMode = null;
        commandPaletteSearchString = '';
        
        commandPalette.classList.add('visible');
        commandInput.value = '';
        commandInput.placeholder = 'Type a command...';
        commandInput.focus();
        
        // Show initial commands
        updateCommandPalette('');
      }
      
      function closeCommandPalette() {
        commandPaletteOpen = false;
        commandPaletteSelectedIndex = -1;
        commandPaletteItems = [];
        commandPaletteMode = null;
        commandPaletteSearchString = '';
        
        commandPalette.classList.remove('visible');
        commandInput.blur();
      }
      
      function navigateCommandPalette(direction) {
        if (commandPaletteItems.length === 0) return;
        
        let newIndex = commandPaletteSelectedIndex;
        const maxAttempts = commandPaletteItems.length;
        let attempts = 0;
        
        do {
          newIndex += direction;
          
          if (newIndex < 0) {
            newIndex = commandPaletteItems.length - 1;
          } else if (newIndex >= commandPaletteItems.length) {
            newIndex = 0;
          }
          
          attempts++;
        } while (commandPaletteItems[newIndex]?.placeholder && attempts < maxAttempts);
        
        commandPaletteSelectedIndex = newIndex;
        
        // Update visual selection
        const items = commandResults.querySelectorAll('.command-item:not(.command-mode-badge)');
        items.forEach((item, index) => {
          if (index === commandPaletteSelectedIndex) {
            item.classList.add('selected');
          } else {
            item.classList.remove('selected');
          }
        });
      }
      
      function executeSelectedCommand() {
        if (commandPaletteSelectedIndex >= 0 && commandPaletteItems[commandPaletteSelectedIndex]) {
          const command = commandPaletteItems[commandPaletteSelectedIndex];
          
          // Don't execute placeholder commands
          if (command.placeholder) {
            return;
          }
          
          if (command.id === 'gallery' && commandPaletteMode !== 'gallery') {
            // Enter gallery mode
            commandPaletteMode = 'gallery';
            commandInput.value = '';
            commandInput.placeholder = 'Enter search criteria (e.g., "Ben 27mm fuji", "2023 Canon")...';
            updateCommandPalette('');
          } else if (command.action) {
            // Execute the command
            command.action();
          }
        }
      }
      
      function updateCommandPalette(query) {
        if (commandPaletteMode === 'gallery') {
          // In gallery mode - show gallery creation options
          commandPaletteSearchString = query;
          const galleryCommands = getGalleryCommands(query);
          commandPaletteItems = galleryCommands;
          commandPaletteSelectedIndex = galleryCommands.length > 0 ? 0 : -1;
          renderCommandPalette(galleryCommands, query);
        } else {
          // Normal command mode
          const commands = getAvailableCommands();
          const filteredCommands = filterCommands(commands, query);
          commandPaletteItems = filteredCommands;
          commandPaletteSelectedIndex = filteredCommands.length > 0 ? 0 : -1;
          renderCommandPalette(filteredCommands, query);
        }
      }
      
      function getAvailableCommands() {
        return [
          {
            id: 'gallery',
            title: 'Create Gallery',
            subtitle: 'Create a new gallery from search criteria',
            icon: 'üñºÔ∏è',
            keywords: ['gallery', 'create', 'new', 'search'],
            category: 'gallery'
          },
          {
            id: 'regenerate-raw-picks',
            title: 'Regenerate RAW Picks',
            subtitle: 'Process picked RAW files with custom RawTherapee settings',
            icon: 'üéûÔ∏è',
            keywords: ['raw', 'picks', 'regenerate', 'process', 'rawtherapee'],
            category: 'processing',
            action: () => {
              closeCommandPalette();
              executeRegenerateRawPicks();
            }
          },
          {
            id: 'delete-rejects',
            title: 'Delete Rejected Images',
            subtitle: 'Permanently delete all rejected images and cleanup files',
            icon: 'üóëÔ∏è',
            keywords: ['delete', 'rejects', 'cull', 'remove', 'cleanup'],
            category: 'management',
            action: () => {
              closeCommandPalette();
              executeDeleteRejects();
            }
          },
          {
            id: 'stats-dashboard',
            title: 'Stats Dashboard',
            subtitle: 'View comprehensive database statistics and analytics',
            icon: 'üìä',
            keywords: ['stats', 'statistics', 'dashboard', 'analytics', 'data', 'charts'],
            category: 'analytics',
            action: () => {
              closeCommandPalette();
              showStatsDashboard();
            }
          },
          {
            id: 'rebuild-current-gallery',
            title: 'Rebuild Current Gallery JSON',
            subtitle: 'Regenerate image_data.json for the currently loaded gallery',
            icon: 'üî®',
            keywords: ['rebuild', 'gallery', 'json', 'refresh', 'regenerate', 'current'],
            category: 'maintenance',
            action: () => {
              closeCommandPalette();
              executeRebuildCurrentGallery();
            }
          },
          {
            id: 'rebuild-galleries-list',
            title: 'Rebuild Galleries List',
            subtitle: 'Regenerate the main galleries.json list from all gallery folders',
            icon: 'üìã',
            keywords: ['rebuild', 'galleries', 'list', 'refresh', 'scan', 'main'],
            category: 'maintenance',
            action: () => {
              closeCommandPalette();
              executeRebuildGalleriesList();
            }
          },
          {
            id: 'rename-current-gallery',
            title: 'Rename Current Gallery',
            subtitle: 'Rename the currently loaded gallery folder',
            icon: 'üìù',
            keywords: ['rename', 'gallery', 'name', 'change', 'current'],
            category: 'maintenance',
            action: () => {
              closeCommandPalette();
              executeRenameCurrentGallery();
            }
          },
          {
            id: 'delete-current-gallery',
            title: 'Delete Current Gallery',
            subtitle: '‚ö†Ô∏è Permanently delete the currently loaded gallery folder and all its hard links',
            icon: 'üóëÔ∏è',
            keywords: ['delete', 'gallery', 'remove', 'destroy', 'current'],
            category: 'maintenance',
            action: () => {
              closeCommandPalette();
              executeDeleteCurrentGallery();
            }
          },
          {
            id: 'process-new-images',
            title: 'Process New Images',
            subtitle: 'Extract metadata, detect faces, cluster faces, and generate thumbnails for new images',
            icon: 'üöÄ',
            keywords: ['process', 'new', 'images', 'metadata', 'faces', 'cluster', 'thumbnails'],
            category: 'processing',
            action: () => {
              closeCommandPalette();
              executeProcessNewImages();
            }
          }
        ];
      }
      
      async function executeRegenerateRawPicks() {
        if (picks.size === 0) {
          alert('No picks selected. Mark some RAW images as picks first.');
          return;
        }
        
        const confirmed = confirm(`Regenerate ${picks.size} picked RAW files with custom RawTherapee processing?\n\nThis will:\n‚Ä¢ Process RAW files with enhanced settings\n‚Ä¢ Update existing proxies\n‚Ä¢ Regenerate thumbnails\n\nThis may take several minutes.`);
        
        if (!confirmed) return;
        
        try {
          // Call the regenerate RAW picks script via photo manager
          const response = await fetch('/api/regenerate-raw-picks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (response.ok) {
            alert('‚úÖ RAW picks regeneration started! Check console for progress.');
          } else {
            alert('‚ùå Failed to start RAW picks regeneration. Make sure the server is running.');
          }
        } catch (error) {
          console.error('Error executing regenerate RAW picks:', error);
          alert('‚ùå Error starting RAW picks regeneration. Try running manually via photo_manager.py');
        }
      }
      
      let deleteInProgress = false;
      
      async function executeDeleteRejects() {
        if (deleteInProgress) {
          console.log('Delete already in progress, ignoring duplicate call');
          return;
        }
        
        if (rejects.size === 0) {
          alert('No images rejected. Mark some images as rejects first.');
          return;
        }
        
        deleteInProgress = true;
        
        try {
          // First, get a preview of what will be deleted
          const previewResponse = await fetch(`http://${window.location.hostname}:8001/api/delete-rejects-preview`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (!previewResponse.ok) {
            alert('‚ùå Failed to get deletion preview. Make sure the server is running.');
            deleteInProgress = false;
            return;
          }
          
          const previewData = await previewResponse.json();
          const preview = previewData.preview;
          
          // Show preview to user
          let previewMessage = `üóëÔ∏è DELETE PREVIEW\n\n`;
          previewMessage += `Total images to delete: ${preview.total_images}\n`;
          previewMessage += `Files found in database: ${preview.files_found}\n\n`;
          
          let totalFilesToDelete = 0;
          preview.files.forEach(file => {
            previewMessage += `üì∏ ${file.filename} (ID: ${file.id})\n`;
            file.files_to_delete.forEach(fileInfo => {
              const status = fileInfo.exists ? '‚úì' : '‚ùå';
              previewMessage += `   ${status} ${fileInfo.type}: ${fileInfo.path}\n`;
              if (fileInfo.exists) totalFilesToDelete++;
            });
            previewMessage += `\n`;
          });
          
          previewMessage += `\n‚ö†Ô∏è This will permanently delete ${totalFilesToDelete} files!\n`;
          previewMessage += `üö® THIS ACTION CANNOT BE UNDONE! üö®\n\n`;
          previewMessage += `Type 'DELETE' to confirm:`;
          
          // Show confirmation dialog with preview
          const confirmation = prompt(previewMessage);
          if (confirmation !== 'DELETE') {
            alert('Deletion cancelled - confirmation text did not match.');
            deleteInProgress = false;
            return;
          }
          
          // Proceed with actual deletion
          const deleteResponse = await fetch(`http://${window.location.hostname}:8001/api/delete-rejects`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (deleteResponse.ok) {
            const deleteResult = await deleteResponse.json();
            alert(`‚úÖ ${deleteResult.message}\n\nThe page will now refresh to update the gallery.`);
            // Clear rejects from UI since they're being deleted
            rejects.clear();
            updatePickClasses();
            // Refresh the page to reload with updated galleries
            window.location.reload();
          } else {
            const errorData = await deleteResponse.json().catch(() => ({ error: 'Unknown error' }));
            alert(`‚ùå Deletion failed: ${errorData.error || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error executing delete rejects:', error);
          alert('‚ùå Error with deletion process. Check console for details.');
        } finally {
          deleteInProgress = false;
        }
      }
      
      async function showStatsDashboard() {
        try {
          // Fetch stats from API
          const response = await fetch(`http://${window.location.hostname}:8001/api/stats`);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const stats = await response.json();
          
          // Create stats dashboard UI
          const dashboard = document.createElement('div');
          dashboard.id = 'stats-dashboard';
          dashboard.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            color: #fff;
            font-family: system-ui, sans-serif;
          `;
          
          dashboard.innerHTML = `
            <div style="max-width: 1200px; margin: 0 auto;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <h1 style="margin: 0; color: #fff; font-size: 32px; font-weight: 300;">üìä Database Statistics</h1>
                <button onclick="document.getElementById('stats-dashboard').remove()" 
                        style="background: #ff4444; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 16px;">Close</button>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                ${createStatsSection('Overview', stats.overview)}
                ${createStatsSection('By Camera', stats.cameras)}
                ${createStatsSection('By Lens', stats.lenses)}
                ${createStatsSection('By Focal Length (35mm)', stats.focal_lengths)}
                ${createStatsSection('By Year', stats.years)}
                ${createStatsSection('By Face', stats.faces)}
                ${createStatsSection('File Types', stats.file_types)}
                ${createStatsSection('Pick/Reject Status', stats.status)}
              </div>
            </div>
          `;
          
          document.body.appendChild(dashboard);
          
          // Close on Escape key
          const closeHandler = (e) => {
            if (e.key === 'Escape') {
              dashboard.remove();
              document.removeEventListener('keydown', closeHandler);
            }
          };
          document.addEventListener('keydown', closeHandler);
          
        } catch (error) {
          console.error('Error loading stats:', error);
          alert(`Error loading stats: ${error.message}`);
        }
      }
      
      function createStatsSection(title, data) {
        if (!data || (Array.isArray(data) && data.length === 0)) {
          return `
            <div style="background: #2a2a2a; border-radius: 8px; padding: 20px; border: 1px solid #444; display: flex; flex-direction: column; height: 400px;">
              <h3 style="margin: 0 0 15px 0; color: #ccc; font-size: 18px;">${title}</h3>
              <p style="color: #999; margin: 0;">No data available</p>
            </div>
          `;
        }

        let content = `
          <div style="background: #2a2a2a; border-radius: 8px; padding: 20px; border: 1px solid #444; display: flex; flex-direction: column; height: 400px;">
            <h3 style="margin: 0 0 15px 0; color: #ccc; font-size: 18px; flex-shrink: 0;">${title}</h3>
            <div style="flex: 1; overflow-y: auto; overflow-x: hidden; padding-right: 10px;">
        `;

        if (typeof data === 'object' && !Array.isArray(data)) {
          // Simple key-value pairs
          for (const [key, value] of Object.entries(data)) {
            content += `
              <div style="display: flex; justify-content: space-between; margin-bottom: 8px; padding: 4px 0;">
                <span style="color: #ddd;">${key}</span>
                <span style="color: #4CAF50; font-weight: 600; margin-left: 10px; white-space: nowrap;">${value.toLocaleString()}</span>
              </div>
            `;
          }
        } else if (Array.isArray(data)) {
          // Array of objects with counts - show ALL items
          data.forEach(item => {
            const name = item.name || item.camera || item.lens || item.focal_length || item.year || item.person || item.type || item.status || 'Unknown';
            content += `
              <div style="display: flex; justify-content: space-between; margin-bottom: 8px; padding: 4px 0;">
                <span style="color: #ddd; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 10px;" title="${name}">${name}</span>
                <span style="color: #4CAF50; font-weight: 600; white-space: nowrap;">${item.count.toLocaleString()}</span>
              </div>
            `;
          });
        }

        content += '</div></div>';
        return content;
      }
      
      async function executeRebuildCurrentGallery() {
        if (!currentGallery) {
          alert('No gallery currently loaded. Please load a gallery first.');
          return;
        }
        
        // Extract gallery path from currentGallery JSON path
        const galleryPath = currentGallery.replace('/image_data.json', '');
        const galleryName = galleryPath.split('/').pop();
        
        const confirmed = confirm(`Rebuild gallery JSON for "${galleryName}"?\n\nThis will:\n‚Ä¢ Regenerate image_data.json from database\n‚Ä¢ Update metadata and thumbnails\n‚Ä¢ Refresh the current gallery view\n\nThis may take a few moments.`);
        
        if (!confirmed) return;
        
        try {
          showCommandLoading('Rebuilding gallery JSON...');
          
          const response = await fetch(`http://${window.location.hostname}:8001/api/rebuild-gallery-json`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ gallery_path: galleryPath })
          });
          
          if (response.ok) {
            const result = await response.json();
            alert(`‚úÖ Gallery JSON rebuilt successfully!\n\n${result.message}`);
            
            // Reload the current gallery to show updated data
            location.reload();
          } else {
            const errorText = await response.text();
            alert(`‚ùå Failed to rebuild gallery JSON: ${errorText}`);
          }
        } catch (error) {
          console.error('Error rebuilding gallery JSON:', error);
          alert('‚ùå Error rebuilding gallery JSON. Check console for details.');
        }
      }
      
      async function executeRebuildGalleriesList() {
        const confirmed = confirm('Rebuild the main galleries list?\n\nThis will:\n‚Ä¢ Scan all gallery folders\n‚Ä¢ Regenerate galleries.json\n‚Ä¢ Update the gallery selector\n\nThis may take a few moments.');
        
        if (!confirmed) return;
        
        try {
          showCommandLoading('Rebuilding galleries list...');
          
          const response = await fetch(`http://${window.location.hostname}:8001/api/rebuild-galleries-list`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (response.ok) {
            const result = await response.json();
            alert(`‚úÖ Galleries list rebuilt successfully!\n\n${result.message}`);
            
            // Reload the page to refresh the gallery selector
            location.reload();
          } else {
            const errorText = await response.text();
            alert(`‚ùå Failed to rebuild galleries list: ${errorText}`);
          }
        } catch (error) {
          console.error('Error rebuilding galleries list:', error);
          alert('‚ùå Error rebuilding galleries list. Check console for details.');
        }
      }
      
      async function executeRenameCurrentGallery() {
        if (!currentGallery) {
          alert('No gallery currently loaded. Please load a gallery first.');
          return;
        }

        const galleryPath = currentGallery.replace('/image_data.json', '');
        const currentName = galleryPath.split('/').pop();

        // Prompt for new name
        const newName = prompt(`Rename gallery "${currentName}"\n\nEnter new name:`, currentName);

        if (!newName) {
          return; // User cancelled
        }

        if (newName === currentName) {
          alert('New name is the same as current name. No changes made.');
          return;
        }

        // Validate new name
        if (newName.includes('/') || newName.includes('\\') || newName.includes('..')) {
          alert('‚ùå Invalid name: Cannot contain path separators (/ or \\) or ".."');
          return;
        }

        if (newName.length > 100) {
          alert('‚ùå Name too long: Maximum 100 characters allowed');
          return;
        }

        try {
          showCommandLoading('Renaming gallery...');

          const response = await fetch(`http://${window.location.hostname}:8002/api/rename-gallery`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              old_path: galleryPath,
              new_name: newName
            })
          });

          if (response.ok) {
            const result = await response.json();
            alert(`‚úÖ Gallery renamed successfully!\n\n${result.message}`);

            // Refresh galleries list and redirect to home
            await loadGalleries(true);  // Force reload after rename
            showGallerySelectionMessage();

          } else {
            const errorData = await response.text();
            alert(`‚ùå Failed to rename gallery:\n\n${errorData}`);
          }
        } catch (error) {
          console.error('Error in gallery rename process:', error);
          alert(`‚ùå Error renaming gallery: ${error.message}`);
        }

        hideCommandLoading();
      }

      async function executeDeleteCurrentGallery() {
        if (!currentGallery) {
          alert('No gallery currently loaded. Please load a gallery first.');
          return;
        }
        
        const galleryPath = currentGallery.replace('/image_data.json', '');
        const galleryName = galleryPath.split('/').pop();
        
        // First confirmation
        const firstConfirmed = confirm(`‚ö†Ô∏è DELETE GALLERY: "${galleryName}"?\n\nüö® WARNING: This action CANNOT be undone!\n\nThis will permanently delete:\n‚Ä¢ The entire gallery folder\n‚Ä¢ All hard-linked image files in the gallery\n‚Ä¢ Gallery metadata and configuration\n\n‚ùå Original photos in "Master Photo Library" will NOT be affected\n\nAre you sure you want to continue?`);
        
        if (!firstConfirmed) return;
        
        // Second confirmation with typing requirement
        const typedConfirmation = prompt(`‚ö†Ô∏è FINAL CONFIRMATION\n\nTo permanently delete the gallery "${galleryName}", type: DELETE\n\n(Type exactly: DELETE)`);
        
        if (typedConfirmation !== 'DELETE') {
          if (typedConfirmation !== null) {
            alert('‚ùå Deletion cancelled. You must type exactly "DELETE" to confirm.');
          }
          return;
        }
        
        try {
          showCommandLoading('Deleting gallery... This cannot be undone.');
          
          // Call the new gallery deletion API
          const response = await fetch(`http://${window.location.hostname}:8002/api/delete-gallery`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ gallery_path: galleryPath })
          });
          
          if (response.ok) {
            const result = await response.json();
            alert(`‚úÖ Gallery deleted successfully!\n\n${result.message}`);
            
            // Refresh galleries list and redirect to home
            await loadGalleries(true);  // Force reload after deletion
            showGallerySelectionMessage();
            
          } else {
            const errorData = await response.text();
            alert(`‚ùå Failed to delete gallery:\n\n${errorData}\n\nYou may need to delete manually:\nrm -rf "${galleryPath}"`);
          }
        } catch (error) {
          console.error('Error in gallery deletion process:', error);
          alert(`‚ùå Please manually delete the folder:\n\nrm -rf "${galleryPath}"\n\nThen refresh the page.`);
        }
      }
      
      async function executeProcessNewImages() {
        const confirmed = confirm('Process new images?\n\nThis will:\n‚Ä¢ Extract metadata from new images\n‚Ä¢ Detect faces in new images\n‚Ä¢ Cluster new faces with existing ones\n‚Ä¢ Generate thumbnails for new images\n\nThis may take several minutes depending on the number of new images.\n\nProgress will be shown in the Status Feed at the bottom of the sidebar.');
        
        if (!confirmed) return;
        
        try {
          showCommandLoading('Processing new images...');
          
          const result = await trackOperationWithLogPolling(
            'Process New Images', 
            `http://${window.location.hostname}:8001/api/process-new-images`,
            { directory: 'Master Photo Library' }
          );
          
          alert(`‚úÖ New images processing started!\n\n${result.message}\n\nProgress will continue to show in the Status Feed below.`);
        } catch (error) {
          console.error('Error processing new images:', error);
        }
      }
      
      function getGalleryCommands(searchString) {
        const commands = [];
        
        if (searchString.trim()) {
          // Show the main create gallery command with the search string
          commands.push({
            id: 'create-gallery',
            title: 'Create Gallery',
            subtitle: `Search: "${searchString}"`,
            icon: 'üñºÔ∏è',
            searchString: searchString,
            action: () => {
              createGalleryFromCommand(searchString);
            }
          });
        } else {
          // Show placeholder when no search string
          commands.push({
            id: 'gallery-placeholder',
            title: 'Create Gallery',
            subtitle: 'Start typing search criteria...',
            icon: 'üñºÔ∏è',
            placeholder: true
          });
        }
        
        // Add special options
        commands.push({
          id: 'gallery-face-samples',
          title: 'Face Sample Gallery',
          subtitle: 'Create gallery with one image per person',
          icon: 'üë•',
          action: () => {
            createFaceSampleGallery();
          }
        });
        
        commands.push({
          id: 'gallery-picks',
          title: 'Picks Gallery',
          subtitle: 'Create gallery from saved picks',
          icon: 'üìã',
          action: () => {
            createPicksGallery(searchString);
          }
        });
        
        return commands;
      }
      
      function filterCommands(commands, query) {
        if (!query) return commands;
        
        const lowerQuery = query.toLowerCase();
        return commands.filter(command => {
          // Check if query starts with command keywords
          const matchesKeyword = command.keywords.some(keyword => 
            keyword.toLowerCase().startsWith(lowerQuery) || 
            lowerQuery.startsWith(keyword.toLowerCase())
          );
          
          // For gallery command, if query starts with "gallery", show it
          if (command.id === 'gallery' && lowerQuery.startsWith('gallery')) {
            return true;
          }
          
          return matchesKeyword || 
                 command.title.toLowerCase().includes(lowerQuery) ||
                 command.subtitle.toLowerCase().includes(lowerQuery);
        });
      }
      
      function renderCommandPalette(commands, query) {
        commandResults.innerHTML = '';
        
        // Add mode badge if in gallery mode
        if (commandPaletteMode === 'gallery') {
          const badge = document.createElement('div');
          badge.className = 'command-mode-badge';
          badge.innerHTML = `
            <div class="command-badge-content">
              <span class="command-badge-icon">üñºÔ∏è</span>
              <span class="command-badge-text">Gallery</span>
            </div>
          `;
          commandResults.appendChild(badge);
        }
        
        if (commands.length === 0) {
          const noResults = document.createElement('div');
          noResults.className = 'command-item';
          noResults.innerHTML = `
            <div class="command-item-left">
              <div class="command-icon">‚ùì</div>
              <div class="command-details">
                <div class="command-title">No commands found</div>
                <div class="command-subtitle">${commandPaletteMode ? 'Try a different search' : 'Try typing "gallery" to create a new gallery'}</div>
              </div>
            </div>
          `;
          commandResults.appendChild(noResults);
          return;
        }
        
        commands.forEach((command, index) => {
          const item = document.createElement('div');
          const isPlaceholder = command.placeholder;
          const isSelected = index === commandPaletteSelectedIndex;
          
          item.className = `command-item ${isSelected ? 'selected' : ''} ${isPlaceholder ? 'disabled' : ''}`;
          
          item.innerHTML = `
            <div class="command-item-left">
              <div class="command-icon">${command.icon}</div>
              <div class="command-details">
                <div class="command-title">${command.title}</div>
                <div class="command-subtitle">${command.subtitle}</div>
              </div>
            </div>
            ${!isPlaceholder ? '<div class="command-shortcut">‚èé</div>' : ''}
          `;
          
          if (!isPlaceholder) {
            item.addEventListener('click', () => {
              commandPaletteSelectedIndex = index;
              executeSelectedCommand();
            });
          }
          
          commandResults.appendChild(item);
        });
      }
      
      async function createGalleryFromCommand(searchString) {
        // Generate gallery name from search string
        const galleryName = generateGalleryName(searchString);
        
        showCommandLoading('Creating gallery...');
        
        try {
          const result = await trackOperation(
            `Create Gallery: ${galleryName}`, 
            `${API_BASE_URL}/api/create-gallery`,
            { search_string: searchString, gallery_name: galleryName }
          );
          
          closeCommandPalette();
          
          // Refresh galleries list
          await loadGalleries(true);  // Force reload after creation
          // Refresh gallery selector UI
          renderGalleries();
          alert(`Gallery "${result.gallery_name}" created successfully!`);
        } catch (error) {
          console.error('Error creating gallery:', error);
          closeCommandPalette();
        }
      }
      
      async function createFaceSampleGallery() {
        const galleryName = 'Face Samples';
        
        showCommandLoading('Creating face sample gallery...');
        
        try {
          const response = await fetch(`${API_BASE_URL}/api/create-gallery`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              face_samples: true,
              gallery_name: galleryName
            })
          });
          
          const result = await response.json();
          
          closeCommandPalette();
          
          if (response.ok && result.success) {
            await loadGalleries(true);  // Force reload after creation
            renderGalleries();
            alert(`Gallery "${result.gallery_name}" created successfully!`);
          } else {
            alert(`Failed to create gallery: ${result.message || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error creating gallery:', error);
          closeCommandPalette();
          alert(`Error creating gallery: ${error.message}`);
        }
      }
      
      async function createPicksGallery(searchString = '') {
        const galleryName = searchString.trim() ? generateGalleryName(searchString) : 'Picks Gallery';
        
        showCommandLoading('Creating picks gallery...');
        
        try {
          const response = await fetch(`${API_BASE_URL}/api/create-gallery`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              picks_file: 'JSON/picks.json', // Use default picks file
              gallery_name: galleryName
            })
          });
          
          const result = await response.json();
          
          closeCommandPalette();
          
          if (response.ok && result.success) {
            await loadGalleries(true);  // Force reload after creation
            alert(`Gallery "${result.gallery_name}" created successfully!`);
          } else {
            alert(`Failed to create gallery: ${result.message || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error creating gallery:', error);
          closeCommandPalette();
          alert(`Error creating gallery: ${error.message}`);
        }
      }
      
      function generateGalleryName(searchString) {
        // Generate a reasonable gallery name from search string
        const cleaned = searchString.replace(/[^a-zA-Z0-9\s-]/g, '').trim();
        if (!cleaned) return 'New Gallery';
        return cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
      }
      
      function showCommandLoading(message) {
        commandResults.innerHTML = `
          <div class="command-loading">
            <div class="spinner"></div>
            ${message}
          </div>
        `;
      }
      
      // Status Feed Management
      let statusFeedPollInterval = null;
      let statusFeedLogOffset = 0;
      
      function showStatusFeed() {
        const statusFeed = document.getElementById('status-feed');
        if (statusFeed) {
          statusFeed.classList.remove('hidden');
          startStatusFeedPolling();
          localStorage.setItem('statusFeedVisible', 'true');
        }
      }
      
      function hideStatusFeed() {
        const statusFeed = document.getElementById('status-feed');
        if (statusFeed) {
          statusFeed.classList.add('hidden');
          stopStatusFeedPolling();
          localStorage.setItem('statusFeedVisible', 'false');
        }
      }
      
      function toggleStatusFeed() {
        const statusFeed = document.getElementById('status-feed');
        if (statusFeed) {
          if (statusFeed.classList.contains('hidden')) {
            showStatusFeed();
          } else {
            hideStatusFeed();
          }
        }
      }
      
      function startStatusFeedPolling() {
        if (statusFeedPollInterval) {
          clearInterval(statusFeedPollInterval);
        }
        
        // Start polling for progress updates
        const pollProgress = async () => {
          try {
            const response = await fetch(`http://${window.location.hostname}:8001/api/progress-log?offset=${statusFeedLogOffset}`);
            if (response.ok) {
              const data = await response.json();
              if (data.entries && data.entries.length > 0) {
                // Add new log entries to status feed
                data.entries.forEach(entry => {
                  addStatusMessage(entry.message, entry.type, entry.timestamp);
                });
                statusFeedLogOffset = data.total_lines;
              }
            }
          } catch (e) {
            console.log('Error polling progress log:', e);
          }
        };
        
        // If this is the first time opening the feed and it's empty, start from beginning
        const statusContent = document.getElementById('status-feed-content');
        if (statusContent && statusContent.children.length === 0) {
          statusFeedLogOffset = 0;
        }
        
        // Poll immediately to get any existing entries
        pollProgress();
        
        // Start polling every 2 seconds
        statusFeedPollInterval = setInterval(pollProgress, 2000);
      }
      
      function stopStatusFeedPolling() {
        if (statusFeedPollInterval) {
          clearInterval(statusFeedPollInterval);
          statusFeedPollInterval = null;
        }
      }
      
      function addStatusMessage(message, type = 'info', customTimestamp = null) {
        const statusContent = document.getElementById('status-feed-content');
        if (!statusContent) return;
        
        const timestamp = customTimestamp || new Date().toLocaleTimeString('en-US', { 
          hour12: false, 
          timeZone: 'UTC' 
        }).substring(0, 5);
        
        const entry = document.createElement('div');
        entry.className = `status-entry ${type}`;
        entry.innerHTML = `
          <span class="status-timestamp">${timestamp}</span>
          <span class="status-message">${message}</span>
        `;
        
        statusContent.appendChild(entry);
        statusContent.scrollTop = statusContent.scrollHeight;
      }
      
      function clearStatusFeed() {
        const statusContent = document.getElementById('status-feed-content');
        if (statusContent) {
          statusContent.innerHTML = '';
        }
        hideStatusFeed();
      }
      
      // Enhanced progress tracking for long operations
      function trackOperation(operationName, endpoint, data = {}) {
        addStatusMessage(`üöÄ Starting ${operationName}...`, 'info');
        
        // For now, use traditional fetch
        // TODO: Replace with Server-Sent Events for real-time updates
        return fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        }).then(response => {
          if (response.ok) {
            return response.json().then(result => {
              addStatusMessage(`‚úÖ ${operationName} completed successfully`, 'success');
              if (result.message) {
                addStatusMessage(result.message, 'info');
              }
              return result;
            });
          } else {
            return response.json().then(error => {
              addStatusMessage(`‚ùå ${operationName} failed: ${error.error || 'Unknown error'}`, 'error');
              throw new Error(error.error || 'Operation failed');
            });
          }
        }).catch(error => {
          addStatusMessage(`‚ùå ${operationName} failed: ${error.message}`, 'error');
          throw error;
        });
      }
      
      // Enhanced progress tracking with log file polling
      function trackOperationWithLogPolling(operationName, endpoint, data = {}) {
        return new Promise((resolve, reject) => {
          addStatusMessage(`üöÄ Starting ${operationName}...`, 'info');
          
          let logOffset = 0;
          let pollInterval;
          
          // Start polling for progress updates
          const pollProgress = async () => {
            try {
              const response = await fetch(`http://${window.location.hostname}:8001/api/progress-log?offset=${logOffset}`);
              if (response.ok) {
                const data = await response.json();
                if (data.entries && data.entries.length > 0) {
                  // Add new log entries to status feed
                  data.entries.forEach(entry => {
                    addStatusMessage(entry.message, entry.type, entry.timestamp);
                  });
                  logOffset = data.total_lines;
                }
              }
            } catch (e) {
              console.log('Error polling progress log:', e);
            }
          };
          
          // Start polling every 2 seconds
          pollInterval = setInterval(pollProgress, 2000);
          
          // Start the actual operation
          fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          }).then(response => {
            if (response.ok) {
              return response.json().then(result => {
                // Continue polling for a bit after the API returns
                setTimeout(() => {
                  clearInterval(pollInterval);
                  addStatusMessage(`‚úÖ ${operationName} completed`, 'success');
                }, 5000); // Poll for 5 more seconds
                
                resolve(result);
              });
            } else {
              clearInterval(pollInterval);
              return response.json().then(error => {
                addStatusMessage(`‚ùå ${operationName} failed: ${error.error || 'Unknown error'}`, 'error');
                reject(new Error(error.error || 'Operation failed'));
              });
            }
          }).catch(error => {
            clearInterval(pollInterval);
            addStatusMessage(`‚ùå ${operationName} failed: ${error.message}`, 'error');
            reject(error);
          });
        });
      }
      
      // Command input event listener
      commandInput.addEventListener('input', (e) => {
        updateCommandPalette(e.target.value);
      });
      
      // Command input keydown handler for special keys
      commandInput.addEventListener('keydown', (e) => {
        if (e.key === "/" && !e.ctrlKey && !e.metaKey) {
          // Close command palette if / is pressed while it's focused
          console.log('Closing command palette via / key');
          closeCommandPalette();
          e.preventDefault();
          e.stopPropagation();
          return;
        }
      });
      
      // Close command palette when clicking outside
      commandPalette.addEventListener('click', (e) => {
        if (e.target === commandPalette) {
          closeCommandPalette();
        }
      });

      // Initialize status feed visibility from localStorage
      function initializeStatusFeed() {
        const statusFeedVisible = localStorage.getItem('statusFeedVisible');
        if (statusFeedVisible === 'true') {
          showStatusFeed();
        }
      }
      
      // Update exposure display value
      function updateExposureDisplay(imageId, value) {
        const numValue = parseFloat(value);
        const displayValue = numValue >= 0 ? '+' + numValue : numValue;
        const displayElement = document.getElementById('exposure-value-' + imageId);
        if (displayElement) {
          displayElement.textContent = displayValue + ' EV';
        }
      }

      // Gallery selection message
      function showGallerySelectionMessage() {
        // Clear existing content
        images = [];
        current = 0;
        currentGallery = null; // Reset current gallery so keyboard navigation works
        
        // Create selection message
        const message = `
          <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #181818;
            padding: 40px;
            text-align: center;
            color: #ccc;
            font-family: system-ui, -apple-system, sans-serif;
            box-sizing: border-box;
            z-index: 150;
          ">
            <div style="
              font-size: 48px;
              margin-bottom: 24px;
              opacity: 0.6;
            ">üì∏</div>
            <h2 style="
              font-size: 28px;
              margin: 0 0 16px 0;
              color: #fff;
              font-weight: 300;
            ">Select a Gallery</h2>
            <p style="
              font-size: 16px;
              margin: 0 0 24px 0;
              opacity: 0.8;
              max-width: 400px;
              line-height: 1.5;
            ">Choose a gallery from the sidebar to view your photos. Use the arrow keys to navigate the gallery list.</p>
            <div style="
              font-size: 14px;
              opacity: 0.6;
              padding: 16px 24px;
              background: rgba(255,255,255,0.05);
              border-radius: 8px;
              border: 1px solid rgba(255,255,255,0.1);
            ">
              üìã ${galleries.length} galleries available
            </div>
          </div>
        `;
        
        // Update thumbnail grid with message
        thumbgrid.innerHTML = message;
        
        // Clear single view but preserve the img and video elements
        const bigimgWrap = document.querySelector('#singleview .bigimg-wrap');
        if (bigimgWrap) {
          bigimgWrap.innerHTML = `
            <img id="bigimg" class="bigimg" draggable="false" />
            <video id="bigvideo" class="bigvideo" controls></video>
          `;
        }
        
        // Update mode and navigation
        mode = "thumbs";
        const singleViewEl = document.getElementById('single-view');
        const gridViewEl = document.getElementById('grid-view');
        if (singleViewEl) singleViewEl.classList.remove('active');
        if (gridViewEl) gridViewEl.classList.add('active');
        
        // Clear selections
        selectedThumbnails.clear();
        updateSelectionDisplay();
      }

      // Sorting functionality
      let currentSortOrder = 'oldest'; // Default to oldest first
      
      function sortImages(order) {
        if (!images || images.length === 0) return;
        
        const sortedImages = [...images].sort((a, b) => {
          // Normalize date strings to handle timezone inconsistencies between videos and photos
          function normalizeDate(dateStr) {
            if (!dateStr) return 0;
            
            // If date already has timezone info (videos), use as-is
            if (dateStr.includes('+') || dateStr.includes('Z')) {
              return new Date(dateStr);
            }
            
            // If no timezone info (photos), treat as UTC to match videos
            // Convert "2025-09-06 16:41:10" to "2025-09-06T16:41:10Z"
            const normalizedStr = dateStr.replace(' ', 'T') + 'Z';
            return new Date(normalizedStr);
          }
          
          // Try different date fields, prioritizing DateTimeOriginal
          const dateA = normalizeDate(a.DateTimeOriginal || a.DateTime || a.FileModifyDate);
          const dateB = normalizeDate(b.DateTimeOriginal || b.DateTime || b.FileModifyDate);
          
          if (order === 'oldest') {
            return dateA - dateB; // Oldest first
          } else {
            return dateB - dateA; // Newest first  
          }
        });
        
        // Update global images array
        images = sortedImages;
        currentSortOrder = order;
        
        // Update button states
        document.getElementById('sort-oldest').classList.toggle('active', order === 'oldest');
        document.getElementById('sort-newest').classList.toggle('active', order === 'newest');
        
        // Re-render thumbnails with new order
        renderThumbnails();
        
        // Reset current index to 0 to show first image in new order
        current = 0;
        if (mode === "single") {
          loadImage(current);
        }
        
        // Update preload queue with new order
        createPreloadQueue();
      }
      
      function initializeSortControls() {
        document.getElementById('sort-oldest').addEventListener('click', () => {
          if (currentSortOrder !== 'oldest') {
            sortImages('oldest');
          }
        });
        
        document.getElementById('sort-newest').addEventListener('click', () => {
          if (currentSortOrder !== 'newest') {
            sortImages('newest');
          }
        });
      }

      // Initialize touch support and status feed after page loads
      document.addEventListener('DOMContentLoaded', function() {
        initializeTouchSupport();
        initializeStatusFeed();
        initializeSortControls();
        
        // Initialize picks and rejects from server
        initializePicksAndRejects();
        
        // Add click handler to gallery selector for focusing
        const gallerySelector = document.getElementById('gallery-selector');
        if (gallerySelector) {
          gallerySelector.addEventListener('click', function(e) {
            // Only focus if clicking on the selector itself or header, not on gallery items
            if (e.target === gallerySelector || e.target.classList.contains('gallery-header')) {
              focusGallerySelector();
            }
          });
        }
      });
    </script>
  </body>
</html>
