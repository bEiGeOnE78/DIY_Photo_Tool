<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Gallery Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        background: #181818;
        color: #eee;
        font-family: system-ui, sans-serif;
      }
      #main {
        display: flex;
        height: 100vh;
      }
      #gallery-selector {
        width: 0;
        min-width: 0;
        background: #1e1e1e;
        color: #fff;
        border-right: 1px solid #333;
        padding: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 6px;
        z-index: 300;
      }
      #gallery-selector.visible {
        width: 228px;
        min-width: 180px;
        padding: 12px;
        overflow-y: auto;
      }
      .gallery-item {
        padding: 8px 10px;
        background: #2a2a2a;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
        font-size: 11px;
        font-weight: 500;
        border: 1px solid transparent;
        line-height: 1.3;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .gallery-item:hover {
        background: #3a3a3a;
      }
      .gallery-item.active {
        background: #0066cc;
        border-color: #41aaff;
      }
      .gallery-count-badge {
        background: #666;
        color: #ccc;
        font-size: 8px;
        font-weight: 600;
        padding: 2px 6px;
        border-radius: 8px;
        margin-left: auto;
        min-width: 16px;
        text-align: center;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }
      .gallery-item.active .gallery-count-badge {
        background: #4CAF50;
        color: white;
      }
      .gallery-item.keyboard-selected {
        background: #804dcc;
        border-color: #b366ff;
      }
      .gallery-item.keyboard-selected .gallery-count-badge {
        background: #9966cc;
        color: white;
      }
      .gallery-selector.focused {
        border: 2px solid #9966cc;
        background: rgba(153, 102, 204, 0.1);
      }
      .gallery-item.active.gallery-focused {
        background: #0066cc;
        border: 2px solid #9966cc;
      }
      .gallery-header {
        font-weight: 600;
        margin-bottom: 8px;
        padding: 6px 0;
        border-bottom: 1px solid #333;
        color: #999;
        font-size: 9px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      #sidebar {
        width: 0;
        min-width: 0;
        max-width: 0;
        background: #1e1e1e;
        color: #fff;
        border-left: 1px solid #333;
        box-sizing: border-box;
        padding: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 12px;
        z-index: 300;
      }
      #sidebar.visible {
        width: 240px;
        min-width: 200px;
        max-width: 280px;
        padding: 16px 12px;
        overflow-y: auto;
      }
      .meta-table {
        font-size: 10px;
        width: 100%;
        border-collapse: collapse;
        line-height: 1.3;
      }
      .meta-table td {
        padding: 2px 3px;
        vertical-align: top;
      }
      .meta-table td:first-child {
        color: #999;
        font-weight: 500;
        width: 55px;
        font-size: 9px;
        text-transform: uppercase;
        letter-spacing: 0.4px;
      }
      .meta-table td:last-child {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
        font-size: 10px;
        color: #e0e0e0;
      }
      .map-iframe {
        width: 100%;
        height: 120px;
        border: 0;
        border-radius: 6px;
        margin-top: 8px;
      }
      #gallery-area {
        flex: 1;
        position: relative;
        display: flex;
        flex-direction: column;
      }
      .thumb-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        gap: 14px;
        padding: 20px;
        overflow-y: auto;
        flex: 1;
        background: rgba(25, 26, 29, 0.98);
        justify-content: space-evenly;
        align-content: start;
        align-items: start;
        z-index: 200;
      }
      .thumb-cell {
        background: #262626;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid transparent;
        border-radius: 10px;
        cursor: pointer;
        transition: border-color 0.12s;
        position: relative;
        aspect-ratio: 1;
        width: 100%;
      }
      .thumb-cell.highlight-selected {
        border-color: #ffaa00;
        background: rgba(255, 170, 0, 0.1);
        z-index: 2;
      }
      .thumb-cell.picked {
        border: 2px solid #0f0;
        box-shadow: 0 0 8px #0f0;
        z-index: 2;
      }
      /* Ensure selected picked images are clearly visible */
      .thumb-cell.picked.highlight-selected {
        border: 2px solid #ffaa00 !important;
        background: rgba(255, 170, 0, 0.3) !important;
        box-shadow: 0 0 12px rgba(255, 170, 0, 0.6), 0 0 8px rgba(0, 255, 0, 0.4) !important;
        z-index: 10 !important;
      }
      .thumb-cell img {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        display: block;
        object-fit: contain;
        transition: box-shadow 0.1s;
      }
      
      /* Video thumbnail filmstrip styling */
      .thumb-cell.video-thumbnail::before,
      .thumb-cell.video-thumbnail::after {
        content: '';
        position: absolute;
        left: 6px;
        right: 6px;
        height: 5px;
        background: repeating-linear-gradient(
          to right,
          #222 0px,
          #222 6px,
          #444 6px,
          #444 8px,
          #666 8px,
          #666 10px,
          #444 10px,
          #444 12px
        );
        opacity: 0.5;
        z-index: 1;
        border-radius: 3px;
      }
      
      .thumb-cell.video-thumbnail::before {
        top: 8px;
      }
      
      .thumb-cell.video-thumbnail::after {
        bottom: 8px;
      }
      
      #singleview {
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #181818;
        align-items: center;
        justify-content: center;
        z-index: 1;
        flex-direction: column;
        overflow: hidden;
      }
      #singleview.visible {
        z-index: 200;
      }
      .bigimg-wrap {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
      }
      /* Adjust single view position and size when sidebars are visible */
      /* Default: full screen with no sidebars */
      #singleview {
        left: 0;
        right: 0;
        width: 100%;
      }
      
      /* When gallery selector is visible, shift right and reduce width */
      #gallery-selector.visible ~ #gallery-area #singleview {
        left: 253px;
        width: calc(100% - 253px);
      }
      
      /* When metadata sidebar is visible, shift left and reduce width */
      #main:has(#sidebar.visible) #singleview {
        right: 240px;
        width: calc(100% - 240px);
      }
      
      /* When both sidebars are visible, adjust both sides */
      #main:has(#gallery-selector.visible):has(#sidebar.visible) #singleview {
        left: 253px;
        right: 240px;
        width: calc(100% - 493px);
      }
      .bigimg, .bigvideo {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        transition: box-shadow 0.13s;
        box-shadow: 0 4px 48px #000a;
        background: #222;
        cursor: pointer;
        position: relative;
        left: 0;
        top: 0;
        box-sizing: border-box;
      }
      .bigvideo {
        display: none; /* Hidden by default, shown when video is loaded */
        width: 100% !important;
        height: 100% !important;
        min-width: 640px !important;
        min-height: 360px !important;
        max-width: 100vw !important;
        max-height: 100vh !important;
        pointer-events: auto !important; /* Ensure mouse interactions work */
        z-index: 999 !important; /* Higher z-index to ensure it's not blocked */
        position: relative !important; /* Ensure z-index takes effect */
      }
      .bigimg.picked, .bigvideo.picked {
        border: 4px solid #0f0;
        box-shadow: 0 0 20px #0f0, 0 4px 48px #000a;
      }
      .bigimg.rejected, .bigvideo.rejected {
        border: 4px solid #ff4444;
        box-shadow: 0 0 20px #ff4444, 0 4px 48px #000a;
        opacity: 0.7;
      }
      .bigimg.pixelzoom {
        max-width: none;
        max-height: none;
        width: auto;
        height: auto;
        position: absolute;
        left: 0;
        top: 0;
        background: #222;
        cursor: grab;
        box-sizing: border-box;
      }
      .bigimg.pixelzoom.rejected {
        border: 4px solid #ff4444;
        box-shadow: 0 0 20px #ff4444, 0 4px 48px #000a;
        opacity: 0.7;
      }
      .bigimg.pixelzoom.picked {
        border: 4px solid #0f0;
        box-shadow: 0 0 20px #0f0, 0 4px 48px #000a;
      }
      
      /* Status indicator dots for full screen mode */
      .status-indicator {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        z-index: 600;
        display: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      }
      
      .status-indicator.picked {
        background: #00ff00;
        display: block;
      }
      
      .status-indicator.rejected {
        background: #ff4444;
        display: block;
      }
      .bigvideo {
        cursor: default;
      }
      .filename-overlay {
        position: absolute;
        bottom: 8px;
        left: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
        font-family: monospace;
        word-break: break-all;
        z-index: 12;
        display: none;
      }
      .filename-overlay.visible {
        display: block;
      }
      .face-overlay {
        position: absolute;
        border: 2px solid #00ff00;
        border-radius: 4px;
        background: transparent;
        pointer-events: auto;
        z-index: 500;
        display: none;
      }
      .face-overlay.visible {
        display: block;
      }
      .face-label {
        position: absolute;
        top: -25px;
        left: 0;
        background: rgba(0, 255, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        font-family: system-ui, sans-serif;
        white-space: nowrap;
      }
      .thumb-cell.rejected {
        border: 2px solid #ff4444 !important;
        opacity: 0.4;
        background: rgba(255, 68, 68, 0.1);
      }
      /* Ensure selected rejected images are clearly visible */
      .thumb-cell.rejected.highlight-selected {
        opacity: 0.8 !important;
        border: 2px solid #ffaa00 !important;
        background: rgba(255, 170, 0, 0.3) !important;
        box-shadow: 0 0 12px rgba(255, 170, 0, 0.6), 0 0 4px rgba(255, 68, 68, 0.4) !important;
        z-index: 10 !important;
      }
      #cull-strip {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 120px;
        background: #1a1a1a;
        border-top: 2px solid #333;
        display: none;
        flex-direction: row;
        align-items: center;
        gap: 10px;
        padding: 10px;
        overflow-x: auto;
        z-index: 100;
      }
      #cull-strip.visible {
        display: flex;
      }
      .cull-thumb {
        height: 100px;
        width: 100px;
        object-fit: cover;
        border: 2px solid #555;
        border-radius: 4px;
        cursor: pointer;
        flex-shrink: 0;
      }
      .cull-thumb.active {
        border-color: #0066cc;
        box-shadow: 0 0 10px rgba(0, 102, 204, 0.5);
      }
      .cull-thumb.pick {
        border-color: #00ff00;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }
      #cull-comparison {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 142px;
        background: #181818;
        display: none;
        z-index: 98;
      }
      #cull-comparison.visible {
        display: flex;
        gap: 10px;
        width: 100%;
        height: 100%;
      }
      #cull-comparison.full {
        overflow: hidden;
      }
      .cull-img-container {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .cull-img-container img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      #cull-comparison.full img {
        position: absolute;
        top: 0;
        left: 0;
        width: auto;
        height: auto;
        object-fit: none;
      }
      #cull-single.full img {
        position: absolute;
        top: 0;
        left: 0;
        width: auto;
        height: auto;
        object-fit: none;
      }
      .cull-side-images {
        width: 300px;
        background: #242424;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        gap: 5px;
        padding: 10px;
      }
      .cull-side-thumb {
        width: 100%;
        height: 120px;
        object-fit: cover;
        cursor: pointer;
        border: 2px solid #555;
        border-radius: 4px;
      }
      .cull-side-thumb.pick {
        border-color: #00ff00;
        box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
      }
      #cull-exit-hint {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 101;
        display: none;
      }
      #cull-exit-hint.visible {
        display: block;
      }
      @media (max-width: 700px) {
        #sidebar {
          width: 180px;
          min-width: 100px;
          font-size: 11px;
        }
        .meta-table {
          font-size: 12px;
        }
        .map-iframe {
          height: 90px;
        }
        .filename-overlay {
          font-size: 12px;
          padding: 6px 8px;
        }
      }

      /* Touch Device Toolbar */
      #touch-toolbar {
        display: none;
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 4px;
        padding: 8px 16px;
        z-index: 1000;
        gap: 12px;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      #touch-toolbar.visible {
        display: flex;
      }
      
      .touch-btn {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 9px 16px;
        color: #fff;
        font-size: 12px;
        font-weight: 600;
        font-family: 'Helvetica Neue', Arial, sans-serif;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: all 0.2s;
        min-width: 40px;
        text-align: center;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        white-space: nowrap;
      }
      
      .touch-btn:hover, .touch-btn:active {
        background: rgba(0, 0, 0, 0.9);
        border-color: rgba(255, 255, 255, 0.4);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
      }
      
      .touch-btn.active {
        background: #0066cc;
        border-color: #41aaff;
      }
      
      .touch-btn.pick {
        background: rgba(0, 255, 0, 0.2);
        border-color: rgba(0, 255, 0, 0.4);
      }
      
      .touch-btn.reject {
        background: rgba(255, 0, 0, 0.2);
        border-color: rgba(255, 0, 0, 0.4);
      }

      /* Cull Mode Toolbar */
      #cull-toolbar {
        display: none;
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 4px;
        padding: 8px 16px;
        z-index: 1000;
        gap: 12px;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      #cull-toolbar.visible {
        display: flex;
      }

      /* Touch selection indicator */
      .thumb-cell.touch-selected {
        border-color: #ffaa00;
        background: rgba(255, 170, 0, 0.2);
        transform: scale(0.95);
      }

      /* Sort controls */
      #sort-controls {
        background: #1e1e1e;
        border-bottom: 1px solid #333;
        padding: 8px 12px;
        display: flex !important;
        align-items: center;
        gap: 12px;
        font-size: 11px;
        color: #ccc;
        min-height: 36px;
        z-index: 100;
        position: relative;
      }
      
      .sort-btn {
        background: #2a2a2a;
        border: 1px solid #444;
        color: #ccc;
        padding: 4px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 10px;
        transition: all 0.2s;
      }
      
      .sort-btn:hover {
        background: #333;
        border-color: #555;
      }
      
      .sort-btn.active {
        background: #0066cc;
        border-color: #41aaff;
        color: white;
      }
      
      /* Command Palette - Spotlight style */
      #command-palette {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        display: none;
        align-items: flex-start;
        justify-content: center;
        padding-top: 100px;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      
      #command-palette.visible {
        display: flex;
        opacity: 1;
      }
      
      .command-palette-container {
        background: #2c2c2c;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        width: 90%;
        max-width: 600px;
        overflow: hidden;
        border: 1px solid #444;
      }
      
      .command-input-container {
        padding: 20px;
        border-bottom: 1px solid #444;
      }
      
      #command-input {
        width: 100%;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 18px;
        font-family: system-ui, sans-serif;
        outline: none;
        padding: 0;
      }
      
      #command-input::placeholder {
        color: #888;
      }
      
      .command-results {
        max-height: 400px;
        overflow-y: auto;
      }
      
      .command-item {
        padding: 12px 20px;
        border-bottom: 1px solid #333;
        cursor: pointer;
        transition: background 0.1s ease;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      
      .command-item:hover,
      .command-item.selected {
        background: #3c3c3c;
      }
      
      .command-item:last-child {
        border-bottom: none;
      }
      
      .command-item.disabled {
        opacity: 0.6;
        cursor: default;
      }
      
      .command-item.disabled:hover {
        background: transparent;
      }
      
      .command-item-left {
        display: flex;
        align-items: center;
        flex: 1;
      }
      
      .command-icon {
        width: 20px;
        height: 20px;
        margin-right: 12px;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .command-details {
        display: flex;
        flex-direction: column;
        flex: 1;
      }
      
      .command-title {
        color: #fff;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 2px;
      }
      
      .command-subtitle {
        color: #888;
        font-size: 12px;
      }
      
      .command-shortcut {
        color: #666;
        font-size: 11px;
        background: #1a1a1a;
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #333;
      }
      
      .command-preview {
        padding: 15px 20px;
        background: #1a1a1a;
        border-top: 1px solid #333;
        color: #aaa;
        font-size: 12px;
        line-height: 1.4;
      }
      
      .command-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 40px;
        color: #888;
      }
      
      .command-loading .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #333;
        border-top: 2px solid #666;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .command-mode-badge {
        padding: 8px 20px;
        background: #1a1a1a;
        border-bottom: 1px solid #333;
        display: flex;
        align-items: center;
      }
      
      .command-badge-content {
        display: flex;
        align-items: center;
        background: #333;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 12px;
        color: #fff;
      }
      
      .command-badge-icon {
        margin-right: 6px;
        font-size: 14px;
      }
      
      .command-badge-text {
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .leica-badge {
        display: inline-block;
        flex: 1;
        text-align: center;
        padding: 9px 16px;
        white-space: nowrap;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        font-size: 10px;
        font-weight: 600;
        font-family: 'Helvetica Neue', Arial, sans-serif;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      }
      
      /* Status Feed Styles */
      #status-feed {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 6px;
        margin-top: 12px;
        max-height: 200px;
        display: flex;
        flex-direction: column;
      }
      
      #status-feed-header {
        background: #2a2a2a;
        padding: 8px 10px;
        border-bottom: 1px solid #333;
        border-radius: 6px 6px 0 0;
        font-size: 10px;
        font-weight: 600;
        color: #ccc;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      #status-feed-content {
        flex: 1;
        overflow-y: auto;
        padding: 6px;
        max-height: 150px;
        font-size: 9px;
        font-family: 'SF Mono', Consolas, 'Monaco', monospace;
        line-height: 1.3;
      }
      
      .status-entry {
        padding: 2px 0;
        color: #ddd;
        display: flex;
        align-items: flex-start;
        gap: 6px;
      }
      
      .status-entry.success {
        color: #4CAF50;
      }
      
      .status-entry.error {
        color: #f44336;
      }
      
      .status-entry.warning {
        color: #ff9800;
      }
      
      .status-entry.info {
        color: #2196F3;
      }
      
      .status-timestamp {
        color: #666;
        font-size: 8px;
        min-width: 45px;
        flex-shrink: 0;
      }
      
      .status-message {
        flex: 1;
        word-break: break-word;
      }
      
      #status-feed.hidden {
        display: none;
      }
      
      #status-clear-btn {
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-size: 10px;
        padding: 2px 4px;
        border-radius: 3px;
        transition: color 0.2s;
      }
      
      #status-clear-btn:hover {
        color: #ccc;
        background: rgba(255, 255, 255, 0.1);
      }
    </style>
  </head>
  <body>
    <div id="main">
      <div id="gallery-selector" class="visible">
        <div class="gallery-header">Galleries</div>
      </div>
      <div id="gallery-area">
        <div id="sort-controls">
          <span>Sort:</span>
          <button class="sort-btn active" id="sort-oldest">Oldest First</button>
          <button class="sort-btn" id="sort-newest">Newest First</button>
        </div>
        <div class="thumb-grid" id="thumbgrid"></div>
        <div id="singleview">
          <div class="bigimg-wrap" id="bigimgWrap">
            <img id="bigimg" class="bigimg" draggable="false" />
            <video id="bigvideo" class="bigvideo" controls></video>
          </div>
          <div class="status-indicator" id="statusIndicator"></div>
        </div>
      </div>
      <div id="sidebar"></div>
      
      <!-- Touch Device Toolbars -->
      <div id="touch-toolbar">
        <button class="touch-btn" id="touch-gallery-btn">📁</button>
        <button class="touch-btn" id="touch-pick-btn">✓</button>
        <button class="touch-btn" id="touch-reject-btn">✗</button>
        <button class="touch-btn" id="touch-faces-btn">👤</button>
        <button class="touch-btn" id="touch-sidebar-btn">ℹ️</button>
        <button class="touch-btn" id="touch-picks-btn">📋</button>
        <button class="touch-btn" id="touch-status-btn">📊</button>
        <button class="touch-btn" id="touch-command-btn">/</button>
        <button class="touch-btn" id="touch-prev-btn" style="display: none;">◀</button>
        <button class="touch-btn" id="touch-next-btn" style="display: none;">▶</button>
        <button class="touch-btn" id="touch-clear-btn" style="display: none;">Clear</button>
        <button class="touch-btn" id="touch-cull-btn" style="display: none;">Cull</button>
        <button class="touch-btn" id="touch-finish-btn" style="display: none;">Finish</button>
      </div>
      
      <div id="cull-toolbar">
        <button class="touch-btn" id="cull-finish-btn">Finish</button>
        <button class="touch-btn" id="cull-cancel-btn">Cancel</button>
      </div>
      
      <!-- Cull Mode UI -->
      <div id="cull-strip">
      </div>
      
      <div id="cull-comparison">
        <div class="cull-img-container">
          <img id="cull-candidate-img" />
          <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; font-size: 14px; z-index: 1;">
            Candidate
          </div>
        </div>
        <div class="cull-img-container">
          <img id="cull-current-img" />
          <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; font-size: 14px; z-index: 1;">
            Current
          </div>
        </div>
      </div>
      
      <!-- Single image view for cull mode (when no candidate selected) -->
      <div id="cull-single" style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 142px;
        background: #181818;
        display: none;
        z-index: 98;
      ">
        <div class="cull-img-container" style="width: 100%; height: 100%;">
          <img id="cull-main-img" />
        </div>
      </div>
      
      
      <!-- Command Palette -->
      <div id="command-palette">
        <div class="command-palette-container">
          <div class="command-input-container">
            <input id="command-input" type="text" placeholder="Type a command..." autocomplete="off" spellcheck="false">
          </div>
          <div class="command-results" id="command-results">
            <!-- Command results will be populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>
    <script>
      // Dynamic API configuration based on current host
      function getApiBaseUrl() {
        const host = window.location.hostname;
        const port = 8001; // Face API server port
        
        // If accessing via localhost, use localhost for API
        if (host === 'localhost' || host === '127.0.0.1') {
          return `http://localhost:${port}`;
        }
        // Otherwise, use the same host as the current page
        return `http://${host}:${port}`;
      }
      
      const API_BASE_URL = getApiBaseUrl();
      
      let images = [],
        current = 0,
        mode = "thumbs",
        sidebarOpen = true,
        picks = new Set(),
        rejects = new Set(),
        galleries = [],
        currentGallery = null,
        gallerySelectorOpen = true,
        facesVisible = false,
        selectedThumbnails = new Set(),
        cullMode = false,
        cullImages = [],
        cullCurrent = 0,
        cullPick = -1,
        preloadCache = new Set(),
        isTouchDevice = false,
        touchStartTime = 0,
        touchTimeout = null,
        touchHoldThreshold = 500,
        touchMode = 'normal',
        touchStartX = 0,
        touchStartY = 0,
        touchMoveThreshold = 10,
        commandPaletteOpen = false,
        commandPaletteSelectedIndex = -1,
        commandPaletteItems = [],
        commandPaletteMode = null, // null, 'gallery'
        commandPaletteSearchString = '',
        inputFieldFocused = false,
        // Background preloading system
        preloadingActive = false,
        preloadQueue = [],
        preloadAbortController = null,
        preloadedImages = new Set(),
        currentPreloadIndex = 0,
        maxPreloadImages = 100,
        // DOM-based adjacent image system
        adjacentImages = {
          prev2: null, prev1: null, current: null, next1: null, next2: null
        },
        adjacentVideos = {
          prev2: null, prev1: null, current: null, next1: null, next2: null
        };
      const thumbgrid = document.getElementById("thumbgrid");
      const bigimg = document.getElementById("bigimg");
      const bigvideo = document.getElementById("bigvideo");
      const singleview = document.getElementById("singleview");
      
      // Debug video element at page load
      console.log('🎬 Video element at page load:', {
        bigvideo: bigvideo,
        exists: !!bigvideo,
        inDOM: bigvideo && bigvideo.parentElement !== null,
        allVideoElements: document.querySelectorAll('video'),
        bigimgWrapContent: document.getElementById('bigimgWrap') ? document.getElementById('bigimgWrap').innerHTML : 'NO WRAP'
      });
      const sidebar = document.getElementById("sidebar");
      const commandPalette = document.getElementById("command-palette");
      const commandInput = document.getElementById("command-input");
      const commandResults = document.getElementById("command-results");
      const bigimgWrap = document.getElementById("bigimgWrap");
      const main = document.getElementById("main");

      function detectTouchDevice() {
        return ('ontouchstart' in window) || 
               (navigator.maxTouchPoints > 0) || 
               (navigator.msMaxTouchPoints > 0);
      }
      
      function isVideoFile(filename) {
        const videoExts = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.m4v'];
        const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
        return videoExts.includes(ext);
      }

      function convertDMSToDD(dms) {
        // Handle numeric values (already decimal degrees)
        if (typeof dms === 'number') return dms;
        
        // Convert "51 deg 20' 26.21" N" format to decimal degrees
        if (typeof dms === 'string') {
          const match = dms.match(/(\d+) deg (\d+)' ([\d.]+)"/);
          if (!match) return parseFloat(dms); // fallback if already decimal
          const degrees = parseFloat(match[1]);
          const minutes = parseFloat(match[2]);
          const seconds = parseFloat(match[3]);
          let dd = degrees + minutes/60 + seconds/3600;
          if (dms.includes('S') || dms.includes('W')) dd = -dd;
          return dd;
        }
        
        return parseFloat(dms) || 0;
      }
      
      let galleryCache = null;
      let galleryCacheBuilt = false;
      let galleriesListLoaded = false;
      
      async function getGalleryInfo(imageId) {
        try {
          // Load all gallery JSONs if not cached
          if (!galleryCacheBuilt) {
            galleryCache = {};
            galleryCacheBuilt = true;
            
            // Use the existing galleries data instead of fetching galleries.json
            if (!galleries || galleries.length === 0) {
              return ""; // No galleries loaded yet
            }
            
            // Load each gallery's JSON
            for (const gallery of galleries) {
              try {
                const galleryResponse = await fetch(gallery.jsonPath + '?t=' + Date.now());
                const galleryData = await galleryResponse.json();
                
                // Index by image ID
                for (const image of galleryData) {
                  if (image._imageId) {
                    if (!galleryCache[image._imageId]) {
                      galleryCache[image._imageId] = [];
                    }
                    galleryCache[image._imageId].push(gallery.name);
                  }
                }
              } catch (e) {
                console.log(`Could not load gallery ${gallery.name}:`, e);
              }
            }
            
          }
          
          const foundGalleries = galleryCache[imageId] || [];
          
          if (foundGalleries.length > 1) { // More than current gallery
            const currentGalleryName = currentGallery ? getGalleryNameFromPath(currentGallery) : '';
            const otherGalleries = foundGalleries.filter(name => name !== currentGalleryName);
            
            if (otherGalleries.length > 0) {
              return `
                <div style="margin-top: 10px; padding: 6px 8px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
                  <div style="font-size: 9px; font-weight: 600; margin-bottom: 4px; color: #999; text-transform: uppercase; letter-spacing: 0.5px;">Also In</div>
                  <div style="font-size: 10px; line-height: 1.3;">
                    ${otherGalleries.map(name => `<div style="color: #e0e0e0; margin-bottom: 2px;">${name}</div>`).join('')}
                  </div>
                </div>`;
            }
          }
          
          console.log('No other galleries found for image', imageId);
          return "";
        } catch (e) {
          console.log('Error loading gallery info:', e);
          return "";
        }
      }

      async function loadSidebar(idx) {
        if (!images[idx]) {
          sidebar.innerHTML = "";
          return;
        }
        const meta = images[idx];
        
        // Create Leica-style camera setting badges at the top
        let cameraSettings = "";
        const settingBadges = [];
        
        if (meta.FNumber) {
          settingBadges.push(`<span class="leica-badge">ƒ/${meta.FNumber}</span>`);
        }
        if (meta.ExposureTime) {
          settingBadges.push(`<span class="leica-badge">${meta.ExposureTime}s</span>`);
        }
        if (meta.ISO) {
          settingBadges.push(`<span class="leica-badge">ISO ${meta.ISO}</span>`);
        }
        if (meta.ExposureCompensation) {
          const comp = parseFloat(meta.ExposureCompensation);
          const sign = comp > 0 ? '+' : '';
          settingBadges.push(`<span class="leica-badge">${sign}${comp}EV</span>`);
        }
        if (meta.FocalLengthIn35mmFormat) {
          const focalLength = String(meta.FocalLengthIn35mmFormat).replace(/[^\d.]/g, '');
          if (focalLength && !isNaN(parseFloat(focalLength))) {
            settingBadges.push(`<span class="leica-badge">${Math.round(parseFloat(focalLength))}mm</span>`);
          }
        }
        
        // Add RAW badge (simplified - no async database call)
        if (meta.raw_proxy_type && meta.raw_proxy_type !== 'none') {
          settingBadges.push(`<span class="leica-badge">RAW</span>`);
        }
        
        // Ensure file type badge is always added
        if (meta.FileType && !settingBadges.some(badge => badge.includes(meta.FileType))) {
          settingBadges.push(`<span class="leica-badge">${meta.FileType}</span>`);
        }
        
        // Add megapixels badge
        const width = meta.ImageWidth || meta.width;
        const height = meta.ImageHeight || meta.height;
        if (width && height) {
          const megapixels = Math.round(width * height / 1000000);
          settingBadges.push(`<span class="leica-badge">${megapixels}MP</span>`);
        }
        
        // Add film mode badge last
        if (meta.FilmMode) {
          const filmName = meta.FilmMode.includes('(') && meta.FilmMode.includes(')') 
            ? meta.FilmMode.match(/\(([^)]+)\)/)?.[1] || meta.FilmMode
            : meta.FilmMode;
          settingBadges.push(`<span class="leica-badge">${filmName}</span>`);
        }
        
        if (settingBadges.length > 0) {
          cameraSettings = `<div style="margin-bottom: 12px; display: flex; flex-wrap: wrap; gap: 8px;">${settingBadges.join('')}</div>`;
        }
        
        let table = `<table class="meta-table">`;
        if (meta.DateTimeOriginal)
          table += `<tr><td>Date</td><td>${meta.DateTimeOriginal.replace(/:/g, "-").replace(" ", "&nbsp;")}</td></tr>`;
        if (meta.Make || meta.Model)
          table += `<tr><td>Camera</td><td>${[meta.Make, meta.Model].filter(Boolean).join(" ")}</td></tr>`;
        if (meta.LensModel)
          table += `<tr><td>Lens</td><td>${meta.LensModel}</td></tr>`;
        if (meta.FocalLength) {
          const focalLength = String(meta.FocalLength).replace(/[^\d.]/g, '');
          if (focalLength && !isNaN(parseFloat(focalLength))) {
            table += `<tr><td>Focal</td><td>${Math.round(parseFloat(focalLength))}mm</td></tr>`;
          } else {
            table += `<tr><td>Focal</td><td>${meta.FocalLength}</td></tr>`;
          }
        }
        // Add pixel dimensions (but not megapixels - will be in badges)
        // Check multiple possible field names for dimensions
        const tableWidth = meta.ImageWidth || meta.width;
        const tableHeight = meta.ImageHeight || meta.height;
        if (tableWidth && tableHeight) {
          table += `<tr><td>Dimensions</td><td>${tableWidth} × ${tableHeight}</td></tr>`;
        }
        
        if (meta.GPSLatitude && meta.GPSLongitude)
          table += `<tr><td>GPS</td><td>${meta.GPSLatitude.toFixed(4)}, ${meta.GPSLongitude.toFixed(4)}</td></tr>`;
        // Get correct file type and path from database for RAW files
        let fileType = meta.FileType;
        let masterPath = meta._originalPath || meta.FileName;
        
        // Add file type badge early (before async RAW logic)
        if (fileType) {
          settingBadges.push(`<span class="leica-badge">${fileType}</span>`);
        }
        
        if (meta.raw_proxy_type && meta.raw_proxy_type !== 'none') {
          fileType = 'RAW';
        }
        if (masterPath) {
          table += `<tr><td>Master Path</td><td>${masterPath}</td></tr>`;
        }
        
        // Add face recognition metadata if available
        if (meta._personId) {
          table += `<tr><td colspan="2" style="color: #4CAF50; font-weight: bold; padding-top: 8px; border-top: 1px solid #444;">Face Recognition</td></tr>`;
          table += `<tr><td>Person ID</td><td>${meta._personId}</td></tr>`;
          if (meta._personName) {
            table += `<tr><td>Name</td><td>${meta._personName}${meta._personConfirmed ? ' ✓' : ' ?'}</td></tr>`;
          }
          if (meta._faceConfidence) {
            table += `<tr><td>Confidence</td><td>${(meta._faceConfidence * 100).toFixed(1)}%</td></tr>`;
          }
          if (meta._totalFaces) {
            table += `<tr><td>Total Faces</td><td>${meta._totalFaces}</td></tr>`;
          }
          if (meta._sampleNumber) {
            table += `<tr><td>Sample</td><td>${meta._sampleNumber}</td></tr>`;
          }
        }
        
        table += `</table>`;
        
        // Add proxy switching controls if applicable
        let proxyControls = "";
        if (meta._imageId) {
          proxyControls = await getProxyControls(meta._imageId);
        }
        
        // Add gallery information
        let galleryInfo = "";
        if (meta._imageId) {
          galleryInfo = await getGalleryInfo(meta._imageId);
        }
        
        let locationInfo = "";
        if (meta.GPSLatitude && meta.GPSLongitude) {
          const lat = convertDMSToDD(meta.GPSLatitude);
          const lon = convertDMSToDD(meta.GPSLongitude);
          locationInfo = `
            <div style="margin-top: 10px; padding: 6px 8px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
              <div style="font-size: 9px; font-weight: 600; margin-bottom: 4px; color: #999; text-transform: uppercase; letter-spacing: 0.5px;">Location</div>
              <div style="font-size: 10px; color: #ddd; margin-bottom: 4px; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;">
                ${lat.toFixed(6)}, ${lon.toFixed(6)}
              </div>
              <div style="display: flex; gap: 6px; margin-top: 4px;">
                <a href="https://maps.google.com/maps?q=${lat},${lon}" target="_blank" 
                   style="color: #4285f4; text-decoration: none; font-size: 9px; padding: 2px 4px; border-radius: 2px; background: rgba(66, 133, 244, 0.1);">Google Maps</a>
                <a href="https://www.openstreetmap.org/?mlat=${lat}&mlon=${lon}&zoom=15" target="_blank" 
                   style="color: #7ebc6f; text-decoration: none; font-size: 9px; padding: 2px 4px; border-radius: 2px; background: rgba(126, 188, 111, 0.1);">OpenStreetMap</a>
              </div>
            </div>`;
        }
        
        // Status feed HTML - always include
        const statusFeed = `
          <div id="status-feed" class="hidden">
            <div id="status-feed-header">
              <span>Status Feed</span>
              <button id="status-clear-btn" onclick="clearStatusFeed()">Clear</button>
            </div>
            <div id="status-feed-content">
              <!-- Status messages will appear here -->
            </div>
          </div>
        `;
        
        // Render initial content immediately (without proxy controls for performance)
        sidebar.innerHTML = cameraSettings + table + galleryInfo + locationInfo + statusFeed;
        
        // Load proxy controls asynchronously after initial render
        if (meta._imageId) {
          getProxyControls(meta._imageId).then(proxyControls => {
            // Insert proxy controls after the table but before gallery info
            sidebar.innerHTML = cameraSettings + table + proxyControls + galleryInfo + locationInfo + statusFeed;
          }).catch(error => {
            console.log('Could not load proxy controls:', error);
          });
        }
      }

      function showThumbs() {
        mode = "thumbs";
        
        // Use z-index instead of display changes for instant switching
        thumbgrid.style.zIndex = "200";   // Bring thumbnails to front
        singleview.style.zIndex = "1";    // Send single view to back
        singleview.classList.remove('visible');
        
        // Reset video z-index when switching to thumbnail mode
        const videoEl = document.getElementById('bigvideo');
        if (videoEl) {
          videoEl.style.zIndex = "1";
        }
        
        // Hide all adjacent images but keep them in DOM for fast re-entry
        Object.values(adjacentImages).forEach(img => {
          if (img) img.style.opacity = "0";
        });
        Object.values(adjacentVideos).forEach(video => {
          if (video) video.style.opacity = "0";
        });
        
        updateTouchToolbar();
        
        // Sync orange selection with current image from full screen navigation
        selectedThumbnails.clear();
        selectedThumbnails.add(current);
        
        updateSelectionDisplay();
        updatePickClasses();
        updateStatusIndicator();
        loadSidebar(current).catch(console.error);
      }
      function showSingle(fitOrZoom) {
        mode = fitOrZoom;
        
        // Use z-index instead of display changes for instant switching
        singleview.style.zIndex = "200";  // Bring to front
        thumbgrid.style.zIndex = "1";     // Send to back
        singleview.classList.add('visible');
        
        // Check if current item is a video
        const currentMeta = images[current];
        const currentSrc = currentMeta?.SourceFile || currentMeta?.src || currentMeta?.FileName || '';
        const isCurrentVideo = isVideoFile(currentSrc);
        
        if (isCurrentVideo) {
          // For videos, use the main bigvideo element directly
          console.log('📹 Loading video in main bigvideo element');
          loadImage(current);
        } else {
          // Adjacent images should already be created from thumbnail selection
          // Only create them if they don't exist (fallback for edge cases)
          const currentElement = adjacentImages.current || adjacentVideos.current;
          if (!currentElement) {
            console.log('🔄 Creating adjacent images as fallback');
            createAdjacentImageElements(current);
          } else {
            console.log('✨ Using pre-created adjacent images for instant display');
            // Make sure current image is visible
            if (adjacentImages.current) {
              adjacentImages.current.style.opacity = "1";
              adjacentImages.current.style.zIndex = "100";
            }
            if (adjacentVideos.current) {
              adjacentVideos.current.style.opacity = "1";
              adjacentVideos.current.style.zIndex = "100";
            }
          }
        }
        
        loadSidebar(current).catch(console.error);
        updateTouchToolbar();
      }
      function highlightSelected() {
        // No longer needed - orange selection handles this
        updatePickClasses();
      }
      function scrollThumbIntoView(idx) {
        const el = document.querySelector(`.thumb-cell[data-idx='${idx}']`);
        if (el) el.scrollIntoView({ block: "center", inline: "center" });
      }
      function getDisplaySource(meta, forceTimestamp = false) {
        const originalSrc = meta.SourceFile || meta.src || meta.FileName;
        const cleanSrc = originalSrc.replace(/^\.\//, "");
        
        // Check if this is a RAW file with a custom proxy
        if (meta._imageId && meta.has_custom_proxy && meta.raw_proxy_type === 'custom_generated') {
          const proxyPath = `RAW Proxies/${meta._imageId}.jpg`;
          return forceTimestamp ? proxyPath + '?t=' + Date.now() : proxyPath;
        }
        
        // Check if this is a HEIC file and if we have a WebP proxy
        if (meta._imageId && (cleanSrc.toLowerCase().endsWith('.heic') || meta.FileType === 'HEIC')) {
          // Use WebP proxy for display
          const proxyPath = `HEIC Proxies/${meta._imageId}.webp`;
          return forceTimestamp ? proxyPath + '?t=' + Date.now() : proxyPath;
        }
        
        // Check if this is a video file - in galleries, they're already proxy files
        if (isVideoFile(cleanSrc)) {
          // Video files in galleries are already the correct proxy files
          return forceTimestamp ? cleanSrc + '?t=' + Date.now() : cleanSrc;
        }
        
        // Use original file for other files
        const finalSrc = cleanSrc;
        return forceTimestamp ? finalSrc + '?t=' + Date.now() : finalSrc;
      }
      
      function loadImage(idx, forceRefresh = false) {
        if (!images[idx] || !currentGallery) return;
        
        // Use cached version unless forceRefresh is true (for RAW proxy changes)
        const meta = images[idx];
        const displaySrc = getDisplaySource(meta, forceRefresh);
        const originalSrc = meta.SourceFile || meta.src || meta.FileName;
        const cleanOriginalSrc = originalSrc.replace(/^\.\//, ""); // for filename extraction
        const imageId = meta._imageId;
        const isPicked = picks.has(imageId);
        const isRejected = rejects.has(imageId);
        
        console.log('🎯 loadImage called for:', {
          cleanOriginalSrc: cleanOriginalSrc,
          displaySrc: displaySrc,
          isVideo: isVideoFile(cleanOriginalSrc),
          imageId: imageId
        });
        
        if (isVideoFile(cleanOriginalSrc)) {
          // Debug logging for video loading
          console.log('🎬 Loading video:', {
            cleanOriginalSrc: cleanOriginalSrc,
            displaySrc: displaySrc,
            imageId: imageId,
            bigvideoElement: bigvideo,
            bigvideoExists: !!bigvideo,
            bigvideoInDOM: bigvideo && bigvideo.parentElement !== null,
            bigvideoId: bigvideo ? bigvideo.id : 'NO ELEMENT'
          });
          
          // Use fresh DOM lookup instead of potentially detached cached variable
          const videoElement = document.getElementById('bigvideo');
          console.log('🎬 Fresh video element check:', {
            element: videoElement,
            exists: !!videoElement,
            inDOM: videoElement && videoElement.parentElement !== null,
            parentTag: videoElement && videoElement.parentElement ? videoElement.parentElement.tagName : 'NO PARENT'
          });
          
          if (!videoElement) {
            console.error('🎬 ERROR: Video element not found in DOM!');
            return;
          }
          
          if (!videoElement.parentElement) {
            console.error('🎬 ERROR: Video element exists but not attached to DOM!');
            return;
          }
          
          // Add event listeners for debugging video loading
          videoElement.addEventListener('loadstart', () => console.log('🎬 Video loadstart event'), { once: true });
          videoElement.addEventListener('loadedmetadata', () => console.log('🎬 Video loadedmetadata event'), { once: true });
          videoElement.addEventListener('canplay', () => console.log('🎬 Video canplay event'), { once: true });
          videoElement.addEventListener('error', (e) => console.error('🎬 Video error:', e, videoElement.error), { once: true });
          
          // Add simple interaction debugging
          videoElement.addEventListener('click', () => console.log('🎬 Video controls clicked'));
          
          // Show video, hide image
          console.log('🎬 Setting video src to:', displaySrc);
          console.log('🎬 Current base URL:', window.location.origin);
          
          // For videos, ensure we use absolute URL to prevent URI issues
          const absoluteVideoSrc = displaySrc.startsWith('http') ? displaySrc : `http://localhost:8000/${displaySrc}`;
          console.log('🎬 Absolute video URL:', absoluteVideoSrc);
          
          // Ensure proper display switching for videos
          videoElement.src = absoluteVideoSrc;
          videoElement.style.display = "block";
          videoElement.style.zIndex = "999"; // Restore high z-index for control interaction
          
          // Hide image element using fresh DOM lookup
          const currentImageElement = document.getElementById('bigimg');
          if (currentImageElement) {
            currentImageElement.style.display = "none";
          }
          
          console.log('🎬 Display set: video=block, image=none');
          
          // Ensure video is unmuted for autoplay
          videoElement.muted = false;
          videoElement.volume = 1.0; // Set to full volume
          
          // Debug key video properties
          console.log('🎬 Video loaded:', {
            fileName: cleanOriginalSrc.split('/').pop(),
            dimensions: `${videoElement.offsetWidth}x${videoElement.offsetHeight}`,
            muted: videoElement.muted,
            controls: videoElement.controls
          });
          
          console.log('🎬 Video src after setting:', videoElement.src);
          videoElement.classList.toggle("picked", isPicked);
          videoElement.classList.toggle("rejected", isRejected);
          
          // Auto-play the video immediately after setting source
          console.log('🎬 Starting immediate auto-play...');
          setTimeout(() => {
            // For Firefox/Zen browser compatibility, try unmuting again
            videoElement.muted = false;
            videoElement.volume = 1.0;
            
            videoElement.play().then(() => {
              console.log('🎬 Immediate auto-play successful!');
              // Force unmute after successful play
              setTimeout(() => {
                videoElement.muted = false;
                videoElement.volume = 1.0;
                console.log('🎬 Post-play unmute applied');
              }, 50);
            }).catch(err => {
              console.log('🎬 Immediate auto-play failed, will retry on canplay:', err.message);
              // If autoplay fails, try playing muted first then unmuting (Firefox workaround)
              videoElement.muted = true;
              videoElement.play().then(() => {
                console.log('🎬 Playing muted, will unmute after user interaction');
                videoElement.muted = false;
                videoElement.volume = 1.0;
              }).catch(err2 => {
                console.log('🎬 Even muted autoplay failed:', err2.message);
              });
            });
          }, 100);
          
          console.log('🎬 Video element after src set:', {
            src: bigvideo.src,
            display: bigvideo.style.display,
            readyState: bigvideo.readyState,
            networkState: bigvideo.networkState
          });
          
          // Update status indicator dot
          const statusIndicator = document.getElementById('statusIndicator');
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
          
          // Load faces for videos (if any)
          bigvideo.addEventListener('loadedmetadata', () => loadFacesForCurrentImage(), { once: true });
          
          // Additional debugging after video is ready
          bigvideo.addEventListener('canplay', () => {
            console.log('🎬 Video ready to play - element state:', {
              src: bigvideo.src,
              display: bigvideo.style.display,
              visibility: getComputedStyle(bigvideo).visibility,
              width: bigvideo.offsetWidth,
              height: bigvideo.offsetHeight,
              clientWidth: bigvideo.clientWidth,
              clientHeight: bigvideo.clientHeight,
              controls: bigvideo.controls,
              paused: bigvideo.paused,
              readyState: bigvideo.readyState,
              videoWidth: bigvideo.videoWidth,
              videoHeight: bigvideo.videoHeight,
              duration: bigvideo.duration,
              parentElement: bigvideo.parentElement,
              zIndex: getComputedStyle(bigvideo).zIndex
            });
            
            // Debug parent container dimensions
            const parent = bigvideo.parentElement;
            if (parent) {
              console.log('🎬 Parent container state:', {
                tagName: parent.tagName,
                className: parent.className,
                offsetWidth: parent.offsetWidth,
                offsetHeight: parent.offsetHeight,
                clientWidth: parent.clientWidth,
                clientHeight: parent.clientHeight,
                computedStyle: {
                  width: getComputedStyle(parent).width,
                  height: getComputedStyle(parent).height,
                  display: getComputedStyle(parent).display,
                  position: getComputedStyle(parent).position
                }
              });
            } else {
              console.error('🎬 Video element has no parent! Element not attached to DOM.');
            }
            
            // Debug grandparent container
            if (parent) {
              const grandParent = parent.parentElement;
              if (grandParent) {
                console.log('🎬 Grandparent container state:', {
                  tagName: grandParent.tagName,
                  className: grandParent.className,
                  offsetWidth: grandParent.offsetWidth,
                  offsetHeight: grandParent.offsetHeight,
                  computedStyle: {
                    width: getComputedStyle(grandParent).width,
                    height: getComputedStyle(grandParent).height,
                    display: getComputedStyle(grandParent).display
                  }
                });
              }
            }
            
            // Try to play the video automatically for testing
            console.log('🎬 Attempting backup auto-play...');
            // Ensure unmuted before backup autoplay attempt
            videoElement.muted = false;
            videoElement.volume = 1.0;
            videoElement.play().then(() => {
              console.log('🎬 Backup auto-play successful!');
            }).catch(err => {
              console.error('🎬 Backup auto-play failed:', err);
            });
          }, { once: true });
        } else {
          // Show image, hide video (use JPG proxy for HEIC files)
          const currentVideoElement = document.getElementById('bigvideo');
          if (currentVideoElement) {
            currentVideoElement.pause(); // Stop any playing video first
            currentVideoElement.style.display = "none";
            // Remove src attribute instead of setting to empty string to avoid invalid URI error
            currentVideoElement.removeAttribute('src');
            currentVideoElement.load(); // Reset the video element
            console.log('🎬 Video hidden, paused, and source cleared for image display');
          }
          
          // Ensure image element is properly configured
          const currentImageElement = document.getElementById('bigimg');
          if (currentImageElement) {
            currentImageElement.src = displaySrc;
            currentImageElement.style.display = "block";
            currentImageElement.classList.remove("pixelzoom");
            currentImageElement.style.left = currentImageElement.style.top = "0px";
            currentImageElement.classList.toggle("picked", isPicked);
            currentImageElement.classList.toggle("rejected", isRejected);
            console.log('🖼️ Image displayed:', displaySrc.split('/').pop());
          } else {
            console.error('🖼️ ERROR: Image element not found!');
          }
          
          // Update status indicator dot
          const statusIndicator = document.getElementById('statusIndicator');
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
          
          // Load faces after image is fully loaded for proper positioning
          bigimg.addEventListener('load', () => {
            loadFacesForCurrentImage();
            
            // Check cache status for main image load
            setTimeout(() => {
              const cacheStatus = checkImageCacheStatus(displaySrc);
              console.log(`🖼️ Main image ${idx + 1} loaded from ${cacheStatus.toUpperCase()}: ${displaySrc}`);
              console.log(`🔍 Main image preloaded? ${preloadedImages.has(idx)}`);
            }, 10);
          }, { once: true });
          
          // Also call immediately in case image is already cached
          if (bigimg.complete) {
            loadFacesForCurrentImage();
          }
        }
      }
      
      function createAdjacentImageElements(centerIdx) {
        /**Create DOM elements for current image and 2 adjacent images on each side*/
        if (!images || images.length === 0) return;
        
        console.log(`🎯 Creating adjacent images for center index ${centerIdx} (mode: ${mode})`);
        
        // Clear existing adjacent elements
        clearAdjacentElements();
        
        // For small galleries, avoid duplicate indices
        const indices = {};
        if (images.length >= 5) {
          indices.prev2 = (centerIdx - 2 + images.length) % images.length;
          indices.prev1 = (centerIdx - 1 + images.length) % images.length;
          indices.current = centerIdx;
          indices.next1 = (centerIdx + 1) % images.length;
          indices.next2 = (centerIdx + 2) % images.length;
        } else {
          // For smaller galleries, only create what we need
          indices.current = centerIdx;
          if (images.length > 1) {
            indices.prev1 = (centerIdx - 1 + images.length) % images.length;
            indices.next1 = (centerIdx + 1) % images.length;
          }
          if (images.length > 3) {
            indices.prev2 = (centerIdx - 2 + images.length) % images.length;
            indices.next2 = (centerIdx + 2) % images.length;
          }
        }
        
        // Create elements for each position
        Object.keys(indices).forEach(position => {
          const idx = indices[position];
          const meta = images[idx];
          if (!meta) return;
          
          const originalSrc = meta.SourceFile || meta.src || meta.FileName;
          const cleanOriginalSrc = originalSrc.replace(/^\.\//, "");
          const displaySrc = getDisplaySource(meta, false);
          const isPicked = picks.has(meta._imageId);
          const isRejected = rejects.has(meta._imageId);
          
          if (isVideoFile(cleanOriginalSrc)) {
            // Skip creating adjacent video elements - videos load on demand only
            console.log(`📹 Skipping adjacent video element for ${position} (index ${idx}) - videos load on demand`);
          } else {
            // Create image element  
            const img = document.createElement("img");
            img.src = displaySrc;
            img.style.position = "absolute";
            img.style.top = "0";
            img.style.left = "0";
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "contain";
            img.style.zIndex = position === 'current' ? "100" : "50";
            // In thumbnail mode, hide all elements initially; in full screen mode, show current
            img.style.opacity = (position === 'current' && mode !== 'thumbs') ? "1" : "0";
            img.classList.toggle("picked", isPicked);
            img.classList.toggle("rejected", isRejected);
            img.dataset.imageIndex = idx;
            img.dataset.position = position;
            
            adjacentImages[position] = img;
            bigimgWrap.appendChild(img);
            
            console.log(`🖼️ Created image element for ${position} (index ${idx})`);
          }
        });
        
        // Hide the main bigimg since we're using adjacent elements for images
        // Keep bigvideo available for video playback when needed
        bigimg.style.display = "none";
      }
      
      function clearAdjacentElements() {
        /**Clear all adjacent image/video elements*/
        Object.values(adjacentImages).forEach(img => {
          if (img && img.parentNode) {
            img.parentNode.removeChild(img);
          }
        });
        Object.values(adjacentVideos).forEach(video => {
          if (video && video.parentNode) {
            video.parentNode.removeChild(video);
          }
        });
        
        // Reset references
        adjacentImages = {
          prev2: null, prev1: null, current: null, next1: null, next2: null
        };
        adjacentVideos = {
          prev2: null, prev1: null, current: null, next1: null, next2: null
        };
      }
      
      function switchToAdjacentImage(direction) {
        /**Switch to adjacent image instantly using pre-created DOM elements - IMAGES ONLY*/
        if (!images || images.length === 0) return false;
        
        const newIndex = (current + direction + images.length) % images.length;
        const targetMeta = images[newIndex];
        const targetSrc = targetMeta?.SourceFile || targetMeta?.src || targetMeta?.FileName || '';
        
        // If target is a video, return false to use normal loadImage
        if (isVideoFile(targetSrc)) {
          console.log(`📹 Target is video, using normal load instead of adjacent switch`);
          return false;
        }
        
        const targetPosition = direction > 0 ? 'next1' : 'prev1';
        const targetImg = adjacentImages[targetPosition];
        
        if (!targetImg) {
          console.log(`⚠️ No adjacent image element found for ${targetPosition}`);
          return false;
        }
        
        // Hide all elements by setting opacity and lowering z-index
        Object.values(adjacentImages).forEach(img => {
          if (img) {
            img.style.opacity = "0";
            img.style.zIndex = "50";
          }
        });
        
        // Show target image element instantly by bringing it to front
        targetImg.style.opacity = "1";
        targetImg.style.zIndex = "100";
        
        // Hide video element when switching to image
        bigvideo.style.display = "none";
        
        console.log(`⚡ Instantly switched to image ${targetImg.dataset.imageIndex}`);
        
        // Update status indicator dot for the new current image
        const newCurrentIndex = (current + direction + images.length) % images.length;
        if (images[newCurrentIndex]) {
          const imageId = images[newCurrentIndex]._imageId;
          const isPicked = picks.has(imageId);
          const isRejected = rejects.has(imageId);
          
          const statusIndicator = document.getElementById('statusIndicator');
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
        }
        
        return true;
      }
      
      function handleArrow(dir, isShiftHeld = false) {
        if (mode === "thumbs") {
          // Get the most recent selected thumbnail (highest index)
          const currentSelection = selectedThumbnails.size > 0 ? 
            Math.max(...Array.from(selectedThumbnails)) : 0;
          
          const newIndex = (currentSelection + dir + images.length) % images.length;
          
          if (isShiftHeld) {
            // Add to selection (range from current to new)
            const start = Math.min(currentSelection, newIndex);
            const end = Math.max(currentSelection, newIndex);
            for (let i = start; i <= end; i++) {
              selectedThumbnails.add(i);
            }
          } else {
            // Move selection to new index
            selectedThumbnails.clear();
            selectedThumbnails.add(newIndex);
          }
          
          current = newIndex;
          updateSelectionDisplay();
          updateStatusIndicator();
          scrollThumbIntoView(newIndex);
          loadSidebar(newIndex).catch(console.error);
          
          // Pre-create adjacent images for instant full screen launch
          createAdjacentImageElements(newIndex);
          
          // Restart preloading from new selection
          restartPreloadingFromSelection();
        } else {
          // Full screen mode navigation with instant switching
          const newCurrent = (current + dir + images.length) % images.length;
          
          // Try instant switch using pre-created adjacent elements
          const instantSwitch = switchToAdjacentImage(dir);
          
          if (instantSwitch) {
            // Successfully switched instantly, now update state and recreate adjacent elements
            current = newCurrent;
            selectedThumbnails.clear();
            selectedThumbnails.add(current);
            
            // Recreate adjacent elements for new position (with small delay to let instant switch show)
            setTimeout(() => {
              createAdjacentImageElements(current);
              loadFacesForCurrentImage();
            }, 50);
          } else {
            // Fallback to regular loading if instant switch failed
            current = newCurrent;
            selectedThumbnails.clear();
            selectedThumbnails.add(current);
            loadImage(current);
          }
          
          loadSidebar(current).catch(console.error);
          
          // Restart preloading from new selection
          restartPreloadingFromSelection();
        }
      }
      
      function handleVerticalArrow(dir, isShiftHeld = false) {
        // Only work in thumbnail mode
        if (mode !== "thumbs") {
          return;
        }
        
        // Calculate the number of columns in the grid
        const thumbGrid = document.querySelector('.thumb-grid');
        if (!thumbGrid) return;
        
        const thumbCells = thumbGrid.querySelectorAll('.thumb-cell');
        if (thumbCells.length === 0) return;
        
        // Get grid computed style to determine columns
        const gridStyle = window.getComputedStyle(thumbGrid);
        const gridColumns = gridStyle.gridTemplateColumns.split(' ').length;
        
        // Get current selection
        const currentSelection = selectedThumbnails.size > 0 ? 
          Math.max(...Array.from(selectedThumbnails)) : 0;
        
        // Calculate new index (up = -columns, down = +columns)
        const newIndex = currentSelection + (dir * gridColumns);
        
        // Make sure we stay within bounds
        if (newIndex < 0 || newIndex >= images.length) {
          return;
        }
        
        if (isShiftHeld) {
          // Add to selection (range from current to new)
          const start = Math.min(currentSelection, newIndex);
          const end = Math.max(currentSelection, newIndex);
          for (let i = start; i <= end; i++) {
            selectedThumbnails.add(i);
          }
        } else {
          // Move selection to new index
          selectedThumbnails.clear();
          selectedThumbnails.add(newIndex);
        }
        
        current = newIndex;
        updateSelectionDisplay();
        updateStatusIndicator();
        scrollThumbIntoView(newIndex);
        loadSidebar(newIndex).catch(console.error);
      }
      
      let selectedGalleryIndex = -1; // Track which gallery is highlighted during navigation
      let gallerySelectorFocused = false; // Track if gallery selector has keyboard focus
      
      function handleGalleryNavigation(dir) {
        const galleryItems = document.querySelectorAll('.gallery-item');
        if (galleryItems.length === 0) return;
        
        // Hide thumbnail highlights while navigating galleries
        hideThumbnailHighlights();
        
        // Initialize selection if not set
        if (selectedGalleryIndex === -1) {
          selectedGalleryIndex = 0;
        } else {
          // Move selection
          selectedGalleryIndex += dir;
          
          // Wrap around
          if (selectedGalleryIndex < 0) {
            selectedGalleryIndex = galleryItems.length - 1;
          } else if (selectedGalleryIndex >= galleryItems.length) {
            selectedGalleryIndex = 0;
          }
        }
        
        // Update visual highlighting
        galleryItems.forEach((item, index) => {
          // Clear all selection classes first
          item.classList.remove('keyboard-selected', 'gallery-focused');
          
          if (index === selectedGalleryIndex) {
            if (item.classList.contains('active')) {
              // If this is the active gallery, use special focused styling
              item.classList.add('gallery-focused');
            } else {
              // Regular purple highlighting for non-active galleries
              item.classList.add('keyboard-selected');
            }
          }
        });
        
        // Scroll the selected gallery into view
        galleryItems[selectedGalleryIndex].scrollIntoView({
          behavior: 'smooth',
          block: 'nearest'
        });
      }
      
      // Store thumbnail selection state for restoration
      let savedThumbnailSelection = new Set();
      
      function hideThumbnailHighlights() {
        // Save current selection state before hiding
        savedThumbnailSelection.clear();
        const thumbCells = document.querySelectorAll('.thumb-cell.selected');
        thumbCells.forEach((cell, index) => {
          const thumbIndex = parseInt(cell.dataset.index);
          if (!isNaN(thumbIndex)) {
            savedThumbnailSelection.add(thumbIndex);
          }
        });
        
        // Clear thumbnail selection visual highlights
        const allThumbCells = document.querySelectorAll('.thumb-cell');
        allThumbCells.forEach(cell => {
          cell.classList.remove('selected');
        });
      }
      
      function restoreThumbnailHighlights() {
        // Restore previously saved thumbnail selections
        if (savedThumbnailSelection.size > 0) {
          const thumbCells = document.querySelectorAll('.thumb-cell');
          thumbCells.forEach(cell => {
            const thumbIndex = parseInt(cell.dataset.index);
            if (savedThumbnailSelection.has(thumbIndex)) {
              cell.classList.add('selected');
            }
          });
        }
      }
      
      function selectGalleryByIndex(index) {
        const galleryItems = document.querySelectorAll('.gallery-item');
        if (index >= 0 && index < galleryItems.length) {
          const galleryItem = galleryItems[index];
          const galleryPath = galleryItem.dataset.galleryPath;
          const galleryName = galleryItem.textContent.trim();
          
          // Clear keyboard selection styling and focus
          clearGalleryFocus();
          
          // Load the gallery
          loadGallery(galleryPath, galleryName);
        }
      }
      
      function focusGallerySelector() {
        // Validate gallery selector exists and is visible
        const gallerySelector = document.getElementById('gallery-selector');
        if (!gallerySelector || !gallerySelectorOpen) {
          console.warn('Cannot focus gallery selector: not found or not visible');
          return;
        }
        
        gallerySelectorFocused = true;
        
        // Add visual focus indicator
        gallerySelector.classList.add('focused');
        
        // Find current active gallery and highlight it, or start with first gallery
        const galleryItems = document.querySelectorAll('.gallery-item');
        if (galleryItems.length === 0) {
          console.warn('No gallery items found');
          return;
        }
        
        const activeGallery = document.querySelector('.gallery-item.active');
        
        if (activeGallery) {
          // If there's an active gallery, highlight it with special styling
          selectedGalleryIndex = Array.from(galleryItems).indexOf(activeGallery);
          activeGallery.classList.add('gallery-focused');
        } else {
          // Start with first gallery if no active gallery
          selectedGalleryIndex = 0;
          if (galleryItems.length > 0) {
            galleryItems[0].classList.add('keyboard-selected');
          }
        }
        
        // Hide thumbnail highlights (saves state for restoration)
        hideThumbnailHighlights();
        
        // Gallery selector is now focused
      }
      
      function clearGalleryFocus() {
        gallerySelectorFocused = false;
        selectedGalleryIndex = -1;
        
        // Remove visual focus indicator
        const gallerySelector = document.getElementById('gallery-selector');
        if (gallerySelector) {
          gallerySelector.classList.remove('focused');
        }
        
        // Clear keyboard selection styling
        document.querySelectorAll('.gallery-item.keyboard-selected').forEach(item => {
          item.classList.remove('keyboard-selected');
        });
        
        // Clear focused active gallery styling
        document.querySelectorAll('.gallery-item.gallery-focused').forEach(item => {
          item.classList.remove('gallery-focused');
        });
        
        // Restore thumbnail highlights if we're not switching galleries
        if (!gallerySelectorOpen) {
          restoreThumbnailHighlights();
        }
        
        // Gallery selector focus cleared
      }
      
      function enterZoom() {
        // Don't allow zoom for videos
        if (!images[current] || isVideoFile(images[current].SourceFile || images[current].src || images[current].FileName)) {
          return;
        }
        
        // Get the current visible adjacent image
        const currentImg = adjacentImages.current;
        if (!currentImg) {
          console.log('No current image found for zoom mode');
          return;
        }
        
        mode = "zoom";
        
        // Apply zoom styling to the current adjacent image
        currentImg.classList.add("pixelzoom");
        currentImg.style.maxWidth = "none";
        currentImg.style.maxHeight = "none";
        currentImg.style.width = "auto";
        currentImg.style.height = "auto";
        currentImg.style.cursor = "grab";
        currentImg.style.background = "#222";
        currentImg.style.boxSizing = "border-box";
        currentImg.style.zIndex = "150"; // Higher than normal images
        
        // Add mouse panning using the working logic from cull tool
        enableSingleImagePanning(currentImg);
        
        // Refresh faces (will hide them in zoom mode)
        loadFacesForCurrentImage();
      }
      function exitZoom() {
        mode = "fit";
        
        // Get the current visible adjacent image and reset zoom styling
        const currentImg = adjacentImages.current;
        if (currentImg) {
          currentImg.classList.remove("pixelzoom");
          currentImg.style.maxWidth = "100%";
          currentImg.style.maxHeight = "100%";
          currentImg.style.width = "100%";
          currentImg.style.height = "100%";
          currentImg.style.cursor = "";
          currentImg.style.background = "";
          currentImg.style.boxSizing = "";
          currentImg.style.left = "0px";
          currentImg.style.top = "0px";
          currentImg.style.zIndex = "100"; // Back to normal z-index
        }
        
        // Remove mouse panning
        disableSingleImagePanning();
        
        // Refresh faces (will show them again in fit mode)
        loadFacesForCurrentImage();
      }
      
      let singleImagePanHandler = null;
      
      function enableSingleImagePanning(targetImg = null) {
        const container = document.getElementById('singleview');
        const img = targetImg || bigimg;
        
        singleImagePanHandler = (e) => {
          if (!img || !img.naturalWidth) return;
          
          const rect = container.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width;
          const y = (e.clientY - rect.top) / rect.height;
          const maxX = Math.max(0, img.naturalWidth - rect.width);
          const maxY = Math.max(0, img.naturalHeight - rect.height);
          const ox = -maxX * x;
          const oy = -maxY * y;
          
          img.style.left = ox + "px";
          img.style.top = oy + "px";
        };
        
        container.addEventListener('mousemove', singleImagePanHandler);
      }
      
      function disableSingleImagePanning() {
        const container = document.getElementById('singleview');
        if (singleImagePanHandler) {
          container.removeEventListener('mousemove', singleImagePanHandler);
          singleImagePanHandler = null;
        }
      }
      function toggleSidebar() {
        sidebarOpen = !sidebarOpen;
        sidebar.classList.toggle("visible", sidebarOpen);
      }
      
      function togglePick() {
        // Toggle pick status for all selected thumbnails
        if (!currentGallery) return;
        
        const galleryName = getGalleryNameFromPath(currentGallery);
        const selectedIndices = selectedThumbnails.size > 0 ? Array.from(selectedThumbnails) : [current];
        
        // Determine if we're adding or removing (based on first selected item)
        const firstIndex = selectedIndices[0];
        const firstImageId = images[firstIndex]._imageId;
        const shouldAdd = !picks.has(firstImageId);
        
        selectedIndices.forEach(index => {
          if (images[index]) {
            const imageId = images[index]._imageId;
            
            if (shouldAdd) {
              picks.add(imageId);
            } else {
              picks.delete(imageId);
            }
          }
        });
        
        updatePickClasses();
        
        // Auto-save picks
        autoSavePicks();
      }
      
      async function autoSavePicks() {
        if (picks.size === 0) {
          // If no picks, save empty array to clear the file
          await savePicksToAPI([]);
          return;
        }
        
        const picksList = Array.from(picks);
        await savePicksToAPI(picksList);
      }
      
      async function savePicksToAPI(picksList) {
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/save-picks`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({picks: picksList})
          });
          
          if (response.ok) {
            console.log(`✅ Auto-saved ${picksList.length} picks`);
          } else {
            console.error('❌ Failed to auto-save picks');
          }
        } catch (error) {
          console.error('❌ Error auto-saving picks:', error);
        }
      }
      
      function selectThumbnail(index, isShiftClick = false, isToggleClick = false) {
        if (!images[index]) return;
        
        if (isShiftClick && selectedThumbnails.size > 0) {
          // Range selection
          const existingSelection = Array.from(selectedThumbnails);
          const lastSelected = Math.max(...existingSelection);
          const start = Math.min(lastSelected, index);
          const end = Math.max(lastSelected, index);
          
          // Add range to selection
          for (let i = start; i <= end; i++) {
            selectedThumbnails.add(i);
          }
        } else if (isToggleClick) {
          // Toggle selection - add if not selected, remove if selected
          if (selectedThumbnails.has(index)) {
            selectedThumbnails.delete(index);
            // If we removed the current item and there are other selections, set current to the last remaining
            if (selectedThumbnails.size > 0 && current === index) {
              current = Math.max(...Array.from(selectedThumbnails));
            }
          } else {
            selectedThumbnails.add(index);
            current = index;
          }
        } else {
          // Single selection - clear previous
          selectedThumbnails.clear();
          selectedThumbnails.add(index);
          current = index;
        }
        
        updateSelectionDisplay();
        updateStatusIndicator();
        
        // Only load sidebar and preload if we have a valid current selection
        if (selectedThumbnails.size > 0) {
          loadSidebar(current).catch(console.error);
          
          // Pre-create adjacent images for instant full screen launch
          createAdjacentImageElements(current);
          
          // Restart preloading from new selection
          restartPreloadingFromSelection();
        }
      }
      
      function getGalleryNameFromPath(galleryPath) {
        // Extract gallery name from path like "Hard Link Galleries/Gower Holiday/image_data.json"
        const parts = galleryPath.split('/');
        return parts[parts.length - 2]; // Get the folder name before image_data.json
      }
      
      function getFileName(path) {
        return path.split('/').pop();
      }
      
      function updatePickClasses() {
        if (!currentGallery) return;
        
        const galleryName = getGalleryNameFromPath(currentGallery);
        
        Array.from(document.querySelectorAll(".thumb-cell")).forEach((el, i) => {
          const imageId = images[i]._imageId;
          el.classList.toggle("picked", picks.has(imageId));
          el.classList.toggle("rejected", rejects.has(imageId));
        });
        
        // Update full screen mode if active
        if (mode === "fit" || mode === "zoom") {
          const currentImageId = images[current]._imageId;
          const isPicked = picks.has(currentImageId);
          const isRejected = rejects.has(currentImageId);
          
          // Update adjacent images/videos
          if (adjacentImages.current) {
            adjacentImages.current.classList.toggle("picked", isPicked);
            adjacentImages.current.classList.toggle("rejected", isRejected);
          }
          if (adjacentVideos.current) {
            adjacentVideos.current.classList.toggle("picked", isPicked);
            adjacentVideos.current.classList.toggle("rejected", isRejected);
          }
          
          // Update status indicator dot
          const statusIndicator = document.getElementById('statusIndicator');
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
        }
        
      }
      
      function toggleReject() {
        // Toggle reject status for all selected thumbnails
        if (!currentGallery) return;
        
        const galleryName = getGalleryNameFromPath(currentGallery);
        const selectedIndices = selectedThumbnails.size > 0 ? Array.from(selectedThumbnails) : [current];
        
        // Determine if we're adding or removing (based on first selected item)
        const firstIndex = selectedIndices[0];
        const firstImageId = images[firstIndex]._imageId;
        const shouldAdd = !rejects.has(firstImageId);
        
        selectedIndices.forEach(index => {
          if (images[index]) {
            const imageId = images[index]._imageId;
            
            if (shouldAdd) {
              rejects.add(imageId);
              // Remove from picks if it was picked
              picks.delete(imageId);
            } else {
              rejects.delete(imageId);
            }
          }
        });
        
        updatePickClasses();
        
        // Auto-save both picks and rejects (since reject can remove picks)
        autoSavePicks();
        autoSaveRejects();
      }
      
      async function autoSaveRejects() {
        if (rejects.size === 0) {
          // If no rejects, save empty array to clear the file
          await saveRejectsToAPI([]);
          return;
        }
        
        const rejectsList = Array.from(rejects);
        await saveRejectsToAPI(rejectsList);
      }
      
      async function saveRejectsToAPI(rejectsList) {
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/save-rejects`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({rejects: rejectsList})
          });
          
          if (response.ok) {
            console.log(`✅ Auto-saved ${rejectsList.length} rejects`);
          } else {
            console.error('❌ Failed to auto-save rejects');
          }
        } catch (error) {
          console.error('❌ Error auto-saving rejects:', error);
        }
      }
      
      async function loadPicksFromAPI() {
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/load-picks`);
          if (response.ok) {
            const data = await response.json();
            if (data.picks && Array.isArray(data.picks)) {
              picks.clear();
              data.picks.forEach(imageId => picks.add(imageId));
              console.log(`✅ Loaded ${picks.size} picks from server`);
              return true;
            }
          } else if (response.status === 404) {
            // No picks file exists yet - this is normal
            console.log('ℹ️ No existing picks file found (this is normal for new installations)');
            return true;
          } else {
            console.warn('⚠️ Failed to load picks from server');
          }
        } catch (error) {
          console.error('❌ Error loading picks:', error);
        }
        return false;
      }
      
      async function loadRejectsFromAPI() {
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/load-rejects`);
          if (response.ok) {
            const data = await response.json();
            if (data.rejects && Array.isArray(data.rejects)) {
              rejects.clear();
              data.rejects.forEach(imageId => rejects.add(imageId));
              console.log(`✅ Loaded ${rejects.size} rejects from server`);
              return true;
            }
          } else if (response.status === 404) {
            // No rejects file exists yet - this is normal
            console.log('ℹ️ No existing rejects file found (this is normal for new installations)');
            return true;
          } else {
            console.warn('⚠️ Failed to load rejects from server');
          }
        } catch (error) {
          console.error('❌ Error loading rejects:', error);
        }
        return false;
      }
      
      async function initializePicksAndRejects() {
        console.log('🔄 Loading picks and rejects from server...');
        await Promise.all([
          loadPicksFromAPI(),
          loadRejectsFromAPI()
        ]);
        // Update visual indicators after loading
        updatePickClasses();
        console.log(`📊 Initialization complete: ${picks.size} picks, ${rejects.size} rejects`);
      }
      
      function enterCullMode() {
        if (selectedThumbnails.size < 2) {
          alert("Select at least 2 images to enter cull mode");
          return;
        }
        
        // Clear all cull images first to prevent flash of previous content
        document.getElementById('cull-main-img').src = '';
        document.getElementById('cull-candidate-img').src = '';
        document.getElementById('cull-current-img').src = '';
        
        cullMode = true;
        cullImages = Array.from(selectedThumbnails).map(i => ({
          index: i,
          src: images[i].SourceFile || images[i].src || images[i].FileName,
          displaySrc: getDisplaySource(images[i]),
          _imageId: images[i]._imageId
        }));
        cullCurrent = 0;
        cullPick = -1; // -1 = no candidate, >=0 = candidate index
        
        // Auto-hide both panels for cull mode
        const sidebar = document.getElementById('sidebar');
        const gallerySelector = document.getElementById('gallery-selector');
        sidebar.classList.remove('visible');
        gallerySelector.classList.remove('visible');
        sidebarOpen = false;
        gallerySelectorOpen = false;
        
        // Show cull UI
        document.getElementById('cull-strip').classList.add('visible');
        
        // Hide main thumbnail grid and show single view
        thumbgrid.style.display = 'none';
        
        renderCullStrip();
        showCullSingleImage();
        updateTouchToolbar();
      }
      
      function exitCullMode(markForDeletion = false) {
        if (!cullMode) return;
        
        if (markForDeletion && cullPick >= 0) {
          // Mark all non-candidates as rejected
          const galleryName = getGalleryNameFromPath(currentGallery);
          
          cullImages.forEach((img, i) => {
            if (i !== cullPick) {
              const imageId = img._imageId;
              rejects.add(imageId);
              picks.delete(imageId); // Remove from picks if it was picked
            }
          });
          
          console.log(`Marked ${cullImages.length - 1} images for deletion, kept candidate`);
          
          // Update pick/reject classes on thumbnails
          updatePickClasses();
          
          // Auto-save both picks and rejects after cull operation
          autoSavePicks();
          autoSaveRejects();
        }
        
        // Exit zoom mode if active
        if (cullZoomMode) {
          exitCullZoom();
        }
        
        // Reset cull mode
        cullMode = false;
        cullImages = [];
        cullCurrent = 0;
        cullPick = -1;
        
        // Hide cull UI
        document.getElementById('cull-strip').classList.remove('visible');
        document.getElementById('cull-comparison').classList.remove('visible');
        document.getElementById('cull-single').style.display = 'none';
        
        // Show main thumbnail grid
        thumbgrid.style.display = 'grid';
        
        // Update display
        updatePickClasses();
        updateSelectionDisplay();
        updateTouchToolbar();
      }
      
      function renderCullStrip() {
        const strip = document.getElementById('cull-strip');
        strip.innerHTML = '';
        
        cullImages.forEach((img, i) => {
          const thumb = document.createElement('img');
          // Use thumbnail if available, otherwise use display source (proxy for HEIC)
          const imageData = images[img.index];
          if (imageData._thumbnail) {
            thumb.src = imageData._thumbnail;
          } else {
            thumb.src = img.displaySrc;
          }
          thumb.className = 'cull-thumb';
          if (i === cullCurrent) thumb.classList.add('active');
          if (i === cullPick) thumb.classList.add('pick');
          
          thumb.addEventListener('click', () => {
            cullCurrent = i;
            renderCullStrip();
            renderCullComparison();
          });
          
          strip.appendChild(thumb);
        });
      }
      
      function showCullSingleImage() {
        // Show single image full screen with strip at bottom
        const mainImg = document.getElementById('cull-main-img');
        mainImg.src = cullImages[cullCurrent].displaySrc;
        
        // Ensure image is in fitted mode (not zoomed)
        resetCullImageToFitted(mainImg);
        
        // Show single view, hide comparison view
        document.getElementById('cull-single').style.display = 'flex';
        document.getElementById('cull-comparison').classList.remove('visible');
      }
      
      function resetCullImageToFitted(img) {
        // Reset image to fitted mode
        img.style.width = '';
        img.style.height = '';
        img.style.left = '';
        img.style.top = '';
        img.style.position = '';
      }
      
      function renderCullComparison() {
        if (cullPick < 0) {
          showCullSingleImage();
          return;
        }
        
        // Show two-up comparison: candidate on left, current on right
        document.getElementById('cull-single').style.display = 'none';
        document.getElementById('cull-comparison').classList.add('visible');
        
        const leftImg = document.getElementById('cull-candidate-img');
        const rightImg = document.getElementById('cull-current-img');
        
        leftImg.src = cullImages[cullPick].displaySrc;
        rightImg.src = cullImages[cullCurrent].displaySrc;
        
        // Ensure images are in fitted mode (not zoomed) unless we're in zoom mode
        if (!cullZoomMode) {
          resetCullImageToFitted(leftImg);
          resetCullImageToFitted(rightImg);
        }
      }
      
      function handleCullPick() {
        if (!cullMode) return;
        
        if (cullPick < 0) {
          // No candidate yet - set current as candidate and enter two-up mode
          cullPick = cullCurrent;
          // Move to next image for comparison
          cullCurrent = (cullCurrent + 1) % cullImages.length;
          if (cullCurrent === cullPick) {
            cullCurrent = (cullCurrent + 1) % cullImages.length; // Skip if wrapped to same
          }
        } else {
          // In two-up mode - promote right image to candidate
          cullPick = cullCurrent;
        }
        
        renderCullStrip();
        renderCullComparison();
      }
      
      function handleCullNavigation(direction) {
        if (!cullMode) return;
        
        if (cullPick < 0) {
          // Single image mode - navigate through all images
          cullCurrent = (cullCurrent + direction + cullImages.length) % cullImages.length;
        } else {
          // Two-up mode - navigate through non-candidate images on the right
          do {
            cullCurrent = (cullCurrent + direction + cullImages.length) % cullImages.length;
          } while (cullCurrent === cullPick && cullImages.length > 1);
        }
        
        renderCullStrip();
        renderCullComparison();
      }
      
      let cullZoomMode = false;
      let cullLastPan = { x: 0, y: 0 }; // Store pan offsets like working version
      
      function enterCullZoom() {
        if (!cullMode) return;
        
        cullZoomMode = true;
        
        if (cullPick < 0) {
          // Single image mode
          const singleContainer = document.getElementById('cull-single');
          singleContainer.classList.add('full');
          
          const container = document.querySelector('#cull-single .cull-img-container');
          const img = document.getElementById('cull-main-img');
          
          applyCullZoom(img);
          enableCullPan([container]);
        } else {
          // Two-up mode
          const comparison = document.getElementById('cull-comparison');
          comparison.classList.add('full');
          
          const candidateImg = document.getElementById('cull-candidate-img');
          const currentImg = document.getElementById('cull-current-img');
          const containers = document.querySelectorAll('#cull-comparison .cull-img-container');
          
          applyCullZoom(candidateImg);
          applyCullZoom(currentImg);
          enableCullPan(containers);
        }
        
        // Zoom mode is now active
      }
      
      function applyCullZoom(img) {
        if (img.complete && img.naturalWidth > 0) {
          img.style.width = img.naturalWidth + 'px';
          img.style.height = img.naturalHeight + 'px';
          img.style.left = cullLastPan.x + 'px';
          img.style.top = cullLastPan.y + 'px';
        } else {
          img.onload = () => {
            img.style.width = img.naturalWidth + 'px';
            img.style.height = img.naturalHeight + 'px';
            img.style.left = cullLastPan.x + 'px';
            img.style.top = cullLastPan.y + 'px';
          };
        }
      }
      
      function enableCullPan(containers) {
        containers.forEach((c) => {
          c.onmousemove = (e) => {
            const img = c.querySelector('img'); // Use querySelector instead of firstChild
            if (!img || !img.naturalWidth) return; // Safety check
            
            const rect = c.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            const maxX = Math.max(0, img.naturalWidth - rect.width);
            const maxY = Math.max(0, img.naturalHeight - rect.height);
            const ox = -maxX * x;
            const oy = -maxY * y;
            cullLastPan = { x: ox, y: oy }; // Store for next navigation
            
            // Apply to all images in all containers
            containers.forEach((container) => {
              const image = container.querySelector('img');
              if (image && image.style) {
                image.style.left = ox + "px";
                image.style.top = oy + "px";
              }
            });
          };
        });
      }
      
      function exitCullZoom() {
        if (!cullZoomMode) return;
        
        cullZoomMode = false;
        
        // Remove full class and reset containers
        const comparison = document.getElementById('cull-comparison');
        const singleContainer = document.getElementById('cull-single');
        comparison.classList.remove('full');
        singleContainer.classList.remove('full');
        
        // Reset all images to fitted mode
        const allImages = [
          document.getElementById('cull-main-img'),
          document.getElementById('cull-candidate-img'),
          document.getElementById('cull-current-img')
        ];
        
        allImages.forEach(img => {
          if (img) {
            img.style.width = '';
            img.style.height = '';
            img.style.left = '';
            img.style.top = '';
          }
        });
        
        // Remove mouse listeners
        const containers = document.querySelectorAll('.cull-img-container');
        containers.forEach(c => {
          c.onmousemove = null;
        });
        
      }
      
      
      function updateSelectionDisplay() {
        Array.from(document.querySelectorAll(".thumb-cell")).forEach((el, i) => {
          el.classList.toggle("highlight-selected", selectedThumbnails.has(i));
        });
      }
      
      function updateStatusIndicator() {
        const statusIndicator = document.getElementById('statusIndicator');
        if (statusIndicator && images[current]) {
          const imageId = images[current]._imageId;
          const isPicked = picks.has(imageId);
          const isRejected = rejects.has(imageId);
          statusIndicator.classList.toggle("picked", isPicked);
          statusIndicator.classList.toggle("rejected", isRejected);
        }
      }
      
      function togglePicksList() {
        const existing = document.getElementById('picks-display');
        if (existing) {
          existing.remove();
          return;
        }
        
        if (picks.size === 0) {
          alert("No picks selected");
          return;
        }
        
        const picksList = Array.from(picks);
        const picksDisplay = document.createElement('div');
        picksDisplay.style.cssText = `
          position: fixed;
          top: 20px;
          left: 20px;
          right: 20px;
          background: #222;
          color: #0f0;
          z-index: 2000;
          max-width: 700px;
          margin: 0 auto;
          padding: 24px 16px;
          font-size: 15px;
          box-shadow: 0 2px 16px #0008;
          white-space: pre-wrap;
          font-family: monospace;
          border-radius: 8px;
        `;
        
        // Show raw JSON as before
        const jsonText = JSON.stringify(picksList, null, 2);
        picksDisplay.textContent = jsonText;
        picksDisplay.id = 'picks-display';
        
        // Add save button
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save to picks.json';
        saveButton.style.cssText = `
          position: absolute;
          top: 10px;
          right: 10px;
          background: #0066cc;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 14px;
          z-index: 3000;
        `;
        
        saveButton.addEventListener('click', async () => {
          try {
            const response = await fetch(`http://${window.location.hostname}:8001/api/save-picks`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({picks: picksList})
            });
            
            if (response.ok) {
              saveButton.textContent = '✅ Saved!';
              saveButton.style.background = '#00aa00';
              setTimeout(() => {
                saveButton.textContent = 'Save to picks.json';
                saveButton.style.background = '#0066cc';
              }, 2000);
            } else {
              saveButton.textContent = '❌ Failed';
              saveButton.style.background = '#cc0000';
            }
          } catch (error) {
            console.error('Save error:', error);
            saveButton.textContent = '❌ Error';
            saveButton.style.background = '#cc0000';
          }
        });
        
        picksDisplay.appendChild(saveButton);
        document.body.appendChild(picksDisplay);
        
        // Auto-select the text
        setTimeout(() => {
          const range = document.createRange();
          range.selectNodeContents(picksDisplay);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }, 10);
        
        // Click to close
        picksDisplay.addEventListener('click', () => {
          picksDisplay.remove();
        });
        
        // Close on escape or clear picks with C
        const closeHandler = (e) => {
          const current = document.getElementById('picks-display');
          if (!current) return;
          
          if (e.key === 'q' || e.key === 'Q') {
            current.remove();
            document.removeEventListener('keydown', closeHandler);
          } else if (e.key === 'c' || e.key === 'C') {
            if (confirm(`Clear all ${picks.size} picks?`)) {
              picks.clear();
              updatePickClasses();
              current.remove();
              document.removeEventListener('keydown', closeHandler);
            }
          }
        };
        document.addEventListener('keydown', closeHandler);
      }
      
      function toggleGallerySelector() {
        gallerySelectorOpen = !gallerySelectorOpen;
        document.getElementById('gallery-selector').classList.toggle('visible', gallerySelectorOpen);
      }
      
      // Cache for people list
      let peopleCache = null;
      
      async function loadPeopleList() {
        /**Load list of all people for dropdown*/
        if (peopleCache) return peopleCache;
        
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/people`);
          if (response.ok) {
            peopleCache = await response.json();
            return peopleCache;
          }
        } catch (error) {
          console.error('Failed to load people list:', error);
        }
        return [];
      }
      
      async function assignFaceToPerson(faceId, personId) {
        /**Assign a face to a person via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/assign-face`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              face_id: faceId,
              person_id: personId
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('Face assigned successfully:', result);
            return true;
          } else {
            console.error('Failed to assign face:', response.statusText);
            return false;
          }
        } catch (error) {
          console.error('Error assigning face:', error);
          return false;
        }
      }
      
      async function ignoreFace(faceId) {
        /**Mark a face as ignored via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/ignore-face`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              face_id: faceId
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('Face ignored successfully:', result);
            return true;
          } else {
            console.error('Failed to ignore face:', response.statusText);
            return false;
          }
        } catch (error) {
          console.error('Error ignoring face:', error);
          return false;
        }
      }
      
      async function createUnidentifiedFaceControls(label, face) {
        /**Create dropdown and ignore button for unidentified faces*/
        const people = await loadPeopleList();
        
        // Create container for controls
        label.innerHTML = '';
        label.style.background = 'rgba(255, 80, 80, 0.9)';
        label.style.padding = '4px';
        label.style.minWidth = '120px';
        label.style.textAlign = 'left';
        
        // Face ID display
        const faceInfo = document.createElement('div');
        faceInfo.textContent = `ID:${face.id} (${(face.confidence * 100).toFixed(0)}%)`;
        faceInfo.style.fontSize = '10px';
        faceInfo.style.marginBottom = '2px';
        label.appendChild(faceInfo);
        
        // Dropdown for people
        const dropdown = document.createElement('select');
        dropdown.style.fontSize = '10px';
        dropdown.style.width = '100%';
        dropdown.style.marginBottom = '2px';
        
        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'Choose action...';
        dropdown.appendChild(defaultOption);
        
        // Add ignore option
        const ignoreOption = document.createElement('option');
        ignoreOption.value = 'IGNORE';
        ignoreOption.textContent = '🚫 Ignore this face';
        dropdown.appendChild(ignoreOption);
        
        // Add separator
        const separatorOption = document.createElement('option');
        separatorOption.disabled = true;
        separatorOption.textContent = '─────────────────';
        dropdown.appendChild(separatorOption);
        
        // Add people options
        people.forEach(person => {
          const option = document.createElement('option');
          option.value = person.id;
          option.textContent = `${person.name} (${person.face_count})`;
          dropdown.appendChild(option);
        });
        
        // Disable keyboard shortcuts when dropdown is focused
        dropdown.addEventListener('focus', () => {
          inputFieldFocused = true;
        });
        dropdown.addEventListener('blur', () => {
          inputFieldFocused = false;
        });
        
        // Handle assignment or ignore
        dropdown.addEventListener('change', async (e) => {
          if (e.target.value) {
            dropdown.disabled = true;
            dropdown.style.opacity = '0.5';
            
            if (e.target.value === 'IGNORE') {
              // Handle ignore
              faceInfo.textContent = 'Ignoring...';
              
              const success = await ignoreFace(face.id);
              if (success) {
                // Hide the face overlay completely
                label.parentElement.style.display = 'none';
              } else {
                // Reset on failure
                dropdown.disabled = false;
                dropdown.style.opacity = '1';
                dropdown.value = '';
                faceInfo.textContent = `ID:${face.id} (${(face.confidence * 100).toFixed(0)}%)`;
                alert('Failed to ignore face. Please try again.');
              }
            } else {
              // Handle person assignment
              const personId = parseInt(e.target.value);
              const personName = people.find(p => p.id === personId)?.name;
              
              faceInfo.textContent = 'Assigning...';
              
              const success = await assignFaceToPerson(face.id, personId);
              if (success) {
                // Update label to show assignment
                label.innerHTML = `${personName} (${(face.confidence * 100).toFixed(0)}%)`;
                label.style.background = 'rgba(0, 150, 255, 0.8)'; // Blue for assigned
              } else {
                // Reset on failure
                dropdown.disabled = false;
                dropdown.style.opacity = '1';
                dropdown.value = '';
                faceInfo.textContent = `ID:${face.id} (${(face.confidence * 100).toFixed(0)}%)`;
                alert('Failed to assign face. Please try again.');
              }
            }
          }
        });
        
        label.appendChild(dropdown);
      }
      
      async function createPersonRenameControls(label, face) {
        /**Create rename input field for Person # format names*/
        // Clear label and set up container
        label.innerHTML = '';
        label.style.background = 'rgba(255, 200, 0, 0.9)'; // Yellow for renameable
        label.style.padding = '4px';
        label.style.minWidth = '120px';
        label.style.textAlign = 'left';
        
        // Face info display
        const faceInfo = document.createElement('div');
        faceInfo.textContent = `${face.person_name} (${(face.confidence * 100).toFixed(0)}%)`;
        faceInfo.style.fontSize = '10px';
        faceInfo.style.marginBottom = '2px';
        label.appendChild(faceInfo);
        
        // Create input field
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter real name...';
        input.style.fontSize = '10px';
        input.style.width = '100%';
        input.style.padding = '2px';
        input.style.border = '1px solid #ccc';
        input.style.borderRadius = '3px';
        input.style.marginBottom = '2px';
        
        // Create buttons container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '2px';
        
        // Save button
        const saveButton = document.createElement('button');
        saveButton.textContent = '✓';
        saveButton.style.fontSize = '10px';
        saveButton.style.padding = '2px 6px';
        saveButton.style.background = '#00aa00';
        saveButton.style.color = 'white';
        saveButton.style.border = 'none';
        saveButton.style.borderRadius = '3px';
        saveButton.style.cursor = 'pointer';
        saveButton.style.flex = '1';
        
        // Cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = '✗';
        cancelButton.style.fontSize = '10px';
        cancelButton.style.padding = '2px 6px';
        cancelButton.style.background = '#cc0000';
        cancelButton.style.color = 'white';
        cancelButton.style.border = 'none';
        cancelButton.style.borderRadius = '3px';
        cancelButton.style.cursor = 'pointer';
        cancelButton.style.flex = '1';
        
        // Handle save
        const handleSave = async () => {
          const newName = input.value.trim();
          if (!newName) {
            alert('Please enter a name');
            return;
          }
          
          // Disable controls
          input.disabled = true;
          saveButton.disabled = true;
          cancelButton.disabled = true;
          faceInfo.textContent = 'Renaming...';
          
          const success = await renamePersonLabel(face.person_id, newName);
          if (success) {
            // Update label to show new name
            label.innerHTML = `${newName} (${(face.confidence * 100).toFixed(0)}%)`;
            label.style.background = 'rgba(0, 150, 255, 0.8)'; // Blue for confirmed
            
            // Clear people cache to force reload
            peopleCache = null;
          } else {
            // Reset on failure
            input.disabled = false;
            saveButton.disabled = false;
            cancelButton.disabled = false;
            faceInfo.textContent = `${face.person_name} (${(face.confidence * 100).toFixed(0)}%)`;
            alert('Failed to rename person. Please try again.');
          }
        };
        
        // Handle cancel
        const handleCancel = () => {
          // Restore original label
          label.innerHTML = `${face.person_name} (${(face.confidence * 100).toFixed(0)}%)`;
          label.style.background = face.confirmed ? 'rgba(0, 150, 255, 0.8)' : 'rgba(255, 150, 0, 0.8)';
        };
        
        // Event listeners
        saveButton.addEventListener('click', handleSave);
        cancelButton.addEventListener('click', handleCancel);
        
        // Disable keyboard shortcuts when input is focused
        input.addEventListener('focus', () => {
          inputFieldFocused = true;
        });
        input.addEventListener('blur', () => {
          inputFieldFocused = false;
        });
        
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            handleSave();
          } else if (e.key === 'Escape') {
            handleCancel();
          }
        });
        
        // Assemble the controls
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        label.appendChild(input);
        label.appendChild(buttonContainer);
        
        // Focus the input
        setTimeout(() => input.focus(), 100);
      }
      
      async function renamePersonLabel(personId, newName) {
        /**Rename a person via the API*/
        try {
          console.log(`Attempting to rename person ${personId} to "${newName}"`);
          
          const response = await fetch(`http://${window.location.hostname}:8001/api/rename-person`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              person_id: personId,
              new_name: newName
            })
          });
          
          console.log('Response status:', response.status, response.statusText);
          
          if (response.ok) {
            const result = await response.json();
            console.log('Person renamed successfully:', result);
            return true;
          } else {
            // Try to get error details from response
            let errorMessage = response.statusText;
            try {
              const errorText = await response.text();
              console.error('Rename error response:', errorText);
              errorMessage = errorText || errorMessage;
            } catch (e) {
              console.error('Could not read error response:', e);
            }
            
            console.error('Failed to rename person:', errorMessage);
            alert(`Failed to rename person: ${errorMessage}`);
            return false;
          }
        } catch (error) {
          console.error('Network error renaming person:', error);
          alert(`Network error: ${error.message}`);
          return false;
        }
      }
      
      async function loadFaces(imageId) {
        /**Load face data for an image from the database API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/faces/${imageId}`);
          if (response.ok) {
            return await response.json();
          }
        } catch (error) {
          console.log('Face data not available:', error);
        }
        return [];
      }
      
      async function getImageMetadata(imageId) {
        /**Get image metadata including proxy information from API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/image-metadata/${imageId}`);
          if (response.ok) {
            return await response.json();
          }
        } catch (error) {
          console.log('Image metadata not available:', error);
        }
        return null;
      }
      
      async function switchProxyMode(imageId, useCustomProxy) {
        /**Switch between original JPG and custom proxy via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/switch-proxy`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              image_id: imageId,
              use_custom_proxy: useCustomProxy
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            return { success: true, message: result.message };
          } else {
            const error = await response.text();
            console.error('Switch proxy API error:', response.status, error);
            return { success: false, message: `API Error ${response.status}: ${error}` };
          }
        } catch (error) {
          console.error('Error switching proxy mode:', error);
          return { success: false, message: `Network error: ${error.message}` };
        }
      }
      
      async function getAvailablePresets() {
        /**Get lists of available camera standards and style presets from API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/presets`);
          if (response.ok) {
            const presets = await response.json();
            // New API returns {camera_standards: [...], style_presets: [...]}
            if (presets.camera_standards && presets.style_presets) {
              return presets;
            }
            // Fallback for old API format
            return {
              camera_standards: presets.filter(p => p.file.startsWith('Standard_')),
              style_presets: presets.filter(p => !p.file.startsWith('Standard_'))
            };
          }
        } catch (error) {
          console.log('Presets not available:', error);
        }
        return {camera_standards: [], style_presets: []};
      }
      
      async function generateRawProxy(imageId, cameraStandard, stylePreset, exposure = 0.0, quality = 95) {
        /**Generate RAW proxy with three-stage preset processing via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/generate-raw-proxy`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              image_id: imageId,
              camera_standard: cameraStandard,
              style_preset: stylePreset,
              exposure: exposure,
              quality: quality
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            return { success: true, message: result.message };
          } else {
            const error = await response.text();
            return { success: false, message: error };
          }
        } catch (error) {
          console.error('Error generating RAW proxy:', error);
          return { success: false, message: 'Network error' };
        }
      }

      async function getProxyControls(imageId) {
        /**Generate enhanced proxy controls for the sidebar*/
        const metadata = await getImageMetadata(imageId);
        if (!metadata) return "";
        
        const isRAWFile = metadata.filename && /\.(cr2|cr3|nef|arw|dng|raf|orf|rw2|raw)$/i.test(metadata.filename);
        const isVideoFile = metadata.filename && /\.(mp4|mov|avi|mkv|webm|m4v)$/i.test(metadata.filename);
        
        if (!isRAWFile && !isVideoFile) return "";
        
        // Handle video files separately
        if (isVideoFile) {
          return await getVideoProxyControls(imageId, metadata);
        }
        
        // Get available presets
        const presets = await getAvailablePresets();
        
        // Determine current state and available actions
        const isUsingCustomProxy = metadata.raw_proxy_type === 'custom_generated';
        const hasCustomProxy = metadata.has_custom_proxy;
        const hasAdjacentJPG = metadata.has_adjacent_jpg;
        
        let buttons = "";
        
        if (isUsingCustomProxy) {
          // Currently using custom proxy
          if (hasAdjacentJPG) {
            buttons += `
              <button onclick="handleProxySwitch(${imageId}, false, event)" style="
                width: 100%;
                padding: 6px;
                background: #667722;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                font-weight: 500;
                margin-bottom: 4px;
              ">📷 Use Original JPG</button>`;
          }
          
          // Add regenerate with new preset option
          if (presets.camera_standards.length > 0 || presets.style_presets.length > 0) {
            buttons += `
              <div style="margin-bottom: 6px;">
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Camera Standard:</div>
                <select id="camera-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 6px;
                ">
                  <option value="">Auto-detect from EXIF</option>
                  ${presets.camera_standards.map(preset => `<option value="${preset.path}">${preset.name}</option>`).join('')}
                </select>
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Style Preset:</div>
                <select id="style-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 4px;
                ">
                  <option value="">Default Style</option>
                  ${presets.style_presets.sort((a, b) => a.name.localeCompare(b.name)).map(preset => `<option value="${preset.path}">${preset.name}</option>`).join('')}
                </select>
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Exposure:</div>
                <div style="display: flex; align-items: center; margin-bottom: 12px;">
                  <input type="range" id="exposure-select-${imageId}" min="-1" max="1" step="0.25" value="0" 
                    oninput="updateExposureDisplay(${imageId}, this.value)" style="
                    flex: 1;
                    height: 4px;
                    background: #555;
                    border-radius: 2px;
                    outline: none;
                    margin-right: 6px;
                  ">
                  <span id="exposure-value-${imageId}" style="
                    font-size: 9px;
                    color: #ccc;
                    min-width: 35px;
                    text-align: center;
                  ">0 EV</span>
                </div>
                <button onclick="handleRawRegenerate(${imageId})" style="
                  width: 100%;
                  padding: 6px;
                  background: #cc6600;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 10px;
                  font-weight: 500;
                ">🎨 Regenerate with New Style</button>
              </div>`;
          }
        } else {
          // Currently using original JPG
          if (hasCustomProxy) {
            buttons += `
              <button onclick="handleProxySwitch(${imageId}, true, event)" style="
                width: 100%;
                padding: 6px;
                background: #cc6600;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                font-weight: 500;
                margin-bottom: 4px;
              ">🎞️ Use Existing RAW Proxy</button>`;
          }
          
          // Add generate new proxy option for ALL RAW files
          if (presets.camera_standards.length > 0 || presets.style_presets.length > 0) {
            buttons += `
              <div style="margin-bottom: 6px;">
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Camera Standard:</div>
                <select id="camera-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 6px;
                ">
                  <option value="">Auto-detect from EXIF</option>
                  ${presets.camera_standards.map(preset => `<option value="${preset.path}">${preset.name}</option>`).join('')}
                </select>
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Style Preset:</div>
                <select id="style-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 4px;
                ">
                  <option value="">Default Style</option>
                  ${presets.style_presets.map(preset => `<option value="${preset.path}">${preset.name}</option>`).join('')}
                </select>
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Exposure:</div>
                <div style="display: flex; align-items: center; margin-bottom: 12px;">
                  <input type="range" id="exposure-select-${imageId}" min="-1" max="1" step="0.25" value="0" 
                    oninput="updateExposureDisplay(${imageId}, this.value)" style="
                    flex: 1;
                    height: 4px;
                    background: #555;
                    border-radius: 2px;
                    outline: none;
                    margin-right: 6px;
                  ">
                  <span id="exposure-value-${imageId}" style="
                    font-size: 9px;
                    color: #ccc;
                    min-width: 35px;
                    text-align: center;
                  ">0 EV</span>
                </div>
                <button onclick="handleRawGenerate(${imageId})" style="
                  width: 100%;
                  padding: 6px;
                  background: #0066cc;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 10px;
                  font-weight: 500;
                ">${hasCustomProxy ? '🎨 Generate New' : '🎞️ Process RAW'} Proxy</button>
              </div>`;
          }
        }
        
        if (buttons) {
          const currentStatus = isUsingCustomProxy ? 'Custom Proxy' : (hasAdjacentJPG ? 'Original JPG' : 'RAW File');
          return `
            <div style="margin-top: 10px; padding: 6px 8px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
              <div style="font-size: 9px; font-weight: 600; margin-bottom: 4px; color: #999; text-transform: uppercase; letter-spacing: 0.5px;">RAW Processing</div>
              <div style="font-size: 10px; color: #999; margin-bottom: 6px;">
                Currently: ${currentStatus}
              </div>
              ${buttons}
            </div>`;
        }
        
        return "";
      }
      
      async function getVideoProxyControls(imageId, metadata) {
        /**Generate video proxy controls for the sidebar*/
        try {
          // Get available LUTs
          const luts = await getAvailableLUTs();
          
          // Check if video proxy exists and get current proxy type
          const proxyExists = await checkVideoProxyExists(imageId);
          const currentProxyType = await getCurrentVideoProxyType(imageId);
          const isUsingProxy = currentProxyType === 'custom_generated';
          const currentStatus = isUsingProxy ? 'Video Proxy' : 'Original Video';
          
          console.log('Debug - Video Controls:', {
            imageId,
            proxyExists,
            currentProxyType,
            isUsingProxy,
            currentStatus
          });
          
          let controls = `
            <div style="margin-top: 10px; padding: 6px 8px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
              <div style="font-size: 9px; font-weight: 600; margin-bottom: 4px; color: #999; text-transform: uppercase; letter-spacing: 0.5px;">Video Processing</div>
              <div style="font-size: 10px; color: #999; margin-bottom: 6px;">
                Currently: ${currentStatus}
              </div>`;
          
          // Add proxy switching buttons if proxy exists
          if (proxyExists) {
            controls += `
              <div style="margin-bottom: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button onclick="handleVideoProxySwitch(${imageId}, false)" style="
                  padding: 4px 6px;
                  background: ${!isUsingProxy ? '#0066cc' : '#444'};
                  color: white;
                  border: none;
                  border-radius: 3px;
                  cursor: pointer;
                  font-size: 9px;
                  font-weight: 500;
                ">📹 Original</button>
                <button onclick="handleVideoProxySwitch(${imageId}, true)" style="
                  padding: 4px 6px;
                  background: ${isUsingProxy ? '#0066cc' : '#444'};
                  color: white;
                  border: none;
                  border-radius: 3px;
                  cursor: pointer;
                  font-size: 9px;
                  font-weight: 500;
                ">🎬 Proxy</button>
              </div>`;
          }
          
          controls += `
              <div style="margin-bottom: 6px;">
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Correction LUT (.cube):</div>
                <select id="correction-lut-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 6px;
                ">
                  <option value="">No Correction LUT</option>
                  ${luts.correctionLuts.map(lut => `<option value="${lut.path}">${lut.name}</option>`).join('')}
                </select>
                
                <div style="font-size: 9px; color: #999; margin-bottom: 3px; margin-top: 8px;">Style LUT (HALDCLUT .png):</div>
                <select id="style-lut-select-${imageId}" style="
                  width: 100%;
                  padding: 4px;
                  background: #2a2a2a;
                  color: white;
                  border: 1px solid #555;
                  border-radius: 4px;
                  font-size: 10px;
                  margin-bottom: 12px;
                ">
                  <option value="">No Style LUT</option>
                  ${luts.styleLuts.map(lut => `<option value="${lut.path}">${lut.name}</option>`).join('')}
                </select>
                
                <button onclick="handleVideoProxyGenerate(${imageId})" style="
                  width: 100%;
                  padding: 6px;
                  background: #0066cc;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 10px;
                  font-weight: 500;
                ">🎬 ${proxyExists ? 'Regenerate' : 'Generate'} Video Proxy</button>
              </div>
            </div>`;
          
          return controls;
        } catch (error) {
          console.log('Error generating video proxy controls:', error);
          return "";
        }
      }
      
      async function getAvailableLUTs() {
        /**Get available LUT files from LUTS folder*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/luts`);
          if (response.ok) {
            return await response.json();
          }
        } catch (error) {
          console.log('LUTs not available:', error);
        }
        return {correctionLuts: [], styleLuts: []};
      }
      
      async function checkVideoProxyExists(imageId) {
        /**Check if video proxy exists for this image ID*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/video-proxy-status/${imageId}`);
          if (response.ok) {
            const result = await response.json();
            return result.exists;
          }
        } catch (error) {
          console.log('Could not check video proxy status:', error);
        }
        return false;
      }
      
      async function getCurrentVideoProxyType(imageId) {
        /**Get current video proxy type from database*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/image-metadata/${imageId}`);
          if (response.ok) {
            const metadata = await response.json();
            console.log('Debug - Full metadata:', metadata);
            console.log('Debug - video_proxy_type:', metadata.video_proxy_type);
            return metadata.video_proxy_type || 'original';
          }
        } catch (error) {
          console.log('Could not get video proxy type:', error);
        }
        return 'original';
      }
      
      async function handleVideoProxyGenerate(imageId) {
        /**Handle video proxy generation with LUTs*/
        const button = event.target;
        const originalText = button.textContent;
        
        // Get selected LUTs
        const correctionLutSelect = document.getElementById(`correction-lut-select-${imageId}`);
        const styleLutSelect = document.getElementById(`style-lut-select-${imageId}`);
        
        const correctionLut = correctionLutSelect ? correctionLutSelect.value : '';
        const styleLut = styleLutSelect ? styleLutSelect.value : '';
        
        // Disable button and show loading state
        button.disabled = true;
        button.style.opacity = '0.5';
        button.textContent = '⏳ Processing...';
        
        try {
          const result = await generateVideoProxy(imageId, correctionLut, styleLut);
          
          if (result.success) {
            // Show success feedback
            button.textContent = '✅ Proxy Generated';
            button.style.background = '#00aa00';
            
            // Reload the current video to show the change with cache busting
            await reloadCurrentVideo();
            
            // Reset button after delay
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = '#0066cc';
              button.style.opacity = '1';
              button.disabled = false;
            }, 2000);
          } else {
            throw new Error(result.message || 'Video proxy generation failed');
          }
        } catch (error) {
          console.error('Error generating video proxy:', error);
          
          // Show error feedback
          button.textContent = '❌ Failed';
          button.style.background = '#cc0000';
          
          // Reset button after delay
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#0066cc';
            button.style.opacity = '1';
            button.disabled = false;
          }, 2000);
        }
      }
      
      async function generateVideoProxy(imageId, correctionLut, styleLut) {
        /**Generate video proxy with LUTs via API*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/generate-video-proxy`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              image_id: imageId,
              correction_lut: correctionLut,
              style_lut: styleLut
            })
          });
          
          if (response.ok) {
            return await response.json();
          } else {
            const errorText = await response.text();
            return { success: false, message: errorText };
          }
        } catch (error) {
          console.error('Error generating video proxy:', error);
          return { success: false, message: 'Network error' };
        }
      }
      
      async function handleVideoProxySwitch(imageId, useCustomProxy) {
        /**Handle switching between original video and custom proxy*/
        try {
          const response = await fetch(`http://${window.location.hostname}:8001/api/switch-video-proxy`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              image_id: imageId,
              use_custom_proxy: useCustomProxy
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log(`✅ ${result.message}`);
            
            // Reload the current video to show the change with cache busting
            await reloadCurrentVideo();
            
            // Force refresh the entire sidebar to update button states and status text
            await loadSidebar(current);
          } else {
            const error = await response.text();
            console.error('Failed to switch video proxy:', error);
            alert(`❌ Failed to switch video proxy: ${error}`);
          }
        } catch (error) {
          console.error('Error switching video proxy:', error);
          alert(`❌ Error: ${error.message}`);
        }
      }
      
      async function reloadCurrentVideo() {
        /**Reload the current video with cache busting*/
        const bigvideo = document.getElementById('bigvideo');
        if (bigvideo && bigvideo.style.display !== 'none') {
          const currentSrc = bigvideo.src;
          if (currentSrc) {
            // Add timestamp to bust cache
            const separator = currentSrc.includes('?') ? '&' : '?';
            bigvideo.src = currentSrc.split('?')[0] + '?t=' + Date.now();
          }
        }
      }
      
      async function handleProxySwitch(imageId, useCustomProxy, event) {
        /**Handle proxy switching with user feedback*/
        const button = event.target;
        const originalText = button.textContent;
        
        // Disable button and show loading state
        button.disabled = true;
        button.style.opacity = '0.5';
        button.textContent = '⏳ Switching...';
        
        try {
          const result = await switchProxyMode(imageId, useCustomProxy);
          console.log('Proxy switch result:', result);
          
          if (result.success) {
            // Update local metadata to reflect the proxy change
            const meta = images[current];
            if (meta && meta._imageId === imageId) {
              meta.raw_proxy_type = useCustomProxy ? 'custom_generated' : 'original_jpg';
            }
            
            // Show success feedback
            button.textContent = '✅ ' + (useCustomProxy ? 'Using RAW Proxy' : 'Using Original JPG');
            button.style.background = '#00aa00';
            
            // Reload the current image to show the change
            await reloadCurrentImage();
            
            // Explicitly reload thumbnail for this image
            reloadThumbnail(imageId);
            
            // Reload sidebar to update controls
            setTimeout(async () => {
              await loadSidebar(current);
            }, 1000);
            
          } else {
            // Show error feedback
            button.textContent = '❌ Failed';
            button.style.background = '#cc0000';
            alert('Failed to switch proxy mode: ' + result.message);
            
            // Restore button after delay
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = useCustomProxy ? '#cc6600' : '#667722';
              button.style.opacity = '1';
              button.disabled = false;
            }, 2000);
          }
        } catch (error) {
          console.error('Proxy switch error:', error);
          button.textContent = '❌ Error';
          button.style.background = '#cc0000';
          
          // Restore button after delay
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = useCustomProxy ? '#cc6600' : '#667722';
            button.style.opacity = '1';
            button.disabled = false;
          }, 2000);
        }
      }
      
      async function handleRawGenerate(imageId) {
        /**Handle generating new RAW proxy with two-stage preset selection*/
        const button = event.target;
        const originalText = button.textContent;
        const cameraSelect = document.getElementById(`camera-select-${imageId}`);
        const styleSelect = document.getElementById(`style-select-${imageId}`);
        const exposureSelect = document.getElementById(`exposure-select-${imageId}`);
        const selectedCamera = cameraSelect ? cameraSelect.value : '';
        const selectedStyle = styleSelect ? styleSelect.value : '';
        const selectedExposure = exposureSelect ? parseFloat(exposureSelect.value) : 0.0;
        
        // Disable button and show loading state
        button.disabled = true;
        button.style.opacity = '0.5';
        button.textContent = '⏳ Processing...';
        
        try {
          const result = await generateRawProxy(imageId, selectedCamera, selectedStyle, selectedExposure);
          
          if (result.success) {
            // Show success feedback
            button.textContent = '✅ Proxy Generated';
            button.style.background = '#00aa00';
            
            // Reload the current image to show the change
            await reloadCurrentImage();
            
            // Explicitly reload thumbnail for this image
            reloadThumbnail(imageId);
            
            // Reload sidebar to update controls
            setTimeout(async () => {
              await loadSidebar(current);
            }, 1000);
            
          } else {
            // Show error feedback
            button.textContent = '❌ Failed';
            button.style.background = '#cc0000';
            alert('Failed to generate RAW proxy: ' + result.message);
            
            // Restore button after delay
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = '#0066cc';
              button.style.opacity = '1';
              button.disabled = false;
            }, 2000);
          }
        } catch (error) {
          console.error('RAW generation error:', error);
          button.textContent = '❌ Error';
          button.style.background = '#cc0000';
          
          // Restore button after delay
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#0066cc';
            button.style.opacity = '1';
            button.disabled = false;
          }, 2000);
        }
      }
      
      async function handleRawRegenerate(imageId) {
        /**Handle regenerating existing RAW proxy with new two-stage presets*/
        const button = event.target;
        const originalText = button.textContent;
        const cameraSelect = document.getElementById(`camera-select-${imageId}`);
        const styleSelect = document.getElementById(`style-select-${imageId}`);
        const exposureSelect = document.getElementById(`exposure-select-${imageId}`);
        const selectedCamera = cameraSelect ? cameraSelect.value : '';
        const selectedStyle = styleSelect ? styleSelect.value : '';
        const selectedExposure = exposureSelect ? parseFloat(exposureSelect.value) : 0.0;
        
        // Disable button and show loading state
        button.disabled = true;
        button.style.opacity = '0.5';
        button.textContent = '⏳ Regenerating...';
        
        try {
          const result = await generateRawProxy(imageId, selectedCamera, selectedStyle, selectedExposure);
          
          if (result.success) {
            // Show success feedback
            button.textContent = '✅ Regenerated';
            button.style.background = '#00aa00';
            
            // Reload the current image to show the change
            await reloadCurrentImage();
            
            // Explicitly reload thumbnail for this image
            reloadThumbnail(imageId);
            
            // Reload sidebar to update controls
            setTimeout(async () => {
              await loadSidebar(current);
            }, 1000);
            
          } else {
            // Show error feedback
            button.textContent = '❌ Failed';
            button.style.background = '#cc0000';
            alert('Failed to regenerate RAW proxy: ' + result.message);
            
            // Restore button after delay
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = '#cc6600';
              button.style.opacity = '1';
              button.disabled = false;
            }, 2000);
          }
        } catch (error) {
          console.error('RAW regeneration error:', error);
          button.textContent = '❌ Error';
          button.style.background = '#cc0000';
          
          // Restore button after delay
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#cc6600';
            button.style.opacity = '1';
            button.disabled = false;
          }, 2000);
        }
      }
      
      function getDisplayImageUrl(meta) {
        /**Get the display URL for an image from metadata*/
        return meta.SourceFile || meta.src || meta.FileName;
      }
      
      async function reloadCurrentImage() {
        /**Reload the currently displayed image to reflect proxy changes*/
        if (mode === 'thumbs' || !images[current]) return;
        
        const meta = images[current];
        const timestampUrl = getDisplaySource(meta, true); // Use proper proxy logic with timestamp
        
        if (mode === 'fit' || mode === 'zoom') {
          // Using adjacent image system - update the current visible element
          if (adjacentImages.current) {
            adjacentImages.current.src = timestampUrl;
            
            // Reload faces after adjacent image loads
            adjacentImages.current.onload = () => {
              if (facesVisible && meta._imageId) {
                loadAndDisplayFaces();
              }
            };
          } else if (adjacentVideos.current) {
            // Adjacent video system is active
            adjacentVideos.current.src = timestampUrl;
          }
        }
        
        // Thumbnail reload is handled separately when explicitly needed for proxy changes
      }
      
      function reloadThumbnail(imageId) {
        /**Force reload thumbnail with timestamp to show updated version*/
        if (!imageId) return;
        
        // Find thumbnail in grid view and force reload
        const thumbnailImg = document.querySelector(`img[data-image-id="${imageId}"]`);
        if (thumbnailImg) {
          const originalSrc = thumbnailImg.src.split('?')[0]; // Remove existing timestamp
          thumbnailImg.src = originalSrc + '?t=' + Date.now();
        }
        
        // Only reload thumbnail in current view to avoid performance issues during gallery switching
        // The expensive querySelectorAll is only used when specifically needed for proxy changes
      }
      
      async function showFaces(faces, containerElement) {
        /**Display face detection boxes on an image*/
        // Clear existing face overlays
        const existingFaces = containerElement.querySelectorAll('.face-overlay');
        existingFaces.forEach(el => el.remove());
        
        // Don't show faces in zoom mode (1:1 pixel view - too crowded)
        if (mode === "zoom") {
          console.log('Hiding faces in zoom mode');
          return;
        }
        
        if (!facesVisible || !faces || faces.length === 0) return;
        
        // Get the currently visible image element (either bigimg or adjacent image)
        let imgElement = null;
        
        // First try to find the current visible adjacent image
        const currentAdjacent = adjacentImages.current || adjacentVideos.current;
        if (currentAdjacent && currentAdjacent.style.opacity === "1") {
          imgElement = currentAdjacent;
        } else {
          // Fallback to bigimg for compatibility
          imgElement = containerElement.querySelector('#bigimg');
        }
        
        if (!imgElement) {
          console.log('No visible image element found, skipping face display');
          return;
        }
        
        // For video elements, skip face detection
        if (imgElement.tagName === 'VIDEO') {
          console.log('Video element detected, skipping face display');
          return;
        }
        
        if (!imgElement.complete && imgElement.tagName === 'IMG') {
          console.log('Image not loaded yet, skipping face display');
          return;
        }
        
        // Calculate scale factors between original image and displayed image
        const naturalWidth = imgElement.naturalWidth;
        const naturalHeight = imgElement.naturalHeight;
        
        if (!naturalWidth || !naturalHeight) {
          console.log('Could not get image dimensions');
          return;
        }
        
        // For images with object-fit: contain, we need to calculate the actual rendered size
        const containerWidth = imgElement.clientWidth;
        const containerHeight = imgElement.clientHeight;
        
        // Calculate the scale to fit the image within the container while maintaining aspect ratio
        const scaleToFitX = containerWidth / naturalWidth;
        const scaleToFitY = containerHeight / naturalHeight;
        const scaleToFit = Math.min(scaleToFitX, scaleToFitY);
        
        // Calculate actual displayed image dimensions
        const displayedWidth = naturalWidth * scaleToFit;
        const displayedHeight = naturalHeight * scaleToFit;
        
        // Calculate centering offset within the container
        const centerOffsetX = (containerWidth - displayedWidth) / 2;
        const centerOffsetY = (containerHeight - displayedHeight) / 2;
        
        // Get the image's position relative to the container
        const imgRect = imgElement.getBoundingClientRect();
        const containerRect = containerElement.getBoundingClientRect();
        const offsetX = imgRect.left - containerRect.left + centerOffsetX;
        const offsetY = imgRect.top - containerRect.top + centerOffsetY;
        
        console.log(`🔍 Face positioning debug:`);
        console.log(`  Container: ${containerElement.id || containerElement.className}`);
        console.log(`  Image element: ${imgElement.id || imgElement.className} (${imgElement.tagName})`);
        console.log(`  Container size: ${containerWidth}x${containerHeight}`);
        console.log(`  Natural size: ${naturalWidth}x${naturalHeight}`);
        console.log(`  Actual displayed size: ${displayedWidth.toFixed(1)}x${displayedHeight.toFixed(1)}`);
        console.log(`  Scale to fit: ${scaleToFit.toFixed(3)}`);
        console.log(`  Center offset: ${centerOffsetX.toFixed(1)}px, ${centerOffsetY.toFixed(1)}px`);
        console.log(`  Final offset: ${offsetX.toFixed(1)}px, ${offsetY.toFixed(1)}px`);
        
        // Show all faces (identified and unidentified)
        for (let index = 0; index < faces.length; index++) {
          const face = faces[index];
          const overlay = document.createElement('div');
          overlay.className = 'face-overlay visible';
          
          // Scale face coordinates to match displayed image
          const scaledX = face.x * scaleToFit + offsetX;
          const scaledY = face.y * scaleToFit + offsetY;
          const scaledWidth = face.width * scaleToFit;
          const scaledHeight = face.height * scaleToFit;
          
          overlay.style.left = `${scaledX}px`;
          overlay.style.top = `${scaledY}px`;
          overlay.style.width = `${scaledWidth}px`;
          overlay.style.height = `${scaledHeight}px`;
          
          console.log(`Face ${index}: orig(${face.x},${face.y},${face.width}x${face.height}) -> scaled(${scaledX.toFixed(0)},${scaledY.toFixed(0)},${scaledWidth.toFixed(0)}x${scaledHeight.toFixed(0)})`);
          
          
          // Add name/confidence label
          const label = document.createElement('div');
          label.className = 'face-label';
          
          // Adjust label position if face box goes off top of screen
          const labelHeight = 25; // Height of label plus margin
          if (scaledY < labelHeight) {
            // Move label below the face box instead of above
            label.style.top = `${scaledHeight + 5}px`;
          } else {
            // Default position above the face box
            label.style.top = '-25px';
          }
          
          if (face.person_name && face.confirmed) {
            // Check if this is a Person # format that can be renamed
            if (/^Person \d+$/.test(face.person_name)) {
              await createPersonRenameControls(label, face);
            } else {
              label.textContent = `${face.person_name} (${(face.confidence * 100).toFixed(0)}%)`;
              label.style.background = 'rgba(0, 150, 255, 0.8)'; // Blue for confirmed
            }
          } else if (face.person_name) {
            // Check if this is a Person # format that can be renamed
            if (/^Person \d+$/.test(face.person_name)) {
              await createPersonRenameControls(label, face);
            } else {
              label.textContent = `${face.person_name}? (${(face.confidence * 100).toFixed(0)}%)`;
              label.style.background = 'rgba(255, 150, 0, 0.8)'; // Orange for unconfirmed
            }
          } else {
            // Unidentified face - create interactive controls
            await createUnidentifiedFaceControls(label, face);
          }
          
          overlay.appendChild(label);
          
          containerElement.appendChild(overlay);
        }
      }
      
      function toggleFaceDetection() {
        /**Toggle face detection overlay visibility*/
        facesVisible = !facesVisible;
        
        // Update all visible face overlays
        const allFaceOverlays = document.querySelectorAll('.face-overlay');
        allFaceOverlays.forEach(overlay => {
          overlay.classList.toggle('visible', facesVisible);
        });
        
        console.log(`Face detection: ${facesVisible ? 'ON' : 'OFF'}`);
        
        // If we're in single view and turning ON, load faces for current image
        if (mode !== 'thumbs' && facesVisible && images[current]) {
          console.log('Triggering face load after toggle');
          loadFacesForCurrentImage();
        }
        
        // If turning off, clear existing overlays
        if (!facesVisible) {
          const existingFaces = document.querySelectorAll('.face-overlay');
          existingFaces.forEach(el => el.remove());
        }
      }
      
      async function loadFacesForCurrentImage() {
        /**Load and display faces for the currently viewed image*/
        if (!images[current]) return;
        
        // Clear existing face overlays from both old bigimgWrap and singleview containers
        const existingFaces = document.querySelectorAll('.face-overlay');
        existingFaces.forEach(el => el.remove());
        
        const meta = images[current];
        const imageId = meta._imageId || meta.id; // Assuming we add image ID to JSON
        
        console.log('Loading faces for image:', current, 'imageId:', imageId, 'meta:', meta);
        
        if (imageId) {
          const faces = await loadFaces(imageId);
          console.log('Loaded faces:', faces);
          if (faces.length > 0) {
            // Use singleview as container since that's where adjacent images are positioned
            await showFaces(faces, singleview);
            // Show face detection controls if faces are found
            showFaceDetectionControls(true);
          } else {
            console.log('No faces found for image:', imageId);
            // Hide face detection controls if no faces
            showFaceDetectionControls(false);
            // Turn off face detection if it was on
            if (facesVisible) {
              facesVisible = false;
              console.log('Auto-disabled face detection - no faces in image');
            }
          }
        } else {
          console.log('No imageId found in meta data');
          showFaceDetectionControls(false);
        }
      }
      
      function showFaceDetectionControls(show) {
        /**Show or hide face detection controls based on whether image has faces*/
        const faceToggleButton = document.querySelector('[onclick*="toggleFaceDetection"]');
        if (faceToggleButton) {
          faceToggleButton.style.display = show ? 'block' : 'none';
        }
        
        // Also hide the keyboard shortcut hint if no faces
        const shortcutHints = document.querySelectorAll('[title*="face"]');
        shortcutHints.forEach(hint => {
          if (hint.textContent.toLowerCase().includes('face')) {
            hint.style.display = show ? 'block' : 'none';
          }
        });
      }
      
      async function loadGalleries(forceReload = false) {
        // Force reload if requested
        if (forceReload) {
          galleriesListLoaded = false;
          galleryCacheBuilt = false;
          galleryCache = null;
        }

        // Only load galleries once (unless forcing reload)
        if (!forceReload && galleriesListLoaded && galleries.length > 0) {
          return;
        }
        
        try {
          const response = await fetch(`JSON/galleries.json?t=${Date.now()}`);
          if (response.ok) {
            galleries = await response.json();
            console.log(`Loaded ${galleries.length} galleries from galleries.json`);
            renderGalleries();
            galleriesListLoaded = true;
          } else {
            console.log('galleries.json not found - run start_gallery_server.sh first');
            galleries = [];
            renderGalleries();
          }
        } catch (error) {
          console.log('Failed to load galleries.json:', error);
          galleries = [];
          renderGalleries();
        }
      }
      
      
      function renderGalleries() {
        const selector = document.getElementById('gallery-selector');
        const header = selector.querySelector('.gallery-header');
        
        // Clear existing items
        const existingItems = selector.querySelectorAll('.gallery-item');
        existingItems.forEach(item => item.remove());
        
        galleries.forEach(gallery => {
          const item = document.createElement('div');
          item.className = 'gallery-item';
          
          // Create gallery name span
          const nameSpan = document.createElement('span');
          nameSpan.textContent = gallery.name;
          
          // Create count badge
          const countBadge = document.createElement('span');
          countBadge.className = 'gallery-count-badge';
          const count = gallery.image_count || gallery.imageCount || 0;
          countBadge.textContent = count.toString();
          
          // Append both elements
          item.appendChild(nameSpan);
          item.appendChild(countBadge);
          
          item.dataset.galleryPath = gallery.jsonPath;
          
          if (currentGallery === gallery.jsonPath) {
            item.classList.add('active');
          }
          
          item.addEventListener('click', () => {
            loadGallery(gallery.jsonPath, gallery.name);
          });
          
          selector.appendChild(item);
        });
      }
      
      async function loadGallery(jsonPath, galleryName) {
        try {
          // Force return to thumbnail view and clear state
          if (mode !== "thumbs") {
            mode = "thumbs";
            singleview.classList.remove("visible");
            // Also clear z-index to ensure thumbnail grid is shown
            singleview.style.zIndex = "1";
            thumbgrid.style.zIndex = "200";
            thumbgrid.style.display = "grid";
            
            // Reset video z-index when forcing thumbnail mode
            const videoEl = document.getElementById('bigvideo');
            if (videoEl) {
              videoEl.style.zIndex = "1";
            }
          }
          
          // Clear current state immediately to prevent conflicts
          const oldImages = images;
          images = [];
          current = 0;
          selectedThumbnails.clear(); // Clear selection when switching galleries
          
          // Clear visual thumbnail highlights
          document.querySelectorAll('.thumb-cell.selected').forEach(cell => {
            cell.classList.remove('selected');
          });
          
          // Clear gallery keyboard navigation state
          clearGalleryFocus();
          
          preloadCache.clear(); // Clear preload cache when switching galleries
          stopPreloading(); // Stop background preloading for previous gallery
          clearAdjacentElements(); // Clear adjacent image elements
          // Keep picks across galleries for multi-gallery selection
          
          // Clear big image/video sources to prevent stale loads
          bigimg.src = '';
          // Properly clear video without invalid URI error
          const videoEl = document.getElementById('bigvideo');
          if (videoEl) {
            videoEl.pause();
            videoEl.removeAttribute('src');
            videoEl.load();
            videoEl.style.display = 'none';
          }
          bigimg.style.display = 'block';
          
          const response = await fetch(`${jsonPath}?t=${Date.now()}`);
          if (!response.ok) throw new Error('Gallery not found');
          
          const galleryData = await response.json();
          images = galleryData;
          currentGallery = jsonPath;
          
          // Apply default sort order to new gallery
          sortImages(currentSortOrder);
          
          // Initialize with first image selected
          if (images.length > 0) {
            selectedThumbnails.add(0);
          }
          
          // Update UI
          renderGalleries(); // Update active state
          renderThumbnails();
          updateSelectionDisplay();
          
          // Load picks and rejects, then update visual indicators
          initializePicksAndRejects();
          
          loadSidebar(0).catch(console.error);
          
          console.log(`Loaded gallery: ${galleryName} (${images.length} images)`);
        } catch (error) {
          console.error('Failed to load gallery:', galleryName, 'Error:', error.message);
          // Don't show alert for transient errors if the gallery might still work
        }
      }
      
      // Deferred loading system
      let loadTimeouts = new Map();
      // let intersectionObserver = null; // Disabled - using immediate loading
      let loadedImages = new Set(); // Track which images are loaded (still used for picks)
      // let viewportCenter = 0; // Track current viewport center
      // const MAX_LOADED_IMAGES = 200;
      
      function initDeferredLoading() {
        if (intersectionObserver) {
          intersectionObserver.disconnect();
        }
        
        intersectionObserver = new IntersectionObserver((entries) => {
          // Update viewport center based on intersecting entries
          updateViewportCenter(entries);
          
          entries.forEach(entry => {
            const cell = entry.target;
            const idx = parseInt(cell.dataset.idx);
            
            if (entry.isIntersecting) {
              // Schedule load after 1 second in viewport
              if (!loadTimeouts.has(idx)) {
                const timeoutId = setTimeout(() => {
                  loadThumbnail(cell, idx);
                  loadTimeouts.delete(idx);
                }, 1000);
                loadTimeouts.set(idx, timeoutId);
              }
            } else {
              // Clear any pending load if not yet loaded
              if (loadTimeouts.has(idx)) {
                clearTimeout(loadTimeouts.get(idx));
                loadTimeouts.delete(idx);
                
                // Only cancel loading for images that haven't started loading yet
                cancelPendingLoad(cell, idx);
              }
            }
          });
        }, {
          rootMargin: '50px',
          threshold: 0.1
        });
      }
      
      function updateViewportCenter(entries) {
        // Calculate approximate viewport center based on visible entries
        let visibleIndices = [];
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            visibleIndices.push(parseInt(entry.target.dataset.idx));
          }
        });
        
        if (visibleIndices.length > 0) {
          viewportCenter = visibleIndices.reduce((a, b) => a + b, 0) / visibleIndices.length;
        }
      }
      
      function getDistanceFromViewport(idx) {
        return Math.abs(idx - viewportCenter);
      }
      
      function enforceMemoryLimit() {
        if (loadedImages.size <= MAX_LOADED_IMAGES) return;
        
        // Get all loaded images with their distances from viewport
        const loadedWithDistances = Array.from(loadedImages).map(idx => ({
          idx: idx,
          distance: getDistanceFromViewport(idx)
        }));
        
        // Sort by distance (furthest first)
        loadedWithDistances.sort((a, b) => b.distance - a.distance);
        
        // Unload the furthest images until we're under the limit
        const toUnload = loadedWithDistances.slice(0, loadedImages.size - MAX_LOADED_IMAGES + 50); // Unload 50 extra for buffer
        
        toUnload.forEach(item => {
          const cell = document.querySelector(`.thumb-cell[data-idx='${item.idx}']`);
          if (cell && !cell.classList.contains('selected')) { // Don't unload selected image
            unloadThumbnail(cell, item.idx);
          }
        });
        
        console.log(`📉 Memory management: Unloaded ${toUnload.length} images furthest from viewport`);
      }
      
      function loadThumbnail(cell, idx) {
        const meta = images[idx];
        if (!meta) return;
        
        // Use thumbnail if available, otherwise fall back to main image
        let src;
        if (meta._thumbnail) {
          src = meta._thumbnail;
        } else {
          src = meta.SourceFile || meta.src || meta.FileName;
        }
        const cleanSrc = src.replace(/^\.\//, "");
        
        // Check if already has content loaded
        const img = cell.querySelector('img');
        const alreadyLoaded = (img && img.src);
        
        if (alreadyLoaded && loadedImages.has(idx)) {
          // Already loaded and tracked
          return;
        }
        
        // Load the content - now both images and videos use img elements for thumbnails
        if (img) {
          if (isVideoFile(cleanSrc) && meta._thumbnail) {
            // For videos, use generated thumbnail
            img.src = meta._thumbnail;
          } else {
            // For images or videos without thumbnails, use original source
            img.src = cleanSrc;
          }
          img.alt = meta.FileName || "";
        }
        
        cell.dataset.loaded = 'true';
        loadedImages.add(idx);
        
        console.log(`📸 Loaded thumbnail ${idx} (${loadedImages.size}/${MAX_LOADED_IMAGES})`);
        
        // Check if we need to unload distant images
        enforceMemoryLimit();
      }
      
      function unloadThumbnail(cell, idx) {
        // Only unload if not currently selected
        if (cell.classList.contains('selected')) return;
        
        // Clear any pending load timeout for this image
        if (loadTimeouts.has(idx)) {
          clearTimeout(loadTimeouts.get(idx));
          loadTimeouts.delete(idx);
        }
        
        const img = cell.querySelector('img');
        
        if (img && img.src) {
          img.src = '';
        }
        
        cell.dataset.loaded = 'false';
        loadedImages.delete(idx);
        
        console.log(`🗑️ Unloaded thumbnail ${idx}`);
      }
      
      function cancelPendingLoad(cell, idx) {
        // This is called when an image leaves viewport before it finished loading
        // Only affects images that were scheduled to load but haven't started yet
        
        // The timeout was already cleared, so no action needed here
        // Images that were already loading will complete, images that hadn't started won't start
      }

      function renderThumbnails() {
        // Cancel any pending image loads from previous gallery
        const existingImages = thumbgrid.querySelectorAll('img');
        existingImages.forEach(img => {
          img.src = ''; // Cancel pending load
        });
        
        // Clear timeouts and reset tracking
        loadTimeouts.forEach(id => clearTimeout(id));
        loadTimeouts.clear();
        loadedImages.clear();
        viewportCenter = 0;
        
        // Clear DOM
        thumbgrid.innerHTML = "";
        
        images.forEach((meta, i) => {
          const src = meta.SourceFile || meta.src || meta.FileName;
          const cleanSrc = src.replace(/^\.\//, "");
          const cell = document.createElement("div");
          cell.className = "thumb-cell";
          cell.dataset.idx = i;
          
          // Load all thumbnails immediately - no lazy loading
          if (isVideoFile(cleanSrc)) {
            // For videos, use generated thumbnail image instead of video element
            const img = document.createElement("img");
            if (meta._thumbnail) {
              img.src = meta._thumbnail;
            } else {
              // Fallback to video file if no thumbnail available
              img.src = cleanSrc;
            }
            img.alt = meta.FileName || "";
            cell.classList.add("video-thumbnail");
            cell.appendChild(img);
          } else {
            const img = document.createElement("img");
            // Always use thumbnail if available, otherwise original
            if (meta._thumbnail) {
              img.src = meta._thumbnail;
            } else {
              img.src = cleanSrc;
            }
            img.alt = meta.FileName || "";
            cell.appendChild(img);
          }
          
          cell.dataset.loaded = 'true';
          loadedImages.add(i);
          
          thumbgrid.appendChild(cell);
        });
        
        console.log(`📸 Loaded all ${images.length} thumbnails immediately`);
        
        // Start background preloading after thumbnails are loaded
        startBackgroundPreloading();
      }
      
      function startBackgroundPreloading() {
        /**Start aggressive background preloading of full-size images*/
        if (preloadingActive || !images || images.length === 0) return;
        
        console.log('🚀 Starting background preloading of full-size images');
        preloadingActive = true;
        preloadedImages.clear();
        
        // Create preload queue starting from current selection, then spiral outward
        createPreloadQueue();
        
        // Start preloading
        continuePreloading();
      }
      
      function createPreloadQueue() {
        /**Create preload queue starting from selected image, spiraling outward (limited to maxPreloadImages) - IMAGES ONLY*/
        preloadQueue = [];
        const startIndex = current || 0;
        const visited = new Set();
        
        // Add selected image first (only if it's not a video)
        if (!isVideoFile(images[startIndex]?.SourceFile || images[startIndex]?.src || images[startIndex]?.FileName || '')) {
          preloadQueue.push(startIndex);
          visited.add(startIndex);
        }
        
        // Spiral outward from selected image, but limit total count and exclude videos
        let distance = 1;
        while (visited.size < Math.min(images.length, maxPreloadImages)) {
          // Add images at distance before and after current
          const before = (startIndex - distance + images.length) % images.length;
          const after = (startIndex + distance) % images.length;
          
          // Check if before index is not a video
          if (!visited.has(before) && visited.size < maxPreloadImages) {
            const beforeFile = images[before]?.SourceFile || images[before]?.src || images[before]?.FileName || '';
            if (!isVideoFile(beforeFile)) {
              preloadQueue.push(before);
              visited.add(before);
            }
          }
          
          // Check if after index is not a video
          if (!visited.has(after) && after !== before && visited.size < maxPreloadImages) {
            const afterFile = images[after]?.SourceFile || images[after]?.src || images[after]?.FileName || '';
            if (!isVideoFile(afterFile)) {
              preloadQueue.push(after);
              visited.add(after);
            }
          }
          
          distance++;
          
          // Safety check to prevent infinite loop in small galleries
          if (distance > Math.ceil(images.length / 2)) {
            break;
          }
        }
        
        console.log(`📋 Created preload queue of ${preloadQueue.length} IMAGES ONLY (max ${maxPreloadImages}) starting from index ${startIndex}`);
      }
      
      function continuePreloading() {
        /**Continue preloading the next image in queue - IMAGES ONLY*/
        if (!preloadingActive || currentPreloadIndex >= preloadQueue.length) {
          console.log(`✅ Background preloading completed (${preloadedImages.size} images cached)`);
          preloadingActive = false;
          return;
        }
        
        const imageIndex = preloadQueue[currentPreloadIndex];
        const meta = images[imageIndex];
        
        if (!meta || preloadedImages.has(imageIndex)) {
          // Skip already preloaded or invalid images
          currentPreloadIndex++;
          setTimeout(continuePreloading, 1);
          return;
        }
        
        // Double-check that this isn't a video (safety check)
        const fileName = meta.SourceFile || meta.src || meta.FileName || '';
        if (isVideoFile(fileName)) {
          console.warn(`⚠️ Skipping video in preload queue: ${fileName}`);
          currentPreloadIndex++;
          setTimeout(continuePreloading, 1);
          return;
        }
        
        // Create an image element to preload
        const img = new Image();
        const displaySrc = getDisplaySource(meta, false); // No timestamp for caching
        
        console.log(`🔄 Preloading image index ${imageIndex} with URL: ${displaySrc}`);
        
        img.onload = () => {
          preloadedImages.add(imageIndex);
          
          // Check if image was loaded from cache or server
          setTimeout(() => {
            const cacheStatus = checkImageCacheStatus(displaySrc);
            console.log(`📸 Preloaded image ${currentPreloadIndex + 1}/${preloadQueue.length} (index ${imageIndex + 1}) - ${cacheStatus.toUpperCase()}`);
          }, 10);
          
          currentPreloadIndex++;
          
          // Continue with next image after small delay to avoid blocking UI
          setTimeout(continuePreloading, 50);
        };
        
        img.onerror = () => {
          console.warn(`⚠️ Failed to preload image ${currentPreloadIndex + 1}/${preloadQueue.length} (index ${imageIndex})`);
          currentPreloadIndex++;
          setTimeout(continuePreloading, 1);
        };
        
        img.src = displaySrc;
      }
      
      function restartPreloadingFromSelection() {
        /**Restart preloading from newly selected image*/
        if (!images || images.length === 0) return;
        
        console.log(`🔄 Selection changed to image ${current + 1}`);
        
        if (preloadingActive) {
          console.log(`⏹️ Cancelling current preloading batch (was at ${currentPreloadIndex}/${preloadQueue.length})`);
          // Stop current preloading
          preloadingActive = false;
        }
        
        // Start fresh preloading from new selection
        console.log(`🚀 Starting new preload batch from image ${current + 1}`);
        preloadingActive = true;
        currentPreloadIndex = 0;
        createPreloadQueue();
        
        // Start preloading from new queue
        continuePreloading();
      }
      
      function stopPreloading() {
        /**Stop background preloading (for gallery changes)*/
        if (preloadingActive) {
          console.log('⏹️ Stopping background preloading');
          preloadingActive = false;
          preloadQueue = [];
          currentPreloadIndex = 0;
        }
      }
      
      function checkImageCacheStatus(imageUrl) {
        /**Check if an image was loaded from cache or server using Performance API*/
        try {
          // Try different URL variations that might be in performance entries
          const urlsToCheck = [
            imageUrl,
            new URL(imageUrl, window.location.href).href, // Convert to absolute URL
            encodeURI(imageUrl), // Handle special characters
            imageUrl.replace(/^\.\//, '') // Remove leading ./
          ];
          
          for (const url of urlsToCheck) {
            const entries = performance.getEntriesByName(url);
            if (entries.length > 0) {
              const entry = entries[entries.length - 1]; // Get most recent entry
              
              console.log(`🔍 Performance entry for ${url}:`, {
                transferSize: entry.transferSize,
                decodedBodySize: entry.decodedBodySize,
                encodedBodySize: entry.encodedBodySize,
                duration: entry.duration
              });
              
              // More robust cache detection
              if (entry.transferSize === 0 && entry.decodedBodySize > 0) {
                return 'cached';
              } else if (entry.transferSize > 0) {
                return 'server';
              } else if (entry.duration === 0 || entry.duration < 1) {
                return 'cached (fast)'; // Very fast load likely means cached
              }
            }
          }
          
          // Check all performance entries to see what URLs are actually recorded
          const allEntries = performance.getEntriesByType('resource');
          const imageEntries = allEntries.filter(e => 
            e.initiatorType === 'img' && 
            (e.name.includes(imageUrl) || imageUrl.includes(e.name.split('/').pop()))
          );
          
          if (imageEntries.length > 0) {
            console.log(`🔍 Found related image entries:`, imageEntries.map(e => e.name));
            const entry = imageEntries[imageEntries.length - 1];
            if (entry.transferSize === 0 && entry.decodedBodySize > 0) {
              return 'cached (matched)';
            } else if (entry.transferSize > 0) {
              return 'server (matched)';
            }
          }
          
          return 'unknown (no perf entry)';
        } catch (e) {
          console.warn('Cache status check error:', e);
          return 'error';
        }
      }
      
      document.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        
        // DEBUG: console.log('Keydown event:', e.key, 'inputFieldFocused:', inputFieldFocused, 'commandPaletteOpen:', commandPaletteOpen);
        
        // Skip keyboard shortcuts when an input field is focused (except for command palette)
        if (inputFieldFocused && !commandPaletteOpen) return;
        
        // Handle command palette
        if (commandPaletteOpen) {
          if (e.key === "Escape") {
            if (commandPaletteMode === 'gallery') {
              // Exit gallery mode, go back to main commands
              commandPaletteMode = null;
              commandPaletteSearchString = '';
              commandInput.value = '';
              commandInput.placeholder = 'Type a command...';
              updateCommandPalette('');
            } else {
              closeCommandPalette();
            }
            e.preventDefault();
            return;
          }
          if (e.key === "ArrowUp") {
            navigateCommandPalette(-1);
            e.preventDefault();
            return;
          }
          if (e.key === "ArrowDown") {
            navigateCommandPalette(1);
            e.preventDefault();
            return;
          }
          if (e.key === "Enter") {
            executeSelectedCommand();
            e.preventDefault();
            return;
          }
          // Let other keys pass through to the input
          return;
        }
        
        // Open command palette with "/"
        if (e.key === "/" && !e.ctrlKey && !e.metaKey) {
          openCommandPalette();
          e.preventDefault();
          return;
        }
        
        // Handle cull mode keys
        if (cullMode) {
          if (e.key === "ArrowLeft") {
            handleCullNavigation(-1);
            e.preventDefault();
            return;
          }
          if (e.key === "ArrowRight") {
            handleCullNavigation(1);
            e.preventDefault();
            return;
          }
          if (e.key === "p") {
            handleCullPick();
            e.preventDefault();
            return;
          }
          if (e.key === " ") {
            if (cullZoomMode) {
              exitCullZoom();
            } else {
              enterCullZoom();
            }
            e.preventDefault();
            return;
          }
          if (e.key === "f") {
            exitCullMode(true); // Mark for deletion
            e.preventDefault();
            return;
          }
          if (e.key === "q" || e.key === "Q") {
            exitCullMode(false); // Cancel without marking
            e.preventDefault();
            return;
          }
          // Block other keys in cull mode
          e.preventDefault();
          return;
        }
        
        // Handle gallery 'g' key behavior - close gallery if open, open if closed
        if (e.key === "g") {
          if (gallerySelectorOpen) {
            // Gallery bar is open - close it
            clearGalleryFocus();
            toggleGallerySelector();
          } else {
            // Gallery bar is closed - open it (but don't focus)
            toggleGallerySelector();
          }
          e.preventDefault();
          return;
        }
        
        // Handle gallery navigation - Shift+Up/Down when gallery is open
        if (gallerySelectorOpen && e.shiftKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          if (!gallerySelectorFocused) focusGallerySelector(); // Auto-focus on Shift+arrow keys
          handleGalleryNavigation(e.key === "ArrowDown" ? 1 : -1);
          e.preventDefault();
          return;
        }
        
        // Handle gallery selection and escape
        if (gallerySelectorOpen && gallerySelectorFocused) {
          if (e.key === "Enter" && selectedGalleryIndex >= 0) {
            selectGalleryByIndex(selectedGalleryIndex);
            e.preventDefault();
            return;
          }
          if (e.key === "Escape") {
            clearGalleryFocus();
            e.preventDefault();
            return;
          }
        }
        
        // Normal mode keys
        if (e.key === "ArrowLeft") handleArrow(-1, e.shiftKey);
        if (e.key === "ArrowRight") handleArrow(1, e.shiftKey);
        if (e.key === "ArrowUp") handleVerticalArrow(-1, e.shiftKey);
        if (e.key === "ArrowDown") handleVerticalArrow(1, e.shiftKey);
        if (e.key === " ") {
          if (mode === "thumbs") {
            // Check if we should enter cull mode
            if (selectedThumbnails.size > 1) {
              enterCullMode();
            } else if (selectedThumbnails.size === 1) {
              // Set current index to the selected thumbnail before showing single view
              const selectedIndex = Array.from(selectedThumbnails)[0];
              current = selectedIndex;
              showSingle("fit");
            }
          } else if (mode === "fit") {
            enterZoom();
          } else if (mode === "zoom") {
            exitZoom();
          }
          e.preventDefault();
        }
        if (e.key === "q" || e.key === "Q") {
          // Stop any playing video
          const currentVideo = document.getElementById('bigvideo');
          if (currentVideo && !currentVideo.paused) {
            console.log('🎬 Stopping video on "q" key press');
            currentVideo.pause();
            currentVideo.currentTime = 0; // Reset to beginning
          }
          
          if (mode === "zoom") exitZoom();
          else if (mode === "fit") showThumbs();
          else if (mode === "thumbs") {
            // Clear all selections in thumbnail mode
            selectedThumbnails.clear();
            updateSelectionDisplay();
          }
        }
        if (e.key === "m") toggleSidebar();
        if (e.key === "p") {
          togglePick();
        }
        if (e.key === "x") {
          toggleReject();
        }
        if (e.key === "l") togglePicksList();
        // 'g' key handler removed - sophisticated 'g' behavior is handled earlier in the keydown handler
        if (e.key === "o") toggleFaceDetection(); // Changed from 'f' to 'o' to avoid conflict
        if (e.key === "s") toggleStatusFeed(); // Toggle status feed log
      });

      // Click-to-zoom removed for better face control interaction
      // Use spacebar to zoom instead
      
      bigvideo.addEventListener("click", (e) => {
        // For videos, don't interfere with native controls
        e.stopPropagation();
      });

      thumbgrid.addEventListener("click", (e) => {
        // Skip click handling on touch devices to prevent conflicts
        if (isTouchDevice) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        
        let cell = e.target.closest(".thumb-cell");
        if (!cell) return;
        
        const clickedIndex = +cell.dataset.idx;
        
        // New selection model: single click selects, shift+click does range selection, cmd/ctrl+click toggles
        if (e.shiftKey) {
          e.preventDefault();
          selectThumbnail(clickedIndex, true, false);
          return;
        }
        
        // Cmd/Ctrl+click - toggle selection
        if (e.metaKey || e.ctrlKey) {
          e.preventDefault();
          selectThumbnail(clickedIndex, false, true);
          return;
        }
        
        // Normal click - just select the thumbnail
        selectThumbnail(clickedIndex, false, false);
      });
      

      // Initialize the gallery system
      // initDeferredLoading(); // Disabled - using immediate loading
      
      loadGalleries().then(() => {
        // Show gallery selection message instead of auto-loading first gallery
        showGallerySelectionMessage();
        sidebar.classList.add("visible");
      });

      // Touch device initialization and handlers
      function initializeTouchSupport() {
        isTouchDevice = detectTouchDevice();
        
        if (isTouchDevice) {
          document.getElementById('touch-toolbar').classList.add('visible');
          
          // Add touch toolbar event handlers
          document.getElementById('touch-gallery-btn').addEventListener('click', toggleGallerySelector);
          document.getElementById('touch-pick-btn').addEventListener('click', () => {
            if (cullMode) {
              // In cull mode, do what 'p' key does
              handleCullPick();
            } else if (selectedThumbnails.size > 0) {
              // In normal mode, do what 'p' key does
              togglePick();
              updatePickClasses();
            }
          });
          document.getElementById('touch-reject-btn').addEventListener('click', () => {
            if (selectedThumbnails.size > 0) {
              toggleReject();
              updatePickClasses();
            }
          });
          document.getElementById('touch-faces-btn').addEventListener('click', () => {
            facesVisible = !facesVisible;
            document.getElementById('touch-faces-btn').classList.toggle('active', facesVisible);
            loadFacesForCurrentImage();
          });
          document.getElementById('touch-sidebar-btn').addEventListener('click', () => {
            sidebarOpen = !sidebarOpen;
            sidebar.classList.toggle('visible', sidebarOpen);
            document.getElementById('touch-sidebar-btn').classList.toggle('active', sidebarOpen);
          });
          document.getElementById('touch-picks-btn').addEventListener('click', () => {
            // Do what 'l' key does - toggle picks list
            togglePicksList();
          });
          document.getElementById('touch-status-btn').addEventListener('click', () => {
            // Do what 's' key does - toggle status feed
            toggleStatusFeed();
          });
          document.getElementById('touch-command-btn').addEventListener('click', () => {
            // Do what '/' key does - open command palette
            openCommandPalette();
          });
          document.getElementById('touch-finish-btn').addEventListener('click', () => {
            // Do what 'f' key does in cull mode - finish cull
            if (cullMode) {
              exitCullMode(true);
            }
          });
          document.getElementById('touch-prev-btn').addEventListener('click', () => {
            // Do what left arrow key does
            handleArrow(-1, false);
          });
          document.getElementById('touch-next-btn').addEventListener('click', () => {
            // Do what right arrow key does
            handleArrow(1, false);
          });
          document.getElementById('touch-clear-btn').addEventListener('click', () => {
            // Do what 'q' key does - clear selection and exit modes
            if (cullMode) {
              // In cull mode, exit cull mode (same as 'q' in cull mode)
              exitCullMode(false);
            } else {
              selectedThumbnails.clear();
              touchMode = 'normal';
              updateSelectionDisplay();
              
              // Hide single view if visible (like 'q' does)
              if (singleview.classList.contains('visible')) {
                showThumbs();
              } else {
                updateTouchToolbar();
              }
            }
          });
          document.getElementById('touch-cull-btn').addEventListener('click', () => {
            if (cullMode) {
              // In cull mode, do what 'f' key does - finish cull
              exitCullMode(true);
            } else if (selectedThumbnails.size > 1) {
              // In selection mode, enter cull mode
              enterCullMode();
            }
          });
          
          // Cull mode toolbar handlers
          document.getElementById('cull-finish-btn').addEventListener('click', () => {
            // Trigger the same action as 'f' key
            finalizeCull();
          });
          document.getElementById('cull-cancel-btn').addEventListener('click', () => {
            // Trigger the same action as 'q' key in cull mode
            exitCullMode();
          });
          
          // Add touch event handlers to thumbnails
          addTouchThumbnailHandlers();
          
          // Add swipe handlers to single view
          addSwipeHandlers();
        }
      }

      function addTouchThumbnailHandlers() {
        thumbgrid.addEventListener('touchstart', handleTouchStart, { passive: true });
        thumbgrid.addEventListener('touchend', handleTouchEnd, { passive: true });
        thumbgrid.addEventListener('touchmove', handleTouchMove, { passive: true });
      }

      function handleTouchStart(e) {
        const cell = e.target.closest('.thumb-cell');
        if (!cell) return;
        
        // Prevent any other event handlers
        e.stopPropagation();
        
        const idx = +cell.dataset.idx;
        touchStartTime = Date.now();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        cell.classList.add('touch-selected');
        
        // Set up long press detection
        touchTimeout = setTimeout(() => {
          handleLongPress(idx, cell);
        }, touchHoldThreshold);
      }

      function handleTouchMove(e) {
        // Cancel long press if user moves finger significantly
        if (touchTimeout && e.touches.length > 0) {
          const deltaX = Math.abs(e.touches[0].clientX - touchStartX);
          const deltaY = Math.abs(e.touches[0].clientY - touchStartY);
          
          if (deltaX > touchMoveThreshold || deltaY > touchMoveThreshold) {
            clearTimeout(touchTimeout);
            touchTimeout = null;
            
            // Remove visual feedback since this is now a scroll
            const cell = e.target.closest('.thumb-cell');
            if (cell) {
              cell.classList.remove('touch-selected');
            }
          }
        }
      }

      function handleTouchEnd(e) {
        const cell = e.target.closest('.thumb-cell');
        if (!cell) return;
        
        // Prevent any other event handlers
        e.stopPropagation();
        
        const idx = +cell.dataset.idx;
        const touchDuration = Date.now() - touchStartTime;
        
        // Calculate movement to detect if this was a scroll
        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        const deltaX = Math.abs(endX - touchStartX);
        const deltaY = Math.abs(endY - touchStartY);
        const hasMoved = deltaX > touchMoveThreshold || deltaY > touchMoveThreshold;
        
        cell.classList.remove('touch-selected');
        
        if (touchTimeout) {
          clearTimeout(touchTimeout);
          touchTimeout = null;
        }
        
        // Only handle tap if user didn't move finger significantly (not a scroll)
        if (!hasMoved && touchDuration < touchHoldThreshold) {
          // Short tap without movement
          if (touchMode === 'selection') {
            // In selection mode, toggle selection
            if (selectedThumbnails.has(idx)) {
              selectedThumbnails.delete(idx);
              // Exit selection mode if no items selected
              if (selectedThumbnails.size === 0) {
                touchMode = 'normal';
              }
            } else {
              selectedThumbnails.add(idx);
            }
            updateSelectionDisplay();
            updateTouchToolbar();
          } else {
            // Normal tap - show full size
            selectedThumbnails.clear();
            selectedThumbnails.add(idx);
            current = idx;
            showSingle('fit');
            updateSelectionDisplay();
          }
        }
        // If hasMoved is true, we ignore the tap and let scrolling work normally
      }

      function handleLongPress(idx, cell) {
        // Long press - enter selection mode
        touchMode = 'selection';
        selectedThumbnails.clear();
        selectedThumbnails.add(idx);
        updateSelectionDisplay();
        updateTouchToolbar();
        
        // Visual feedback
        cell.style.transform = 'scale(0.95)';
        setTimeout(() => {
          cell.style.transform = '';
        }, 200);
      }

      function updateTouchToolbar() {
        if (isTouchDevice) {
          const cullBtn = document.getElementById('touch-cull-btn');
          const clearBtn = document.getElementById('touch-clear-btn');
          const prevBtn = document.getElementById('touch-prev-btn');
          const nextBtn = document.getElementById('touch-next-btn');
          const finishBtn = document.getElementById('touch-finish-btn');
          const isInSingleView = singleview.classList.contains('visible');
          
          if (cullMode) {
            // In cull mode - show finish and clear buttons
            clearBtn.textContent = 'Clear';
            clearBtn.style.display = 'flex';
            cullBtn.style.display = 'none';
            finishBtn.style.display = 'flex';
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          } else if (isInSingleView) {
            // In single view mode - show back and navigation buttons
            clearBtn.textContent = 'Back';
            clearBtn.style.display = 'flex';
            cullBtn.style.display = 'none';
            finishBtn.style.display = 'none';
            // prevBtn.style.display = 'flex';  // Hidden - swiping is sufficient
            // nextBtn.style.display = 'flex';  // Hidden - swiping is sufficient
          } else if (selectedThumbnails.size > 1) {
            // Multiple items selected in thumbnail view
            clearBtn.textContent = 'Clear';
            cullBtn.textContent = 'Cull';
            cullBtn.style.display = 'flex';
            clearBtn.style.display = 'flex';
            finishBtn.style.display = 'none';
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          } else if (selectedThumbnails.size === 1 && touchMode === 'selection') {
            // Single item selected in selection mode
            clearBtn.textContent = 'Clear';
            cullBtn.style.display = 'none';
            clearBtn.style.display = 'flex';
            finishBtn.style.display = 'none';
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          } else {
            // Normal thumbnail view, no selection
            cullBtn.textContent = 'Cull';
            cullBtn.style.display = 'none';
            clearBtn.style.display = 'none';
            finishBtn.style.display = 'none';
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          }
        }
      }




      function addSwipeHandlers() {
        let startX = 0;
        let startY = 0;
        let endX = 0;
        let endY = 0;
        
        singleview.addEventListener('touchstart', (e) => {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        }, { passive: true });
        
        singleview.addEventListener('touchend', (e) => {
          endX = e.changedTouches[0].clientX;
          endY = e.changedTouches[0].clientY;
          
          const deltaX = endX - startX;
          const deltaY = endY - startY;
          const absDeltaX = Math.abs(deltaX);
          const absDeltaY = Math.abs(deltaY);
          
          // Require minimum swipe distance and ensure horizontal swipe
          if (absDeltaX > 50 && absDeltaX > absDeltaY * 2) {
            if (deltaX > 0) {
              // Swipe right - previous image
              handleArrow(-1, false);
            } else {
              // Swipe left - next image
              handleArrow(1, false);
            }
          }
        }, { passive: true });
      }

      // Command Palette Functions
      function openCommandPalette() {
        commandPaletteOpen = true;
        commandPaletteSelectedIndex = -1;
        commandPaletteItems = [];
        commandPaletteMode = null;
        commandPaletteSearchString = '';
        
        commandPalette.classList.add('visible');
        commandInput.value = '';
        commandInput.placeholder = 'Type a command...';
        commandInput.focus();
        
        // Show initial commands
        updateCommandPalette('');
      }
      
      function closeCommandPalette() {
        commandPaletteOpen = false;
        commandPaletteSelectedIndex = -1;
        commandPaletteItems = [];
        commandPaletteMode = null;
        commandPaletteSearchString = '';
        
        commandPalette.classList.remove('visible');
        commandInput.blur();
      }
      
      function navigateCommandPalette(direction) {
        if (commandPaletteItems.length === 0) return;
        
        let newIndex = commandPaletteSelectedIndex;
        const maxAttempts = commandPaletteItems.length;
        let attempts = 0;
        
        do {
          newIndex += direction;
          
          if (newIndex < 0) {
            newIndex = commandPaletteItems.length - 1;
          } else if (newIndex >= commandPaletteItems.length) {
            newIndex = 0;
          }
          
          attempts++;
        } while (commandPaletteItems[newIndex]?.placeholder && attempts < maxAttempts);
        
        commandPaletteSelectedIndex = newIndex;
        
        // Update visual selection
        const items = commandResults.querySelectorAll('.command-item:not(.command-mode-badge)');
        items.forEach((item, index) => {
          if (index === commandPaletteSelectedIndex) {
            item.classList.add('selected');
          } else {
            item.classList.remove('selected');
          }
        });
      }
      
      function executeSelectedCommand() {
        if (commandPaletteSelectedIndex >= 0 && commandPaletteItems[commandPaletteSelectedIndex]) {
          const command = commandPaletteItems[commandPaletteSelectedIndex];
          
          // Don't execute placeholder commands
          if (command.placeholder) {
            return;
          }
          
          if (command.id === 'gallery' && commandPaletteMode !== 'gallery') {
            // Enter gallery mode
            commandPaletteMode = 'gallery';
            commandInput.value = '';
            commandInput.placeholder = 'Enter search criteria (e.g., "Ben 27mm fuji", "2023 Canon")...';
            updateCommandPalette('');
          } else if (command.action) {
            // Execute the command
            command.action();
          }
        }
      }
      
      function updateCommandPalette(query) {
        if (commandPaletteMode === 'gallery') {
          // In gallery mode - show gallery creation options
          commandPaletteSearchString = query;
          const galleryCommands = getGalleryCommands(query);
          commandPaletteItems = galleryCommands;
          commandPaletteSelectedIndex = galleryCommands.length > 0 ? 0 : -1;
          renderCommandPalette(galleryCommands, query);
        } else {
          // Normal command mode
          const commands = getAvailableCommands();
          const filteredCommands = filterCommands(commands, query);
          commandPaletteItems = filteredCommands;
          commandPaletteSelectedIndex = filteredCommands.length > 0 ? 0 : -1;
          renderCommandPalette(filteredCommands, query);
        }
      }
      
      function getAvailableCommands() {
        return [
          {
            id: 'gallery',
            title: 'Create Gallery',
            subtitle: 'Create a new gallery from search criteria',
            icon: '🖼️',
            keywords: ['gallery', 'create', 'new', 'search'],
            category: 'gallery'
          },
          {
            id: 'regenerate-raw-picks',
            title: 'Regenerate RAW Picks',
            subtitle: 'Process picked RAW files with custom RawTherapee settings',
            icon: '🎞️',
            keywords: ['raw', 'picks', 'regenerate', 'process', 'rawtherapee'],
            category: 'processing',
            action: () => {
              closeCommandPalette();
              executeRegenerateRawPicks();
            }
          },
          {
            id: 'delete-rejects',
            title: 'Delete Rejected Images',
            subtitle: 'Permanently delete all rejected images and cleanup files',
            icon: '🗑️',
            keywords: ['delete', 'rejects', 'cull', 'remove', 'cleanup'],
            category: 'management',
            action: () => {
              closeCommandPalette();
              executeDeleteRejects();
            }
          },
          {
            id: 'stats-dashboard',
            title: 'Stats Dashboard',
            subtitle: 'View comprehensive database statistics and analytics',
            icon: '📊',
            keywords: ['stats', 'statistics', 'dashboard', 'analytics', 'data', 'charts'],
            category: 'analytics',
            action: () => {
              closeCommandPalette();
              showStatsDashboard();
            }
          },
          {
            id: 'rebuild-current-gallery',
            title: 'Rebuild Current Gallery JSON',
            subtitle: 'Regenerate image_data.json for the currently loaded gallery',
            icon: '🔨',
            keywords: ['rebuild', 'gallery', 'json', 'refresh', 'regenerate', 'current'],
            category: 'maintenance',
            action: () => {
              closeCommandPalette();
              executeRebuildCurrentGallery();
            }
          },
          {
            id: 'rebuild-galleries-list',
            title: 'Rebuild Galleries List',
            subtitle: 'Regenerate the main galleries.json list from all gallery folders',
            icon: '📋',
            keywords: ['rebuild', 'galleries', 'list', 'refresh', 'scan', 'main'],
            category: 'maintenance',
            action: () => {
              closeCommandPalette();
              executeRebuildGalleriesList();
            }
          },
          {
            id: 'rename-current-gallery',
            title: 'Rename Current Gallery',
            subtitle: 'Rename the currently loaded gallery folder',
            icon: '📝',
            keywords: ['rename', 'gallery', 'name', 'change', 'current'],
            category: 'maintenance',
            action: () => {
              closeCommandPalette();
              executeRenameCurrentGallery();
            }
          },
          {
            id: 'delete-current-gallery',
            title: 'Delete Current Gallery',
            subtitle: '⚠️ Permanently delete the currently loaded gallery folder and all its hard links',
            icon: '🗑️',
            keywords: ['delete', 'gallery', 'remove', 'destroy', 'current'],
            category: 'maintenance',
            action: () => {
              closeCommandPalette();
              executeDeleteCurrentGallery();
            }
          },
          {
            id: 'process-new-images',
            title: 'Process New Images',
            subtitle: 'Extract metadata, detect faces, cluster faces, and generate thumbnails for new images',
            icon: '🚀',
            keywords: ['process', 'new', 'images', 'metadata', 'faces', 'cluster', 'thumbnails'],
            category: 'processing',
            action: () => {
              closeCommandPalette();
              executeProcessNewImages();
            }
          }
        ];
      }
      
      async function executeRegenerateRawPicks() {
        if (picks.size === 0) {
          alert('No picks selected. Mark some RAW images as picks first.');
          return;
        }
        
        const confirmed = confirm(`Regenerate ${picks.size} picked RAW files with custom RawTherapee processing?\n\nThis will:\n• Process RAW files with enhanced settings\n• Update existing proxies\n• Regenerate thumbnails\n\nThis may take several minutes.`);
        
        if (!confirmed) return;
        
        try {
          // Call the regenerate RAW picks script via photo manager
          const response = await fetch('/api/regenerate-raw-picks', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (response.ok) {
            alert('✅ RAW picks regeneration started! Check console for progress.');
          } else {
            alert('❌ Failed to start RAW picks regeneration. Make sure the server is running.');
          }
        } catch (error) {
          console.error('Error executing regenerate RAW picks:', error);
          alert('❌ Error starting RAW picks regeneration. Try running manually via photo_manager.py');
        }
      }
      
      let deleteInProgress = false;
      
      async function executeDeleteRejects() {
        if (deleteInProgress) {
          console.log('Delete already in progress, ignoring duplicate call');
          return;
        }
        
        if (rejects.size === 0) {
          alert('No images rejected. Mark some images as rejects first.');
          return;
        }
        
        deleteInProgress = true;
        
        try {
          // First, get a preview of what will be deleted
          const previewResponse = await fetch(`http://${window.location.hostname}:8001/api/delete-rejects-preview`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (!previewResponse.ok) {
            alert('❌ Failed to get deletion preview. Make sure the server is running.');
            deleteInProgress = false;
            return;
          }
          
          const previewData = await previewResponse.json();
          const preview = previewData.preview;
          
          // Show preview to user
          let previewMessage = `🗑️ DELETE PREVIEW\n\n`;
          previewMessage += `Total images to delete: ${preview.total_images}\n`;
          previewMessage += `Files found in database: ${preview.files_found}\n\n`;
          
          let totalFilesToDelete = 0;
          preview.files.forEach(file => {
            previewMessage += `📸 ${file.filename} (ID: ${file.id})\n`;
            file.files_to_delete.forEach(fileInfo => {
              const status = fileInfo.exists ? '✓' : '❌';
              previewMessage += `   ${status} ${fileInfo.type}: ${fileInfo.path}\n`;
              if (fileInfo.exists) totalFilesToDelete++;
            });
            previewMessage += `\n`;
          });
          
          previewMessage += `\n⚠️ This will permanently delete ${totalFilesToDelete} files!\n`;
          previewMessage += `🚨 THIS ACTION CANNOT BE UNDONE! 🚨\n\n`;
          previewMessage += `Type 'DELETE' to confirm:`;
          
          // Show confirmation dialog with preview
          const confirmation = prompt(previewMessage);
          if (confirmation !== 'DELETE') {
            alert('Deletion cancelled - confirmation text did not match.');
            deleteInProgress = false;
            return;
          }
          
          // Proceed with actual deletion
          const deleteResponse = await fetch(`http://${window.location.hostname}:8001/api/delete-rejects`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (deleteResponse.ok) {
            const deleteResult = await deleteResponse.json();
            alert(`✅ ${deleteResult.message}\n\nThe page will now refresh to update the gallery.`);
            // Clear rejects from UI since they're being deleted
            rejects.clear();
            updatePickClasses();
            // Refresh the page to reload with updated galleries
            window.location.reload();
          } else {
            const errorData = await deleteResponse.json().catch(() => ({ error: 'Unknown error' }));
            alert(`❌ Deletion failed: ${errorData.error || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error executing delete rejects:', error);
          alert('❌ Error with deletion process. Check console for details.');
        } finally {
          deleteInProgress = false;
        }
      }
      
      async function showStatsDashboard() {
        try {
          // Fetch stats from API
          const response = await fetch(`http://${window.location.hostname}:8001/api/stats`);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const stats = await response.json();
          
          // Create stats dashboard UI
          const dashboard = document.createElement('div');
          dashboard.id = 'stats-dashboard';
          dashboard.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            color: #fff;
            font-family: system-ui, sans-serif;
          `;
          
          dashboard.innerHTML = `
            <div style="max-width: 1200px; margin: 0 auto;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <h1 style="margin: 0; color: #fff; font-size: 32px; font-weight: 300;">📊 Database Statistics</h1>
                <button onclick="document.getElementById('stats-dashboard').remove()" 
                        style="background: #ff4444; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 16px;">Close</button>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                ${createStatsSection('Overview', stats.overview)}
                ${createStatsSection('By Camera', stats.cameras)}
                ${createStatsSection('By Lens', stats.lenses)}
                ${createStatsSection('By Focal Length (35mm)', stats.focal_lengths)}
                ${createStatsSection('By Year', stats.years)}
                ${createStatsSection('By Face', stats.faces)}
                ${createStatsSection('File Types', stats.file_types)}
                ${createStatsSection('Pick/Reject Status', stats.status)}
              </div>
            </div>
          `;
          
          document.body.appendChild(dashboard);
          
          // Close on Escape key
          const closeHandler = (e) => {
            if (e.key === 'Escape') {
              dashboard.remove();
              document.removeEventListener('keydown', closeHandler);
            }
          };
          document.addEventListener('keydown', closeHandler);
          
        } catch (error) {
          console.error('Error loading stats:', error);
          alert(`Error loading stats: ${error.message}`);
        }
      }
      
      function createStatsSection(title, data) {
        if (!data || (Array.isArray(data) && data.length === 0)) {
          return `
            <div style="background: #2a2a2a; border-radius: 8px; padding: 20px; border: 1px solid #444; display: flex; flex-direction: column; height: 400px;">
              <h3 style="margin: 0 0 15px 0; color: #ccc; font-size: 18px;">${title}</h3>
              <p style="color: #999; margin: 0;">No data available</p>
            </div>
          `;
        }

        let content = `
          <div style="background: #2a2a2a; border-radius: 8px; padding: 20px; border: 1px solid #444; display: flex; flex-direction: column; height: 400px;">
            <h3 style="margin: 0 0 15px 0; color: #ccc; font-size: 18px; flex-shrink: 0;">${title}</h3>
            <div style="flex: 1; overflow-y: auto; overflow-x: hidden; padding-right: 10px;">
        `;

        if (typeof data === 'object' && !Array.isArray(data)) {
          // Simple key-value pairs
          for (const [key, value] of Object.entries(data)) {
            content += `
              <div style="display: flex; justify-content: space-between; margin-bottom: 8px; padding: 4px 0;">
                <span style="color: #ddd;">${key}</span>
                <span style="color: #4CAF50; font-weight: 600; margin-left: 10px; white-space: nowrap;">${value.toLocaleString()}</span>
              </div>
            `;
          }
        } else if (Array.isArray(data)) {
          // Array of objects with counts - show ALL items
          data.forEach(item => {
            const name = item.name || item.camera || item.lens || item.focal_length || item.year || item.person || item.type || item.status || 'Unknown';
            content += `
              <div style="display: flex; justify-content: space-between; margin-bottom: 8px; padding: 4px 0;">
                <span style="color: #ddd; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 10px;" title="${name}">${name}</span>
                <span style="color: #4CAF50; font-weight: 600; white-space: nowrap;">${item.count.toLocaleString()}</span>
              </div>
            `;
          });
        }

        content += '</div></div>';
        return content;
      }
      
      async function executeRebuildCurrentGallery() {
        if (!currentGallery) {
          alert('No gallery currently loaded. Please load a gallery first.');
          return;
        }
        
        // Extract gallery path from currentGallery JSON path
        const galleryPath = currentGallery.replace('/image_data.json', '');
        const galleryName = galleryPath.split('/').pop();
        
        const confirmed = confirm(`Rebuild gallery JSON for "${galleryName}"?\n\nThis will:\n• Regenerate image_data.json from database\n• Update metadata and thumbnails\n• Refresh the current gallery view\n\nThis may take a few moments.`);
        
        if (!confirmed) return;
        
        try {
          showCommandLoading('Rebuilding gallery JSON...');
          
          const response = await fetch(`http://${window.location.hostname}:8001/api/rebuild-gallery-json`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ gallery_path: galleryPath })
          });
          
          if (response.ok) {
            const result = await response.json();
            alert(`✅ Gallery JSON rebuilt successfully!\n\n${result.message}`);
            
            // Reload the current gallery to show updated data
            location.reload();
          } else {
            const errorText = await response.text();
            alert(`❌ Failed to rebuild gallery JSON: ${errorText}`);
          }
        } catch (error) {
          console.error('Error rebuilding gallery JSON:', error);
          alert('❌ Error rebuilding gallery JSON. Check console for details.');
        }
      }
      
      async function executeRebuildGalleriesList() {
        const confirmed = confirm('Rebuild the main galleries list?\n\nThis will:\n• Scan all gallery folders\n• Regenerate galleries.json\n• Update the gallery selector\n\nThis may take a few moments.');
        
        if (!confirmed) return;
        
        try {
          showCommandLoading('Rebuilding galleries list...');
          
          const response = await fetch(`http://${window.location.hostname}:8001/api/rebuild-galleries-list`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (response.ok) {
            const result = await response.json();
            alert(`✅ Galleries list rebuilt successfully!\n\n${result.message}`);
            
            // Reload the page to refresh the gallery selector
            location.reload();
          } else {
            const errorText = await response.text();
            alert(`❌ Failed to rebuild galleries list: ${errorText}`);
          }
        } catch (error) {
          console.error('Error rebuilding galleries list:', error);
          alert('❌ Error rebuilding galleries list. Check console for details.');
        }
      }
      
      async function executeRenameCurrentGallery() {
        if (!currentGallery) {
          alert('No gallery currently loaded. Please load a gallery first.');
          return;
        }

        const galleryPath = currentGallery.replace('/image_data.json', '');
        const currentName = galleryPath.split('/').pop();

        // Prompt for new name
        const newName = prompt(`Rename gallery "${currentName}"\n\nEnter new name:`, currentName);

        if (!newName) {
          return; // User cancelled
        }

        if (newName === currentName) {
          alert('New name is the same as current name. No changes made.');
          return;
        }

        // Validate new name
        if (newName.includes('/') || newName.includes('\\') || newName.includes('..')) {
          alert('❌ Invalid name: Cannot contain path separators (/ or \\) or ".."');
          return;
        }

        if (newName.length > 100) {
          alert('❌ Name too long: Maximum 100 characters allowed');
          return;
        }

        try {
          showCommandLoading('Renaming gallery...');

          const response = await fetch(`http://${window.location.hostname}:8002/api/rename-gallery`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              old_path: galleryPath,
              new_name: newName
            })
          });

          if (response.ok) {
            const result = await response.json();
            alert(`✅ Gallery renamed successfully!\n\n${result.message}`);

            // Refresh galleries list and redirect to home
            await loadGalleries(true);  // Force reload after rename
            showGallerySelectionMessage();

          } else {
            const errorData = await response.text();
            alert(`❌ Failed to rename gallery:\n\n${errorData}`);
          }
        } catch (error) {
          console.error('Error in gallery rename process:', error);
          alert(`❌ Error renaming gallery: ${error.message}`);
        }

        hideCommandLoading();
      }

      async function executeDeleteCurrentGallery() {
        if (!currentGallery) {
          alert('No gallery currently loaded. Please load a gallery first.');
          return;
        }
        
        const galleryPath = currentGallery.replace('/image_data.json', '');
        const galleryName = galleryPath.split('/').pop();
        
        // First confirmation
        const firstConfirmed = confirm(`⚠️ DELETE GALLERY: "${galleryName}"?\n\n🚨 WARNING: This action CANNOT be undone!\n\nThis will permanently delete:\n• The entire gallery folder\n• All hard-linked image files in the gallery\n• Gallery metadata and configuration\n\n❌ Original photos in "Master Photo Library" will NOT be affected\n\nAre you sure you want to continue?`);
        
        if (!firstConfirmed) return;
        
        // Second confirmation with typing requirement
        const typedConfirmation = prompt(`⚠️ FINAL CONFIRMATION\n\nTo permanently delete the gallery "${galleryName}", type: DELETE\n\n(Type exactly: DELETE)`);
        
        if (typedConfirmation !== 'DELETE') {
          if (typedConfirmation !== null) {
            alert('❌ Deletion cancelled. You must type exactly "DELETE" to confirm.');
          }
          return;
        }
        
        try {
          showCommandLoading('Deleting gallery... This cannot be undone.');
          
          // Call the new gallery deletion API
          const response = await fetch(`http://${window.location.hostname}:8002/api/delete-gallery`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ gallery_path: galleryPath })
          });
          
          if (response.ok) {
            const result = await response.json();
            alert(`✅ Gallery deleted successfully!\n\n${result.message}`);
            
            // Refresh galleries list and redirect to home
            await loadGalleries(true);  // Force reload after deletion
            showGallerySelectionMessage();
            
          } else {
            const errorData = await response.text();
            alert(`❌ Failed to delete gallery:\n\n${errorData}\n\nYou may need to delete manually:\nrm -rf "${galleryPath}"`);
          }
        } catch (error) {
          console.error('Error in gallery deletion process:', error);
          alert(`❌ Please manually delete the folder:\n\nrm -rf "${galleryPath}"\n\nThen refresh the page.`);
        }
      }
      
      async function executeProcessNewImages() {
        const confirmed = confirm('Process new images?\n\nThis will:\n• Extract metadata from new images\n• Detect faces in new images\n• Cluster new faces with existing ones\n• Generate thumbnails for new images\n\nThis may take several minutes depending on the number of new images.\n\nProgress will be shown in the Status Feed at the bottom of the sidebar.');
        
        if (!confirmed) return;
        
        try {
          showCommandLoading('Processing new images...');
          
          const result = await trackOperationWithLogPolling(
            'Process New Images', 
            `http://${window.location.hostname}:8001/api/process-new-images`,
            { directory: 'Master Photo Library' }
          );
          
          alert(`✅ New images processing started!\n\n${result.message}\n\nProgress will continue to show in the Status Feed below.`);
        } catch (error) {
          console.error('Error processing new images:', error);
        }
      }
      
      function getGalleryCommands(searchString) {
        const commands = [];
        
        if (searchString.trim()) {
          // Show the main create gallery command with the search string
          commands.push({
            id: 'create-gallery',
            title: 'Create Gallery',
            subtitle: `Search: "${searchString}"`,
            icon: '🖼️',
            searchString: searchString,
            action: () => {
              createGalleryFromCommand(searchString);
            }
          });
        } else {
          // Show placeholder when no search string
          commands.push({
            id: 'gallery-placeholder',
            title: 'Create Gallery',
            subtitle: 'Start typing search criteria...',
            icon: '🖼️',
            placeholder: true
          });
        }
        
        // Add special options
        commands.push({
          id: 'gallery-face-samples',
          title: 'Face Sample Gallery',
          subtitle: 'Create gallery with one image per person',
          icon: '👥',
          action: () => {
            createFaceSampleGallery();
          }
        });
        
        commands.push({
          id: 'gallery-picks',
          title: 'Picks Gallery',
          subtitle: 'Create gallery from saved picks',
          icon: '📋',
          action: () => {
            createPicksGallery(searchString);
          }
        });
        
        return commands;
      }
      
      function filterCommands(commands, query) {
        if (!query) return commands;
        
        const lowerQuery = query.toLowerCase();
        return commands.filter(command => {
          // Check if query starts with command keywords
          const matchesKeyword = command.keywords.some(keyword => 
            keyword.toLowerCase().startsWith(lowerQuery) || 
            lowerQuery.startsWith(keyword.toLowerCase())
          );
          
          // For gallery command, if query starts with "gallery", show it
          if (command.id === 'gallery' && lowerQuery.startsWith('gallery')) {
            return true;
          }
          
          return matchesKeyword || 
                 command.title.toLowerCase().includes(lowerQuery) ||
                 command.subtitle.toLowerCase().includes(lowerQuery);
        });
      }
      
      function renderCommandPalette(commands, query) {
        commandResults.innerHTML = '';
        
        // Add mode badge if in gallery mode
        if (commandPaletteMode === 'gallery') {
          const badge = document.createElement('div');
          badge.className = 'command-mode-badge';
          badge.innerHTML = `
            <div class="command-badge-content">
              <span class="command-badge-icon">🖼️</span>
              <span class="command-badge-text">Gallery</span>
            </div>
          `;
          commandResults.appendChild(badge);
        }
        
        if (commands.length === 0) {
          const noResults = document.createElement('div');
          noResults.className = 'command-item';
          noResults.innerHTML = `
            <div class="command-item-left">
              <div class="command-icon">❓</div>
              <div class="command-details">
                <div class="command-title">No commands found</div>
                <div class="command-subtitle">${commandPaletteMode ? 'Try a different search' : 'Try typing "gallery" to create a new gallery'}</div>
              </div>
            </div>
          `;
          commandResults.appendChild(noResults);
          return;
        }
        
        commands.forEach((command, index) => {
          const item = document.createElement('div');
          const isPlaceholder = command.placeholder;
          const isSelected = index === commandPaletteSelectedIndex;
          
          item.className = `command-item ${isSelected ? 'selected' : ''} ${isPlaceholder ? 'disabled' : ''}`;
          
          item.innerHTML = `
            <div class="command-item-left">
              <div class="command-icon">${command.icon}</div>
              <div class="command-details">
                <div class="command-title">${command.title}</div>
                <div class="command-subtitle">${command.subtitle}</div>
              </div>
            </div>
            ${!isPlaceholder ? '<div class="command-shortcut">⏎</div>' : ''}
          `;
          
          if (!isPlaceholder) {
            item.addEventListener('click', () => {
              commandPaletteSelectedIndex = index;
              executeSelectedCommand();
            });
          }
          
          commandResults.appendChild(item);
        });
      }
      
      async function createGalleryFromCommand(searchString) {
        // Generate gallery name from search string
        const galleryName = generateGalleryName(searchString);
        
        showCommandLoading('Creating gallery...');
        
        try {
          const result = await trackOperation(
            `Create Gallery: ${galleryName}`, 
            `${API_BASE_URL}/api/create-gallery`,
            { search_string: searchString, gallery_name: galleryName }
          );
          
          closeCommandPalette();
          
          // Refresh galleries list
          await loadGalleries(true);  // Force reload after creation
          // Refresh gallery selector UI
          renderGalleries();
          alert(`Gallery "${result.gallery_name}" created successfully!`);
        } catch (error) {
          console.error('Error creating gallery:', error);
          closeCommandPalette();
        }
      }
      
      async function createFaceSampleGallery() {
        const galleryName = 'Face Samples';
        
        showCommandLoading('Creating face sample gallery...');
        
        try {
          const response = await fetch(`${API_BASE_URL}/api/create-gallery`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              face_samples: true,
              gallery_name: galleryName
            })
          });
          
          const result = await response.json();
          
          closeCommandPalette();
          
          if (response.ok && result.success) {
            await loadGalleries(true);  // Force reload after creation
            renderGalleries();
            alert(`Gallery "${result.gallery_name}" created successfully!`);
          } else {
            alert(`Failed to create gallery: ${result.message || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error creating gallery:', error);
          closeCommandPalette();
          alert(`Error creating gallery: ${error.message}`);
        }
      }
      
      async function createPicksGallery(searchString = '') {
        const galleryName = searchString.trim() ? generateGalleryName(searchString) : 'Picks Gallery';
        
        showCommandLoading('Creating picks gallery...');
        
        try {
          const response = await fetch(`${API_BASE_URL}/api/create-gallery`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              picks_file: 'JSON/picks.json', // Use default picks file
              gallery_name: galleryName
            })
          });
          
          const result = await response.json();
          
          closeCommandPalette();
          
          if (response.ok && result.success) {
            await loadGalleries(true);  // Force reload after creation
            alert(`Gallery "${result.gallery_name}" created successfully!`);
          } else {
            alert(`Failed to create gallery: ${result.message || 'Unknown error'}`);
          }
        } catch (error) {
          console.error('Error creating gallery:', error);
          closeCommandPalette();
          alert(`Error creating gallery: ${error.message}`);
        }
      }
      
      function generateGalleryName(searchString) {
        // Generate a reasonable gallery name from search string
        const cleaned = searchString.replace(/[^a-zA-Z0-9\s-]/g, '').trim();
        if (!cleaned) return 'New Gallery';
        return cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
      }
      
      function showCommandLoading(message) {
        commandResults.innerHTML = `
          <div class="command-loading">
            <div class="spinner"></div>
            ${message}
          </div>
        `;
      }
      
      // Status Feed Management
      let statusFeedPollInterval = null;
      let statusFeedLogOffset = 0;
      
      function showStatusFeed() {
        const statusFeed = document.getElementById('status-feed');
        if (statusFeed) {
          statusFeed.classList.remove('hidden');
          startStatusFeedPolling();
          localStorage.setItem('statusFeedVisible', 'true');
        }
      }
      
      function hideStatusFeed() {
        const statusFeed = document.getElementById('status-feed');
        if (statusFeed) {
          statusFeed.classList.add('hidden');
          stopStatusFeedPolling();
          localStorage.setItem('statusFeedVisible', 'false');
        }
      }
      
      function toggleStatusFeed() {
        const statusFeed = document.getElementById('status-feed');
        if (statusFeed) {
          if (statusFeed.classList.contains('hidden')) {
            showStatusFeed();
          } else {
            hideStatusFeed();
          }
        }
      }
      
      function startStatusFeedPolling() {
        if (statusFeedPollInterval) {
          clearInterval(statusFeedPollInterval);
        }
        
        // Start polling for progress updates
        const pollProgress = async () => {
          try {
            const response = await fetch(`http://${window.location.hostname}:8001/api/progress-log?offset=${statusFeedLogOffset}`);
            if (response.ok) {
              const data = await response.json();
              if (data.entries && data.entries.length > 0) {
                // Add new log entries to status feed
                data.entries.forEach(entry => {
                  addStatusMessage(entry.message, entry.type, entry.timestamp);
                });
                statusFeedLogOffset = data.total_lines;
              }
            }
          } catch (e) {
            console.log('Error polling progress log:', e);
          }
        };
        
        // If this is the first time opening the feed and it's empty, start from beginning
        const statusContent = document.getElementById('status-feed-content');
        if (statusContent && statusContent.children.length === 0) {
          statusFeedLogOffset = 0;
        }
        
        // Poll immediately to get any existing entries
        pollProgress();
        
        // Start polling every 2 seconds
        statusFeedPollInterval = setInterval(pollProgress, 2000);
      }
      
      function stopStatusFeedPolling() {
        if (statusFeedPollInterval) {
          clearInterval(statusFeedPollInterval);
          statusFeedPollInterval = null;
        }
      }
      
      function addStatusMessage(message, type = 'info', customTimestamp = null) {
        const statusContent = document.getElementById('status-feed-content');
        if (!statusContent) return;
        
        const timestamp = customTimestamp || new Date().toLocaleTimeString('en-US', { 
          hour12: false, 
          timeZone: 'UTC' 
        }).substring(0, 5);
        
        const entry = document.createElement('div');
        entry.className = `status-entry ${type}`;
        entry.innerHTML = `
          <span class="status-timestamp">${timestamp}</span>
          <span class="status-message">${message}</span>
        `;
        
        statusContent.appendChild(entry);
        statusContent.scrollTop = statusContent.scrollHeight;
      }
      
      function clearStatusFeed() {
        const statusContent = document.getElementById('status-feed-content');
        if (statusContent) {
          statusContent.innerHTML = '';
        }
        hideStatusFeed();
      }
      
      // Enhanced progress tracking for long operations
      function trackOperation(operationName, endpoint, data = {}) {
        addStatusMessage(`🚀 Starting ${operationName}...`, 'info');
        
        // For now, use traditional fetch
        // TODO: Replace with Server-Sent Events for real-time updates
        return fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        }).then(response => {
          if (response.ok) {
            return response.json().then(result => {
              addStatusMessage(`✅ ${operationName} completed successfully`, 'success');
              if (result.message) {
                addStatusMessage(result.message, 'info');
              }
              return result;
            });
          } else {
            return response.json().then(error => {
              addStatusMessage(`❌ ${operationName} failed: ${error.error || 'Unknown error'}`, 'error');
              throw new Error(error.error || 'Operation failed');
            });
          }
        }).catch(error => {
          addStatusMessage(`❌ ${operationName} failed: ${error.message}`, 'error');
          throw error;
        });
      }
      
      // Enhanced progress tracking with log file polling
      function trackOperationWithLogPolling(operationName, endpoint, data = {}) {
        return new Promise((resolve, reject) => {
          addStatusMessage(`🚀 Starting ${operationName}...`, 'info');
          
          let logOffset = 0;
          let pollInterval;
          
          // Start polling for progress updates
          const pollProgress = async () => {
            try {
              const response = await fetch(`http://${window.location.hostname}:8001/api/progress-log?offset=${logOffset}`);
              if (response.ok) {
                const data = await response.json();
                if (data.entries && data.entries.length > 0) {
                  // Add new log entries to status feed
                  data.entries.forEach(entry => {
                    addStatusMessage(entry.message, entry.type, entry.timestamp);
                  });
                  logOffset = data.total_lines;
                }
              }
            } catch (e) {
              console.log('Error polling progress log:', e);
            }
          };
          
          // Start polling every 2 seconds
          pollInterval = setInterval(pollProgress, 2000);
          
          // Start the actual operation
          fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          }).then(response => {
            if (response.ok) {
              return response.json().then(result => {
                // Continue polling for a bit after the API returns
                setTimeout(() => {
                  clearInterval(pollInterval);
                  addStatusMessage(`✅ ${operationName} completed`, 'success');
                }, 5000); // Poll for 5 more seconds
                
                resolve(result);
              });
            } else {
              clearInterval(pollInterval);
              return response.json().then(error => {
                addStatusMessage(`❌ ${operationName} failed: ${error.error || 'Unknown error'}`, 'error');
                reject(new Error(error.error || 'Operation failed'));
              });
            }
          }).catch(error => {
            clearInterval(pollInterval);
            addStatusMessage(`❌ ${operationName} failed: ${error.message}`, 'error');
            reject(error);
          });
        });
      }
      
      // Command input event listener
      commandInput.addEventListener('input', (e) => {
        updateCommandPalette(e.target.value);
      });
      
      // Command input keydown handler for special keys
      commandInput.addEventListener('keydown', (e) => {
        if (e.key === "/" && !e.ctrlKey && !e.metaKey) {
          // Close command palette if / is pressed while it's focused
          console.log('Closing command palette via / key');
          closeCommandPalette();
          e.preventDefault();
          e.stopPropagation();
          return;
        }
      });
      
      // Close command palette when clicking outside
      commandPalette.addEventListener('click', (e) => {
        if (e.target === commandPalette) {
          closeCommandPalette();
        }
      });

      // Initialize status feed visibility from localStorage
      function initializeStatusFeed() {
        const statusFeedVisible = localStorage.getItem('statusFeedVisible');
        if (statusFeedVisible === 'true') {
          showStatusFeed();
        }
      }
      
      // Update exposure display value
      function updateExposureDisplay(imageId, value) {
        const numValue = parseFloat(value);
        const displayValue = numValue >= 0 ? '+' + numValue : numValue;
        const displayElement = document.getElementById('exposure-value-' + imageId);
        if (displayElement) {
          displayElement.textContent = displayValue + ' EV';
        }
      }

      // Gallery selection message
      function showGallerySelectionMessage() {
        // Clear existing content
        images = [];
        current = 0;
        currentGallery = null; // Reset current gallery so keyboard navigation works
        
        // Create selection message
        const message = `
          <div style="
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #181818;
            padding: 40px;
            text-align: center;
            color: #ccc;
            font-family: system-ui, -apple-system, sans-serif;
            box-sizing: border-box;
            z-index: 150;
          ">
            <div style="
              font-size: 48px;
              margin-bottom: 24px;
              opacity: 0.6;
            ">📸</div>
            <h2 style="
              font-size: 28px;
              margin: 0 0 16px 0;
              color: #fff;
              font-weight: 300;
            ">Select a Gallery</h2>
            <p style="
              font-size: 16px;
              margin: 0 0 24px 0;
              opacity: 0.8;
              max-width: 400px;
              line-height: 1.5;
            ">Choose a gallery from the sidebar to view your photos. Use the arrow keys to navigate the gallery list.</p>
            <div style="
              font-size: 14px;
              opacity: 0.6;
              padding: 16px 24px;
              background: rgba(255,255,255,0.05);
              border-radius: 8px;
              border: 1px solid rgba(255,255,255,0.1);
            ">
              📋 ${galleries.length} galleries available
            </div>
          </div>
        `;
        
        // Update thumbnail grid with message
        thumbgrid.innerHTML = message;
        
        // Clear single view but preserve the img and video elements
        const bigimgWrap = document.querySelector('#singleview .bigimg-wrap');
        if (bigimgWrap) {
          bigimgWrap.innerHTML = `
            <img id="bigimg" class="bigimg" draggable="false" />
            <video id="bigvideo" class="bigvideo" controls></video>
          `;
        }
        
        // Update mode and navigation
        mode = "thumbs";
        const singleViewEl = document.getElementById('single-view');
        const gridViewEl = document.getElementById('grid-view');
        if (singleViewEl) singleViewEl.classList.remove('active');
        if (gridViewEl) gridViewEl.classList.add('active');
        
        // Clear selections
        selectedThumbnails.clear();
        updateSelectionDisplay();
      }

      // Sorting functionality
      let currentSortOrder = 'oldest'; // Default to oldest first
      
      function sortImages(order) {
        if (!images || images.length === 0) return;
        
        const sortedImages = [...images].sort((a, b) => {
          // Normalize date strings to handle timezone inconsistencies between videos and photos
          function normalizeDate(dateStr) {
            if (!dateStr) return 0;
            
            // If date already has timezone info (videos), use as-is
            if (dateStr.includes('+') || dateStr.includes('Z')) {
              return new Date(dateStr);
            }
            
            // If no timezone info (photos), treat as UTC to match videos
            // Convert "2025-09-06 16:41:10" to "2025-09-06T16:41:10Z"
            const normalizedStr = dateStr.replace(' ', 'T') + 'Z';
            return new Date(normalizedStr);
          }
          
          // Try different date fields, prioritizing DateTimeOriginal
          const dateA = normalizeDate(a.DateTimeOriginal || a.DateTime || a.FileModifyDate);
          const dateB = normalizeDate(b.DateTimeOriginal || b.DateTime || b.FileModifyDate);
          
          if (order === 'oldest') {
            return dateA - dateB; // Oldest first
          } else {
            return dateB - dateA; // Newest first  
          }
        });
        
        // Update global images array
        images = sortedImages;
        currentSortOrder = order;
        
        // Update button states
        document.getElementById('sort-oldest').classList.toggle('active', order === 'oldest');
        document.getElementById('sort-newest').classList.toggle('active', order === 'newest');
        
        // Re-render thumbnails with new order
        renderThumbnails();
        
        // Reset current index to 0 to show first image in new order
        current = 0;
        if (mode === "single") {
          loadImage(current);
        }
        
        // Update preload queue with new order
        createPreloadQueue();
      }
      
      function initializeSortControls() {
        document.getElementById('sort-oldest').addEventListener('click', () => {
          if (currentSortOrder !== 'oldest') {
            sortImages('oldest');
          }
        });
        
        document.getElementById('sort-newest').addEventListener('click', () => {
          if (currentSortOrder !== 'newest') {
            sortImages('newest');
          }
        });
      }

      // Initialize touch support and status feed after page loads
      document.addEventListener('DOMContentLoaded', function() {
        initializeTouchSupport();
        initializeStatusFeed();
        initializeSortControls();
        
        // Initialize picks and rejects from server
        initializePicksAndRejects();
        
        // Add click handler to gallery selector for focusing
        const gallerySelector = document.getElementById('gallery-selector');
        if (gallerySelector) {
          gallerySelector.addEventListener('click', function(e) {
            // Only focus if clicking on the selector itself or header, not on gallery items
            if (e.target === gallerySelector || e.target.classList.contains('gallery-header')) {
              focusGallerySelector();
            }
          });
        }
      });
    </script>
  </body>
</html>
